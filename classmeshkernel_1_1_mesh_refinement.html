<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::MeshRefinement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html">MeshRefinement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmeshkernel_1_1_mesh_refinement-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">meshkernel::MeshRefinement Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class used to refine a <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> instance.  
 <a href="classmeshkernel_1_1_mesh_refinement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mesh_refinement_8hpp_source.html">MeshRefinement.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4070f77223ce02f79118a4209dcf3c34" id="r_a4070f77223ce02f79118a4209dcf3c34"><td class="memItemLeft" align="right" valign="top"><a id="a4070f77223ce02f79118a4209dcf3c34" name="a4070f77223ce02f79118a4209dcf3c34"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html#a4070f77223ce02f79118a4209dcf3c34">RefinementType</a> { <b>WaveCourant</b> = 1
, <b>RefinementLevels</b> = 2
, <b>RidgeDetection</b> = 3
 }</td></tr>
<tr class="memdesc:a4070f77223ce02f79118a4209dcf3c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different refinement types. <br /></td></tr>
<tr class="separator:a4070f77223ce02f79118a4209dcf3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39b794046c5473659de82822b7d03b1c" id="r_a39b794046c5473659de82822b7d03b1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html#a39b794046c5473659de82822b7d03b1c">MeshRefinement</a> (<a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh_interpolation.html">MeshInterpolation</a> &gt; interpolant, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;meshRefinementParameters)</td></tr>
<tr class="memdesc:a39b794046c5473659de82822b7d03b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for refining based on samples.  <br /></td></tr>
<tr class="separator:a39b794046c5473659de82822b7d03b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c699e45ed875a962b1ea73cf63c31b0" id="r_a7c699e45ed875a962b1ea73cf63c31b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html#a7c699e45ed875a962b1ea73cf63c31b0">MeshRefinement</a> (<a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh_interpolation.html">MeshInterpolation</a> &gt; interpolant, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;meshRefinementParameters, bool useNodalRefinement)</td></tr>
<tr class="memdesc:a7c699e45ed875a962b1ea73cf63c31b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for refining based on samples.  <br /></td></tr>
<tr class="separator:a7c699e45ed875a962b1ea73cf63c31b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824b1973e9ea260ed7374731c3e5ff6d" id="r_a824b1973e9ea260ed7374731c3e5ff6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html#a824b1973e9ea260ed7374731c3e5ff6d">MeshRefinement</a> (<a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;meshRefinementParameters)</td></tr>
<tr class="memdesc:a824b1973e9ea260ed7374731c3e5ff6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for refining based on polygons.  <br /></td></tr>
<tr class="separator:a824b1973e9ea260ed7374731c3e5ff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a2da807f7abd273ae83a12fb3a1b14" id="r_a60a2da807f7abd273ae83a12fb3a1b14"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh_refinement.html#a60a2da807f7abd273ae83a12fb3a1b14">Compute</a> ()</td></tr>
<tr class="memdesc:a60a2da807f7abd273ae83a12fb3a1b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh refinement (refinecellsandfaces2).  <br /></td></tr>
<tr class="separator:a60a2da807f7abd273ae83a12fb3a1b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class used to refine a <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> instance. </p>
<p><a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a> refinement operates on <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> and is based on iteratively splitting the edges until the desired level of refinement or the maximum number of iterations is reached. Refinement can be based on samples or based on a polygon. The refinement based on samples uses the averaging interpolation algorithm to compute the level of refinement from the samples to the centers of the edges. At a high level, the mesh refinement is performed as follow:</p>
<ul>
<li>Flag the nodes inside the refinement polygon.</li>
<li>Flag all face nodes of the faces not fully included in the polygon.</li>
<li>Execute the refinement iterations<ol type="1">
<li>For each edge store the index of its neighboring edge sharing a hanging node (the so-called brother edge). This is required for the following steps because edges with hanging nodes will not be divided further.</li>
<li>Compute edge and face refinement masks from the samples.</li>
<li>Compute if a face should be divided based on the computed refinement value.</li>
<li>Split the face by dividing the edges.</li>
</ol>
</li>
<li>Connect the hanging nodes if required, thus forming triangular faces in the transition area.</li>
</ul>
<p>As with <a class="el" href="classmeshkernel_1_1_orthogonalization_and_smoothing.html" title="Orthogonalizion (optimize the aspect ratios) and mesh smoothing (optimize internal face angles or are...">OrthogonalizationAndSmoothing</a>, <a class="el" href="classmeshkernel_1_1_mesh_refinement.html" title="A class used to refine a Mesh2D instance.">MeshRefinement</a> modifies an existing <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> instance. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39b794046c5473659de82822b7d03b1c" name="a39b794046c5473659de82822b7d03b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b794046c5473659de82822b7d03b1c">&#9670;&#160;</a></span>MeshRefinement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::MeshRefinement::MeshRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh_interpolation.html">MeshInterpolation</a> &gt;&#160;</td>
          <td class="paramname"><em>interpolant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor for refining based on samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to be refined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The region in which refinement is done, if empty the whole mesh will be considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolant</td><td>The averaging interpolation to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c699e45ed875a962b1ea73cf63c31b0" name="a7c699e45ed875a962b1ea73cf63c31b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c699e45ed875a962b1ea73cf63c31b0">&#9670;&#160;</a></span>MeshRefinement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::MeshRefinement::MeshRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh_interpolation.html">MeshInterpolation</a> &gt;&#160;</td>
          <td class="paramname"><em>interpolant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNodalRefinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor for refining based on samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to be refined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The region in which refinement is done, if empty the whole mesh will be considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolant</td><td>The averaging interpolation to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useNodalRefinement</td><td>Use nodal refinement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824b1973e9ea260ed7374731c3e5ff6d" name="a824b1973e9ea260ed7374731c3e5ff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824b1973e9ea260ed7374731c3e5ff6d">&#9670;&#160;</a></span>MeshRefinement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::MeshRefinement::MeshRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor for refining based on polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to be refined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60a2da807f7abd273ae83a12fb3a1b14" name="a60a2da807f7abd273ae83a12fb3a1b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a2da807f7abd273ae83a12fb3a1b14">&#9670;&#160;</a></span>Compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::MeshRefinement::Compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mesh refinement (refinecellsandfaces2). </p>
<p>Steps:</p><ol type="1">
<li>Masks the node to be refined (those inside a polygon)</li>
<li>Find the brother edges, the edge sharing a hanging node, FindBrotherEdges</li>
<li>Mask nodes at the polygon perimeter, ComputeNodeMaskAtPolygonPerimeter</li>
<li>Do refinement iterations<ol type="a">
<li>Find the brother edges, FindBrotherEdges</li>
<li>Compute the edge refinement mask based on samples, ComputeRefinementMasksFromSamples</li>
<li>Compute the edge refinement mask based on polygon, ComputeEdgesRefinementMask</li>
<li>Compute if a face should be split, ComputeIfFaceShouldBeSplit</li>
<li>Compute face by splitting edges, RefineFacesBySplittingEdges</li>
</ol>
</li>
<li>Connect hanging nodes if requested, DeleteIsolatedHangingnodes, connect_hanging_nodes </li>
</ol>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="_mesh_refinement_8hpp_source.html">MeshRefinement.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
