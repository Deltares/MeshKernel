<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmeshkernel_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">meshkernel::Mesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2d meshes.  
 <a href="classmeshkernel_1_1_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mesh_8hpp_source.html">Mesh.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for meshkernel::Mesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmeshkernel_1_1_mesh.png" usemap="#meshkernel::Mesh_map" alt=""/>
  <map id="meshkernel::Mesh_map" name="meshkernel::Mesh_map">
<area href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes." alt="meshkernel::Mesh1D" shape="rect" coords="0,56,129,80"/>
<area href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes." alt="meshkernel::Mesh2D" shape="rect" coords="139,56,268,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2bdcf8039b306fc22ee56210ac137078" id="r_a2bdcf8039b306fc22ee56210ac137078"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">Type</a> { <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc">Mesh1D</a>
, <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13">Mesh2D</a>
 }</td></tr>
<tr class="memdesc:a2bdcf8039b306fc22ee56210ac137078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different mesh types.  <a href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">More...</a><br /></td></tr>
<tr class="separator:a2bdcf8039b306fc22ee56210ac137078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6e629107d83c68b952351d071140059" id="r_aa6e629107d83c68b952351d071140059"><td class="memItemLeft" align="right" valign="top"><a id="aa6e629107d83c68b952351d071140059" name="aa6e629107d83c68b952351d071140059"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Mesh</b> ()=default</td></tr>
<tr class="memdesc:aa6e629107d83c68b952351d071140059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define virtual destructor. <br /></td></tr>
<tr class="separator:aa6e629107d83c68b952351d071140059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9e838039533bdaf003a150b96834b" id="r_a92e9e838039533bdaf003a150b96834b"><td class="memItemLeft" align="right" valign="top"><a id="a92e9e838039533bdaf003a150b96834b" name="a92e9e838039533bdaf003a150b96834b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> ()</td></tr>
<tr class="memdesc:a92e9e838039533bdaf003a150b96834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, setting a cartesian projection. <br /></td></tr>
<tr class="separator:a92e9e838039533bdaf003a150b96834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3025be7c99cbd8c75390591234513957" id="r_a3025be7c99cbd8c75390591234513957"><td class="memItemLeft" align="right" valign="top"><a id="a3025be7c99cbd8c75390591234513957" name="a3025be7c99cbd8c75390591234513957"></a>
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:a3025be7c99cbd8c75390591234513957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete assignment operator. <br /></td></tr>
<tr class="separator:a3025be7c99cbd8c75390591234513957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7666c2ed76bb22467bc2c85c00b27e" id="r_a6a7666c2ed76bb22467bc2c85c00b27e"><td class="memItemLeft" align="right" valign="top"><a id="a6a7666c2ed76bb22467bc2c85c00b27e" name="a6a7666c2ed76bb22467bc2c85c00b27e"></a>
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:a6a7666c2ed76bb22467bc2c85c00b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete move assignment operator. <br /></td></tr>
<tr class="separator:a6a7666c2ed76bb22467bc2c85c00b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c0a003e5bea44c88abdc1836dacbb" id="r_afc6c0a003e5bea44c88abdc1836dacbb"><td class="memItemLeft" align="right" valign="top"><a id="afc6c0a003e5bea44c88abdc1836dacbb" name="afc6c0a003e5bea44c88abdc1836dacbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:afc6c0a003e5bea44c88abdc1836dacbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor taking only a mesh. <br /></td></tr>
<tr class="separator:afc6c0a003e5bea44c88abdc1836dacbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105eab06d2e36deef97fe359fd648115" id="r_a105eab06d2e36deef97fe359fd648115"><td class="memItemLeft" align="right" valign="top"><a id="a105eab06d2e36deef97fe359fd648115" name="a105eab06d2e36deef97fe359fd648115"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:a105eab06d2e36deef97fe359fd648115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor taking only a mesh. <br /></td></tr>
<tr class="separator:a105eab06d2e36deef97fe359fd648115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01249e9753c76d0ec3942bd5027105" id="r_a6b01249e9753c76d0ec3942bd5027105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">Mesh</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a6b01249e9753c76d0ec3942bd5027105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty mesh, sets only the projection.  <br /></td></tr>
<tr class="separator:a6b01249e9753c76d0ec3942bd5027105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21a6199afcf9444f0e7ae17856dcf" id="r_a77a21a6199afcf9444f0e7ae17856dcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">Mesh</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a77a21a6199afcf9444f0e7ae17856dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh starting from the edges and nodes.  <br /></td></tr>
<tr class="separator:a77a21a6199afcf9444f0e7ae17856dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557891a65132f1629578381c377fafb7" id="r_a557891a65132f1629578381c377fafb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">IsNodeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:a557891a65132f1629578381c377fafb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a node is on boundary.  <br /></td></tr>
<tr class="separator:a557891a65132f1629578381c377fafb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdde73c3f0dd734948065fc83bb7a61" id="r_aacdde73c3f0dd734948065fc83bb7a61"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:aacdde73c3f0dd734948065fc83bb7a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <br /></td></tr>
<tr class="separator:aacdde73c3f0dd734948065fc83bb7a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150280bdba56884de15211a34e64155" id="r_a5150280bdba56884de15211a34e64155"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">GetNumEdges</a> () const</td></tr>
<tr class="memdesc:a5150280bdba56884de15211a34e64155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <br /></td></tr>
<tr class="separator:a5150280bdba56884de15211a34e64155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abbc0382968330e4a530e84f093194" id="r_a50abbc0382968330e4a530e84f093194"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a50abbc0382968330e4a530e84f093194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid faces.  <br /></td></tr>
<tr class="separator:a50abbc0382968330e4a530e84f093194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5092d7f49e94dfbd5c693e64f288145" id="r_aa5092d7f49e94dfbd5c693e64f288145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa5092d7f49e94dfbd5c693e64f288145">GetNumValidNodes</a> () const</td></tr>
<tr class="memdesc:aa5092d7f49e94dfbd5c693e64f288145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <br /></td></tr>
<tr class="separator:aa5092d7f49e94dfbd5c693e64f288145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3513b12402aff0e4d207ad41ab6a1f7" id="r_ac3513b12402aff0e4d207ad41ab6a1f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac3513b12402aff0e4d207ad41ab6a1f7">GetNumValidEdges</a> () const</td></tr>
<tr class="memdesc:ac3513b12402aff0e4d207ad41ab6a1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <br /></td></tr>
<tr class="separator:ac3513b12402aff0e4d207ad41ab6a1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2968e88cb2bd6cfd973f1a65393e32b" id="r_ad2968e88cb2bd6cfd973f1a65393e32b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad2968e88cb2bd6cfd973f1a65393e32b">GetNumNodesEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex) const</td></tr>
<tr class="memdesc:ad2968e88cb2bd6cfd973f1a65393e32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a node.  <br /></td></tr>
<tr class="separator:ad2968e88cb2bd6cfd973f1a65393e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed907d8c59c2d8f38edc0a9cf844440" id="r_a1ed907d8c59c2d8f38edc0a9cf844440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1ed907d8c59c2d8f38edc0a9cf844440">GetNumFaceEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex) const</td></tr>
<tr class="memdesc:a1ed907d8c59c2d8f38edc0a9cf844440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a face.  <br /></td></tr>
<tr class="separator:a1ed907d8c59c2d8f38edc0a9cf844440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0b7f5a23cb1848df66863ec5644d9" id="r_ac9d0b7f5a23cb1848df66863ec5644d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac9d0b7f5a23cb1848df66863ec5644d9">GetNumEdgesFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeIndex) const</td></tr>
<tr class="memdesc:ac9d0b7f5a23cb1848df66863ec5644d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces an edges shares.  <br /></td></tr>
<tr class="separator:ac9d0b7f5a23cb1848df66863ec5644d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c046bcd8bcbd58c3e9b1e1a1eb71a" id="r_a125c046bcd8bcbd58c3e9b1e1a1eb71a"><td class="memItemLeft" align="right" valign="top"><a id="a125c046bcd8bcbd58c3e9b1e1a1eb71a" name="a125c046bcd8bcbd58c3e9b1e1a1eb71a"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEdgeIndex</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a125c046bcd8bcbd58c3e9b1e1a1eb71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local edge number for an element edge. <br /></td></tr>
<tr class="separator:a125c046bcd8bcbd58c3e9b1e1a1eb71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63117852b466d3600ecf3574da268173" id="r_a63117852b466d3600ecf3574da268173"><td class="memItemLeft" align="right" valign="top"><a id="a63117852b466d3600ecf3574da268173" name="a63117852b466d3600ecf3574da268173"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeIndex</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a63117852b466d3600ecf3574da268173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local node number for an element node. <br /></td></tr>
<tr class="separator:a63117852b466d3600ecf3574da268173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569153beacd2187549c3cdf56141a41" id="r_a7569153beacd2187549c3cdf56141a41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">IsEdgeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge) const</td></tr>
<tr class="memdesc:a7569153beacd2187549c3cdf56141a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if an edge is on boundary.  <br /></td></tr>
<tr class="separator:a7569153beacd2187549c3cdf56141a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59544d3cee42126f27bed0da80518051" id="r_a59544d3cee42126f27bed0da80518051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">IsFaceOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> face) const</td></tr>
<tr class="memdesc:a59544d3cee42126f27bed0da80518051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a face is on boundary.  <br /></td></tr>
<tr class="separator:a59544d3cee42126f27bed0da80518051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0f6253491d56310e50e820a97c9e7" id="r_a7ca0f6253491d56310e50e820a97c9e7"><td class="memItemLeft" align="right" valign="top"><a id="a7ca0f6253491d56310e50e820a97c9e7" name="a7ca0f6253491d56310e50e820a97c9e7"></a>
const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes</b> () const</td></tr>
<tr class="memdesc:a7ca0f6253491d56310e50e820a97c9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vector of all nodes. <br /></td></tr>
<tr class="separator:a7ca0f6253491d56310e50e820a97c9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d4f99b05e95ee10af584d047f879b8" id="r_a36d4f99b05e95ee10af584d047f879b8"><td class="memItemLeft" align="right" valign="top"><a id="a36d4f99b05e95ee10af584d047f879b8" name="a36d4f99b05e95ee10af584d047f879b8"></a>
const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a36d4f99b05e95ee10af584d047f879b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node at the position. <br /></td></tr>
<tr class="separator:a36d4f99b05e95ee10af584d047f879b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463bb2c80412b27f0d8bbc32ff2c7320" id="r_a463bb2c80412b27f0d8bbc32ff2c7320"><td class="memItemLeft" align="right" valign="top"><a id="a463bb2c80412b27f0d8bbc32ff2c7320" name="a463bb2c80412b27f0d8bbc32ff2c7320"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNodes</b> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:a463bb2c80412b27f0d8bbc32ff2c7320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all nodes to a new set of values. <br /></td></tr>
<tr class="separator:a463bb2c80412b27f0d8bbc32ff2c7320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9594e484c99c5faf0de1edc85488f9" id="r_a1f9594e484c99c5faf0de1edc85488f9"><td class="memItemLeft" align="right" valign="top"><a id="a1f9594e484c99c5faf0de1edc85488f9" name="a1f9594e484c99c5faf0de1edc85488f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNode</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:a1f9594e484c99c5faf0de1edc85488f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node to a new value, bypassing the undo action. <br /></td></tr>
<tr class="separator:a1f9594e484c99c5faf0de1edc85488f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71c7c4357d19525efffa3ccb069dc61" id="r_aa71c7c4357d19525efffa3ccb069dc61"><td class="memItemLeft" align="right" valign="top"><a id="aa71c7c4357d19525efffa3ccb069dc61" name="aa71c7c4357d19525efffa3ccb069dc61"></a>
std::unique_ptr&lt; ResetNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ResetNode</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:aa71c7c4357d19525efffa3ccb069dc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node to a new value, this value may be the in-valid value. <br /></td></tr>
<tr class="separator:aa71c7c4357d19525efffa3ccb069dc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bc47ffb98b18a28c7e4b56ae085f4" id="r_a022bc47ffb98b18a28c7e4b56ae085f4"><td class="memItemLeft" align="right" valign="top"><a id="a022bc47ffb98b18a28c7e4b56ae085f4" name="a022bc47ffb98b18a28c7e4b56ae085f4"></a>
const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Edges</b> () const</td></tr>
<tr class="memdesc:a022bc47ffb98b18a28c7e4b56ae085f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all edges. <br /></td></tr>
<tr class="separator:a022bc47ffb98b18a28c7e4b56ae085f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099baaed247afdd5ec2f82e7ce9ced4d" id="r_a099baaed247afdd5ec2f82e7ce9ced4d"><td class="memItemLeft" align="right" valign="top"><a id="a099baaed247afdd5ec2f82e7ce9ced4d" name="a099baaed247afdd5ec2f82e7ce9ced4d"></a>
const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetEdge</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a099baaed247afdd5ec2f82e7ce9ced4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reference to an edge. <br /></td></tr>
<tr class="separator:a099baaed247afdd5ec2f82e7ce9ced4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee197c80cffe9346c7fd74d9d13fa4f0" id="r_aee197c80cffe9346c7fd74d9d13fa4f0"><td class="memItemLeft" align="right" valign="top"><a id="aee197c80cffe9346c7fd74d9d13fa4f0" name="aee197c80cffe9346c7fd74d9d13fa4f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEdges</b> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:aee197c80cffe9346c7fd74d9d13fa4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all edges to a new set of values. <br /></td></tr>
<tr class="separator:aee197c80cffe9346c7fd74d9d13fa4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96acfe8f0f96766a3de452bb44b170" id="r_a9a96acfe8f0f96766a3de452bb44b170"><td class="memItemLeft" align="right" valign="top"><a id="a9a96acfe8f0f96766a3de452bb44b170" name="a9a96acfe8f0f96766a3de452bb44b170"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEdge</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a9a96acfe8f0f96766a3de452bb44b170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the edge to a new value, bypassing the undo action. <br /></td></tr>
<tr class="separator:a9a96acfe8f0f96766a3de452bb44b170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf883f0fa0f96b983fcd0d09e315270" id="r_a8cf883f0fa0f96b983fcd0d09e315270"><td class="memItemLeft" align="right" valign="top"><a id="a8cf883f0fa0f96b983fcd0d09e315270" name="a8cf883f0fa0f96b983fcd0d09e315270"></a>
std::unique_ptr&lt; ResetEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ResetEdge</b> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId, const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a8cf883f0fa0f96b983fcd0d09e315270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the nodes referenced by the edge. <br /></td></tr>
<tr class="separator:a8cf883f0fa0f96b983fcd0d09e315270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a9e12803a1fbfb043d5edd0f71d79" id="r_ac67a9e12803a1fbfb043d5edd0f71d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac67a9e12803a1fbfb043d5edd0f71d79">GetLocalFaceNodeIndex</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex) const</td></tr>
<tr class="memdesc:ac67a9e12803a1fbfb043d5edd0f71d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index of the node belong to a face.  <br /></td></tr>
<tr class="separator:ac67a9e12803a1fbfb043d5edd0f71d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f607d6c23447110978de1b7fe8366ed" id="r_a2f607d6c23447110978de1b7fe8366ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2f607d6c23447110978de1b7fe8366ed">MergeTwoNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:a2f607d6c23447110978de1b7fe8366ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh nodes.  <br /></td></tr>
<tr class="separator:a2f607d6c23447110978de1b7fe8366ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1ff2fd9ced80bb851072bfa3d73ffc" id="r_a5b1ff2fd9ced80bb851072bfa3d73ffc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5b1ff2fd9ced80bb851072bfa3d73ffc">MergeNodesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double mergingDistance)</td></tr>
<tr class="memdesc:a5b1ff2fd9ced80bb851072bfa3d73ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON)  <br /></td></tr>
<tr class="separator:a5b1ff2fd9ced80bb851072bfa3d73ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d2dacb6f55d6f640d89e37b19d0982" id="r_af6d2dacb6f55d6f640d89e37b19d0982"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddNodeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#af6d2dacb6f55d6f640d89e37b19d0982">InsertNode</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newPoint)</td></tr>
<tr class="memdesc:af6d2dacb6f55d6f640d89e37b19d0982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the mesh (setnewpoint)  <br /></td></tr>
<tr class="separator:af6d2dacb6f55d6f640d89e37b19d0982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da42e1182d41c447138731467f2e20a" id="r_a3da42e1182d41c447138731467f2e20a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddEdgeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3da42e1182d41c447138731467f2e20a">ConnectNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode, const bool collectUndo=true)</td></tr>
<tr class="memdesc:a3da42e1182d41c447138731467f2e20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two existing nodes, checking if the nodes are already connected. If the nodes are not connected a new edge is formed, otherwise UInt invalid value is returned. (connectdbn)  <br /></td></tr>
<tr class="separator:a3da42e1182d41c447138731467f2e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755064d05033b73f98f6d2543775c471" id="r_a755064d05033b73f98f6d2543775c471"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a755064d05033b73f98f6d2543775c471">DeleteNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node, const bool collectUndo=true)</td></tr>
<tr class="memdesc:a755064d05033b73f98f6d2543775c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node and removes any connected edges.  <br /></td></tr>
<tr class="separator:a755064d05033b73f98f6d2543775c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca9e46fe37ed14e5b42ca498c8f9c42" id="r_adca9e46fe37ed14e5b42ca498c8f9c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">FindEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:adca9e46fe37ed14e5b42ca498c8f9c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge sharing two nodes.  <br /></td></tr>
<tr class="separator:adca9e46fe37ed14e5b42ca498c8f9c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285ea22b80c3cf51e3ad1d11b7363d3" id="r_a5285ea22b80c3cf51e3ad1d11b7363d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5285ea22b80c3cf51e3ad1d11b7363d3">FindEdgeWithLinearSearch</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:a5285ea22b80c3cf51e3ad1d11b7363d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge using a linear search, without connectivity information (much slower than FindEdge)  <br /></td></tr>
<tr class="separator:a5285ea22b80c3cf51e3ad1d11b7363d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b165a838a5201547dd8ed9f1fa73c" id="r_a028b165a838a5201547dd8ed9f1fa73c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a028b165a838a5201547dd8ed9f1fa73c">MoveNode</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> newPoint, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeindex)</td></tr>
<tr class="memdesc:a028b165a838a5201547dd8ed9f1fa73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a node to a new location.  <br /></td></tr>
<tr class="separator:a028b165a838a5201547dd8ed9f1fa73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b39772ba615d01ee00b7cafab6a37" id="r_a295b39772ba615d01ee00b7cafab6a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a295b39772ba615d01ee00b7cafab6a37">FindLocationIndex</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const std::vector&lt; bool &gt; &amp;locationMask={}, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:a295b39772ba615d01ee00b7cafab6a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a location (node/edge or face) close to a point.  <br /></td></tr>
<tr class="separator:a295b39772ba615d01ee00b7cafab6a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d72c761ca10c957623ab8b7c98e20a" id="r_a42d72c761ca10c957623ab8b7c98e20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">FindNodeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> const &amp;point, double searchRadius)</td></tr>
<tr class="memdesc:a42d72c761ca10c957623ab8b7c98e20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <br /></td></tr>
<tr class="separator:a42d72c761ca10c957623ab8b7c98e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb72cad3fc82f848dc6352fb324a8a3f" id="r_abb72cad3fc82f848dc6352fb324a8a3f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abb72cad3fc82f848dc6352fb324a8a3f">DeleteEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge, const bool collectUndo=true)</td></tr>
<tr class="memdesc:abb72cad3fc82f848dc6352fb324a8a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an edge.  <br /></td></tr>
<tr class="separator:abb72cad3fc82f848dc6352fb324a8a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a3ba1a2f8974d7367680ea71a70b28" id="r_a86a3ba1a2f8974d7367680ea71a70b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">FindCommonNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstEdgeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondEdgeIndex) const</td></tr>
<tr class="memdesc:a86a3ba1a2f8974d7367680ea71a70b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop.  <br /></td></tr>
<tr class="separator:a86a3ba1a2f8974d7367680ea71a70b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacff872b8bcecdedf5e67af403e8fbe" id="r_adacff872b8bcecdedf5e67af403e8fbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">NodeAdministration</a> ()</td></tr>
<tr class="memdesc:adacff872b8bcecdedf5e67af403e8fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node administration (setnodadmin)  <br /></td></tr>
<tr class="separator:adacff872b8bcecdedf5e67af403e8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf16bf95337fec05384a2dc07798fe" id="r_adadf16bf95337fec05384a2dc07798fe"><td class="memItemLeft" align="right" valign="top"><a id="adadf16bf95337fec05384a2dc07798fe" name="adadf16bf95337fec05384a2dc07798fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteInvalidNodesAndEdges</b> ()</td></tr>
<tr class="memdesc:adadf16bf95337fec05384a2dc07798fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all invalid nodes and edges. <br /></td></tr>
<tr class="separator:adadf16bf95337fec05384a2dc07798fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301daf1e7c422cf9a52ed4e42911c481" id="r_a301daf1e7c422cf9a52ed4e42911c481"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a301daf1e7c422cf9a52ed4e42911c481">Administrate</a> (CompoundUndoAction *undoAction=nullptr)</td></tr>
<tr class="memdesc:a301daf1e7c422cf9a52ed4e42911c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complete administration.  <br /></td></tr>
<tr class="separator:a301daf1e7c422cf9a52ed4e42911c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6053a6652a47c5954eb9f38f61530d" id="r_a5f6053a6652a47c5954eb9f38f61530d"><td class="memItemLeft" align="right" valign="top"><a id="a5f6053a6652a47c5954eb9f38f61530d" name="a5f6053a6652a47c5954eb9f38f61530d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AdministrateNodesEdges</b> (CompoundUndoAction *undoAction=nullptr)</td></tr>
<tr class="memdesc:a5f6053a6652a47c5954eb9f38f61530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform node and edges administration. <br /></td></tr>
<tr class="separator:a5f6053a6652a47c5954eb9f38f61530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf79b4b9e80ce47284a4cb1d866790a" id="r_accf79b4b9e80ce47284a4cb1d866790a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">SortEdgesInCounterClockWiseOrder</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:accf79b4b9e80ce47284a4cb1d866790a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort mesh edges around a node in counterclockwise order (Sort_links_ccw)  <br /></td></tr>
<tr class="separator:accf79b4b9e80ce47284a4cb1d866790a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd09195a02e96eac266e7463ac8e8b" id="r_acffd09195a02e96eac266e7463ac8e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#acffd09195a02e96eac266e7463ac8e8b">BuildTree</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:acffd09195a02e96eac266e7463ac8e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location, using only the locations inside the bounding box.  <br /></td></tr>
<tr class="separator:acffd09195a02e96eac266e7463ac8e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075ded54a29dee5b05496aa50b6b3c50" id="r_a075ded54a29dee5b05496aa50b6b3c50"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a075ded54a29dee5b05496aa50b6b3c50">ComputeLocations</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a075ded54a29dee5b05496aa50b6b3c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates).  <br /></td></tr>
<tr class="separator:a075ded54a29dee5b05496aa50b6b3c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb7298b6024ac7ba6782dbdb9b36f4d" id="r_afcb7298b6024ac7ba6782dbdb9b36f4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_boolean.html">Boolean</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afcb7298b6024ac7ba6782dbdb9b36f4d">IsLocationInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:afcb7298b6024ac7ba6782dbdb9b36f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes if a location is in polygon.  <br /></td></tr>
<tr class="separator:afcb7298b6024ac7ba6782dbdb9b36f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913cb71a6bdbe0e37e9505eba9cfddbb" id="r_a913cb71a6bdbe0e37e9505eba9cfddbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a913cb71a6bdbe0e37e9505eba9cfddbb">operator+=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a913cb71a6bdbe0e37e9505eba9cfddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <br /></td></tr>
<tr class="separator:a913cb71a6bdbe0e37e9505eba9cfddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33087e1341b98a7b22de95f12b6f3b" id="r_a6f33087e1341b98a7b22de95f12b6f3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6f33087e1341b98a7b22de95f12b6f3b">Join</a> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6f33087e1341b98a7b22de95f12b6f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <br /></td></tr>
<tr class="separator:a6f33087e1341b98a7b22de95f12b6f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a751df055464fae2e83a717599744c7" id="r_a8a751df055464fae2e83a717599744c7"><td class="memItemLeft" align="right" valign="top"><a id="a8a751df055464fae2e83a717599744c7" name="a8a751df055464fae2e83a717599744c7"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidNodeMapping</b> () const</td></tr>
<tr class="memdesc:a8a751df055464fae2e83a717599744c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the node array mapped to valid nodes. <br /></td></tr>
<tr class="separator:a8a751df055464fae2e83a717599744c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f54085e7a7cbaee1c777c6c15d52a3" id="r_a35f54085e7a7cbaee1c777c6c15d52a3"><td class="memItemLeft" align="right" valign="top"><a id="a35f54085e7a7cbaee1c777c6c15d52a3" name="a35f54085e7a7cbaee1c777c6c15d52a3"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidEdgeMapping</b> () const</td></tr>
<tr class="memdesc:a35f54085e7a7cbaee1c777c6c15d52a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the edge array mapped to valid edges. <br /></td></tr>
<tr class="separator:a35f54085e7a7cbaee1c777c6c15d52a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c39d9c4107de7bf1e614a4daab1bf4" id="r_a60c39d9c4107de7bf1e614a4daab1bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a60c39d9c4107de7bf1e614a4daab1bf4">IsValidEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a60c39d9c4107de7bf1e614a4daab1bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the edge-id is a valid edge.  <br /></td></tr>
<tr class="separator:a60c39d9c4107de7bf1e614a4daab1bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861f9236f0817b1d2d492817b4773d5" id="r_ab861f9236f0817b1d2d492817b4773d5"><td class="memItemLeft" align="right" valign="top"><a id="ab861f9236f0817b1d2d492817b4773d5" name="ab861f9236f0817b1d2d492817b4773d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab861f9236f0817b1d2d492817b4773d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset node action. <br /></td></tr>
<tr class="separator:ab861f9236f0817b1d2d492817b4773d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e9c403187516bc12e95cacf5a9efe" id="r_ae38e9c403187516bc12e95cacf5a9efe"><td class="memItemLeft" align="right" valign="top"><a id="ae38e9c403187516bc12e95cacf5a9efe" name="ae38e9c403187516bc12e95cacf5a9efe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ae38e9c403187516bc12e95cacf5a9efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add node action. <br /></td></tr>
<tr class="separator:ae38e9c403187516bc12e95cacf5a9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94255cd952aa63a7dfef62a5b8316ae5" id="r_a94255cd952aa63a7dfef62a5b8316ae5"><td class="memItemLeft" align="right" valign="top"><a id="a94255cd952aa63a7dfef62a5b8316ae5" name="a94255cd952aa63a7dfef62a5b8316ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a94255cd952aa63a7dfef62a5b8316ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add edge action. <br /></td></tr>
<tr class="separator:a94255cd952aa63a7dfef62a5b8316ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b364df4cef58824ace3b7fcebfa72" id="r_aec0b364df4cef58824ace3b7fcebfa72"><td class="memItemLeft" align="right" valign="top"><a id="aec0b364df4cef58824ace3b7fcebfa72" name="aec0b364df4cef58824ace3b7fcebfa72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec0b364df4cef58824ace3b7fcebfa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset edge action. <br /></td></tr>
<tr class="separator:aec0b364df4cef58824ace3b7fcebfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c598b30ede19fe13e5c6f5d858b57d9" id="r_a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memItemLeft" align="right" valign="top"><a id="a7c598b30ede19fe13e5c6f5d858b57d9" name="a7c598b30ede19fe13e5c6f5d858b57d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete node action. <br /></td></tr>
<tr class="separator:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858c17e1f3bcf4d4d499890eb51b8d7" id="r_a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memItemLeft" align="right" valign="top"><a id="a4858c17e1f3bcf4d4d499890eb51b8d7" name="a4858c17e1f3bcf4d4d499890eb51b8d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c00e8af6aa7a5ffdce9d1819d800c" id="r_a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memItemLeft" align="right" valign="top"><a id="a703c00e8af6aa7a5ffdce9d1819d800c" name="a703c00e8af6aa7a5ffdce9d1819d800c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3af477c78c430087b9503e8cca204" id="r_a07d3af477c78c430087b9503e8cca204"><td class="memItemLeft" align="right" valign="top"><a id="a07d3af477c78c430087b9503e8cca204" name="a07d3af477c78c430087b9503e8cca204"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a07d3af477c78c430087b9503e8cca204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete edge action. <br /></td></tr>
<tr class="separator:a07d3af477c78c430087b9503e8cca204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f6003e1fc09bf1ca888bdcc81fb32" id="r_a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memItemLeft" align="right" valign="top"><a id="a5b6f6003e1fc09bf1ca888bdcc81fb32" name="a5b6f6003e1fc09bf1ca888bdcc81fb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node and edge values. <br /></td></tr>
<tr class="separator:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eceeabde32650702348e6a275aa08a" id="r_a29eceeabde32650702348e6a275aa08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a29eceeabde32650702348e6a275aa08a">RestoreAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a29eceeabde32650702348e6a275aa08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset node action.  <br /></td></tr>
<tr class="separator:a29eceeabde32650702348e6a275aa08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50999836399c1abf107447009c91599" id="r_ab50999836399c1abf107447009c91599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab50999836399c1abf107447009c91599">RestoreAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab50999836399c1abf107447009c91599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add node action.  <br /></td></tr>
<tr class="separator:ab50999836399c1abf107447009c91599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32996870084db773349d616d915d20da" id="r_a32996870084db773349d616d915d20da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a32996870084db773349d616d915d20da">RestoreAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a32996870084db773349d616d915d20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add edge action.  <br /></td></tr>
<tr class="separator:a32996870084db773349d616d915d20da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a88228580bdf682918ad1be4232a7a" id="r_ad3a88228580bdf682918ad1be4232a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad3a88228580bdf682918ad1be4232a7a">RestoreAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ad3a88228580bdf682918ad1be4232a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset edge action.  <br /></td></tr>
<tr class="separator:ad3a88228580bdf682918ad1be4232a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f3adb13e8805d490cbe379977956a7" id="r_a70f3adb13e8805d490cbe379977956a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a70f3adb13e8805d490cbe379977956a7">RestoreAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a70f3adb13e8805d490cbe379977956a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete node action.  <br /></td></tr>
<tr class="separator:a70f3adb13e8805d490cbe379977956a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9373b8e04a8a15f955a01587d09f431f" id="r_a9373b8e04a8a15f955a01587d09f431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9373b8e04a8a15f955a01587d09f431f">RestoreAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a9373b8e04a8a15f955a01587d09f431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a9373b8e04a8a15f955a01587d09f431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dd36a747c4b9887235c3d2a372b02" id="r_a423dd36a747c4b9887235c3d2a372b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a423dd36a747c4b9887235c3d2a372b02">RestoreAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a423dd36a747c4b9887235c3d2a372b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a423dd36a747c4b9887235c3d2a372b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c0ba1f81f51653e63d32bec74dbed" id="r_aec8c0ba1f81f51653e63d32bec74dbed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aec8c0ba1f81f51653e63d32bec74dbed">RestoreAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec8c0ba1f81f51653e63d32bec74dbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete edge action.  <br /></td></tr>
<tr class="separator:aec8c0ba1f81f51653e63d32bec74dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3bf27ec07d25b0cf214d2c0ed8565" id="r_a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">RestoreAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo entire node and edge values.  <br /></td></tr>
<tr class="separator:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78aac5163ea0222e691ff11d7ddc56" id="r_a1f78aac5163ea0222e691ff11d7ddc56"><td class="memItemLeft" align="right" valign="top"><a id="a1f78aac5163ea0222e691ff11d7ddc56" name="a1f78aac5163ea0222e691ff11d7ddc56"></a>
RTreeBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRTree</b> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a1f78aac5163ea0222e691ff11d7ddc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the RTree for a specific location. <br /></td></tr>
<tr class="separator:a1f78aac5163ea0222e691ff11d7ddc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781b066806d37bdd5c5fd224c915af2" id="r_a1781b066806d37bdd5c5fd224c915af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1781b066806d37bdd5c5fd224c915af2">SetNodesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1781b066806d37bdd5c5fd224c915af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_nodesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a1781b066806d37bdd5c5fd224c915af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94a0519c42f3867d10c55c80275fce" id="r_a1a94a0519c42f3867d10c55c80275fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1a94a0519c42f3867d10c55c80275fce">SetEdgesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1a94a0519c42f3867d10c55c80275fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_edgesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a1a94a0519c42f3867d10c55c80275fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127847d3b8a1e6c1f3217eeeb3a1fab5" id="r_a127847d3b8a1e6c1f3217eeeb3a1fab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a127847d3b8a1e6c1f3217eeeb3a1fab5">SetFacesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a127847d3b8a1e6c1f3217eeeb3a1fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_facesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a127847d3b8a1e6c1f3217eeeb3a1fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26b86c6e8ab77c1dc9d4c56cf4cca3" id="r_a2e26b86c6e8ab77c1dc9d4c56cf4cca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2e26b86c6e8ab77c1dc9d4c56cf4cca3">ComputeFaceClosedPolygon</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache) const</td></tr>
<tr class="memdesc:a2e26b86c6e8ab77c1dc9d4c56cf4cca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon.  <br /></td></tr>
<tr class="separator:a2e26b86c6e8ab77c1dc9d4c56cf4cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a03dea09629645fd2274c4fdff46b7fbe" id="r_a03dea09629645fd2274c4fdff46b7fbe"><td class="memItemLeft" align="right" valign="top"><a id="a03dea09629645fd2274c4fdff46b7fbe" name="a03dea09629645fd2274c4fdff46b7fbe"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodesEdges</b></td></tr>
<tr class="memdesc:a03dea09629645fd2274c4fdff46b7fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the indices of connected edges (nodlin) <br /></td></tr>
<tr class="separator:a03dea09629645fd2274c4fdff46b7fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a20dfcb763cb48498c07d9e177fb7d" id="r_a35a20dfcb763cb48498c07d9e177fb7d"><td class="memItemLeft" align="right" valign="top"><a id="a35a20dfcb763cb48498c07d9e177fb7d" name="a35a20dfcb763cb48498c07d9e177fb7d"></a>
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodesNumEdges</b></td></tr>
<tr class="memdesc:a35a20dfcb763cb48498c07d9e177fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the number of connected edges (nmk) <br /></td></tr>
<tr class="separator:a35a20dfcb763cb48498c07d9e177fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6634281d78a1ef707bc5a2376a84524" id="r_aa6634281d78a1ef707bc5a2376a84524"><td class="memItemLeft" align="right" valign="top"><a id="aa6634281d78a1ef707bc5a2376a84524" name="aa6634281d78a1ef707bc5a2376a84524"></a>
std::vector&lt; std::array&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edgesFaces</b></td></tr>
<tr class="memdesc:aa6634281d78a1ef707bc5a2376a84524"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the shared face index (lne) <br /></td></tr>
<tr class="separator:aa6634281d78a1ef707bc5a2376a84524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569032e726ac6a9b127dcb285ddca3a7" id="r_a569032e726ac6a9b127dcb285ddca3a7"><td class="memItemLeft" align="right" valign="top"><a id="a569032e726ac6a9b127dcb285ddca3a7" name="a569032e726ac6a9b127dcb285ddca3a7"></a>
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edgesNumFaces</b></td></tr>
<tr class="memdesc:a569032e726ac6a9b127dcb285ddca3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the number of shared faces(lnn) <br /></td></tr>
<tr class="separator:a569032e726ac6a9b127dcb285ddca3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b44ebfdf5d280a25d566fa5a763c78" id="r_a38b44ebfdf5d280a25d566fa5a763c78"><td class="memItemLeft" align="right" valign="top"><a id="a38b44ebfdf5d280a25d566fa5a763c78" name="a38b44ebfdf5d280a25d566fa5a763c78"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesNodes</b></td></tr>
<tr class="memdesc:a38b44ebfdf5d280a25d566fa5a763c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes composing the faces, in ccw order (netcellNod) <br /></td></tr>
<tr class="separator:a38b44ebfdf5d280a25d566fa5a763c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34f60c2fbe9b1f9e2a93b3a0759d6ca" id="r_af34f60c2fbe9b1f9e2a93b3a0759d6ca"><td class="memItemLeft" align="right" valign="top"><a id="af34f60c2fbe9b1f9e2a93b3a0759d6ca" name="af34f60c2fbe9b1f9e2a93b3a0759d6ca"></a>
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_numFacesNodes</b></td></tr>
<tr class="memdesc:af34f60c2fbe9b1f9e2a93b3a0759d6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes composing the face (netcellN) <br /></td></tr>
<tr class="separator:af34f60c2fbe9b1f9e2a93b3a0759d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f33714b34fd0bcd708efc4b44f30b34" id="r_a1f33714b34fd0bcd708efc4b44f30b34"><td class="memItemLeft" align="right" valign="top"><a id="a1f33714b34fd0bcd708efc4b44f30b34" name="a1f33714b34fd0bcd708efc4b44f30b34"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesEdges</b></td></tr>
<tr class="memdesc:a1f33714b34fd0bcd708efc4b44f30b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge indices composing the face (netcelllin) <br /></td></tr>
<tr class="separator:a1f33714b34fd0bcd708efc4b44f30b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821f2e74e22834dcfce0ce0a326e2e" id="r_a79821f2e74e22834dcfce0ce0a326e2e"><td class="memItemLeft" align="right" valign="top"><a id="a79821f2e74e22834dcfce0ce0a326e2e" name="a79821f2e74e22834dcfce0ce0a326e2e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesMassCenters</b></td></tr>
<tr class="memdesc:a79821f2e74e22834dcfce0ce0a326e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces centers of mass (xzw, yzw) <br /></td></tr>
<tr class="separator:a79821f2e74e22834dcfce0ce0a326e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24f1ea21171bfd6f803b06a4997d56" id="r_a2b24f1ea21171bfd6f803b06a4997d56"><td class="memItemLeft" align="right" valign="top"><a id="a2b24f1ea21171bfd6f803b06a4997d56" name="a2b24f1ea21171bfd6f803b06a4997d56"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_faceArea</b></td></tr>
<tr class="memdesc:a2b24f1ea21171bfd6f803b06a4997d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face area. <br /></td></tr>
<tr class="separator:a2b24f1ea21171bfd6f803b06a4997d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05988ff2a54a0ddf3082c7e4aeeb6" id="r_a01c05988ff2a54a0ddf3082c7e4aeeb6"><td class="memItemLeft" align="right" valign="top"><a id="a01c05988ff2a54a0ddf3082c7e4aeeb6" name="a01c05988ff2a54a0ddf3082c7e4aeeb6"></a>
<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_projection</b></td></tr>
<tr class="memdesc:a01c05988ff2a54a0ddf3082c7e4aeeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection used. <br /></td></tr>
<tr class="separator:a01c05988ff2a54a0ddf3082c7e4aeeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6cefdee88e13794b67efd4fb46da9d83" id="r_a6cefdee88e13794b67efd4fb46da9d83"><td class="memItemLeft" align="right" valign="top"><a id="a6cefdee88e13794b67efd4fb46da9d83" name="a6cefdee88e13794b67efd4fb46da9d83"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdministrationRequired</b> () const</td></tr>
<tr class="memdesc:a6cefdee88e13794b67efd4fb46da9d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a administration is required. <br /></td></tr>
<tr class="separator:a6cefdee88e13794b67efd4fb46da9d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d3b03c50a0a43cff8d2d437257758" id="r_aad9d3b03c50a0a43cff8d2d437257758"><td class="memItemLeft" align="right" valign="top"><a id="aad9d3b03c50a0a43cff8d2d437257758" name="aad9d3b03c50a0a43cff8d2d437257758"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAdministrationRequired</b> (const bool value)</td></tr>
<tr class="memdesc:aad9d3b03c50a0a43cff8d2d437257758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a administration is required. <br /></td></tr>
<tr class="separator:aad9d3b03c50a0a43cff8d2d437257758"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a130c483ec12ccfc11cddc0b1162a318e" id="r_a130c483ec12ccfc11cddc0b1162a318e"><td class="memItemLeft" align="right" valign="top"><a id="a130c483ec12ccfc11cddc0b1162a318e" name="a130c483ec12ccfc11cddc0b1162a318e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodes</b></td></tr>
<tr class="memdesc:a130c483ec12ccfc11cddc0b1162a318e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh nodes (xk, yk) <br /></td></tr>
<tr class="separator:a130c483ec12ccfc11cddc0b1162a318e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b337f739ad083ffe320366f6e9dc0e" id="r_a84b337f739ad083ffe320366f6e9dc0e"><td class="memItemLeft" align="right" valign="top"><a id="a84b337f739ad083ffe320366f6e9dc0e" name="a84b337f739ad083ffe320366f6e9dc0e"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edges</b></td></tr>
<tr class="memdesc:a84b337f739ad083ffe320366f6e9dc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges, defined as first and second node(kn) <br /></td></tr>
<tr class="separator:a84b337f739ad083ffe320366f6e9dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2d meshes. </p>
<p>MeshKernel can handle 2d meshes and 1d meshes. Algorithms require certain mappings to be available for both <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">Mesh1D</a> and <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a>, such as a mapping listing all edge indices connected to a particular node. The methods computing these mappings are shared between <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> and <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">Mesh1D</a>, and implemented in the <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a> base class. The <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a> base class also contains other common data members, such as the node coordinate, the edges definitions, the face definitions and the mesh projection. The <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a> base class has the following responsibilities:</p>
<ul>
<li>Construct the mesh faces from the nodes and edges and other mesh mappings required by all algorithms (Mesh::FindFaces). Mesh::FindFaces is using recursion to find faces with up to 6 edges (meshkernel::Mesh::m_maximumNumberOfEdgesPerFace).</li>
<li>Supporting mesh editing, namely:<ul>
<li>Node merging</li>
<li>Node insertion</li>
<li>Moving a node</li>
<li>Inserting edges</li>
<li>Deleting edges</li>
<li>Merging nodes (merging two nodes at meshkernel::mergingDistance). This algorithm use an r-tree for inquiring adjacent nodes, see later.</li>
</ul>
</li>
<li>Converting a curvilinear grid to an unstructured mesh (converting constructor).</li>
<li>Holding the mesh projection (cartesian, spherical, or spherical accurate).</li>
<li>Making a quad mesh from a polygon or from parameters.</li>
<li>Making a triangular mesh from a polygon. This algorithm introduces a dependency on the Richard Shewchuk Triangle.c library, added as an external component in extern/triangle folder.</li>
</ul>
<p>The public interface of the mesh class contains several algorithms, which modify the mesh class members when they are called. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2bdcf8039b306fc22ee56210ac137078" name="a2bdcf8039b306fc22ee56210ac137078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdcf8039b306fc22ee56210ac137078">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">meshkernel::Mesh::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerator describing the different mesh types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc" name="a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc"></a>Mesh1D&#160;</td><td class="fielddoc"><p><a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">Mesh1D</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13" name="a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13"></a>Mesh2D&#160;</td><td class="fielddoc"><p><a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6b01249e9753c76d0ec3942bd5027105" name="a6b01249e9753c76d0ec3942bd5027105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b01249e9753c76d0ec3942bd5027105">&#9670;&#160;</a></span>Mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty mesh, sets only the projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77a21a6199afcf9444f0e7ae17856dcf" name="a77a21a6199afcf9444f0e7ae17856dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a21a6199afcf9444f0e7ae17856dcf">&#9670;&#160;</a></span>Mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh starting from the edges and nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a301daf1e7c422cf9a52ed4e42911c481" name="a301daf1e7c422cf9a52ed4e42911c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301daf1e7c422cf9a52ed4e42911c481">&#9670;&#160;</a></span>Administrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void meshkernel::Mesh::Administrate </td>
          <td>(</td>
          <td class="paramtype">CompoundUndoAction *&#160;</td>
          <td class="paramname"><em>undoAction</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform complete administration. </p>

<p>Reimplemented in <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7bcb5177e39e5d5ce3b233a5942fe6c2">meshkernel::Mesh2D</a>.</p>

</div>
</div>
<a id="acffd09195a02e96eac266e7463ac8e8b" name="acffd09195a02e96eac266e7463ac8e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffd09195a02e96eac266e7463ac8e8b">&#9670;&#160;</a></span>BuildTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::BuildTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the rtree for the corresponding location, using only the locations inside the bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>The mesh location for which the RTree is build </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e26b86c6e8ab77c1dc9d4c56cf4cca3" name="a2e26b86c6e8ab77c1dc9d4c56cf4cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26b86c6e8ab77c1dc9d4c56cf4cca3">&#9670;&#160;</a></span>ComputeFaceClosedPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::ComputeFaceClosedPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygonNodesCache</td><td>The cache array to be filled with the nodes values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a075ded54a29dee5b05496aa50b6b3c50" name="a075ded54a29dee5b05496aa50b6b3c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075ded54a29dee5b05496aa50b6b3c50">&#9670;&#160;</a></span>ComputeLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; meshkernel::Mesh::ComputeLocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a>&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>The mesh location (e.g. nodes, edge centers or face circumcenters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with the mesh locations. </dd></dl>

</div>
</div>
<a id="a3da42e1182d41c447138731467f2e20a" name="a3da42e1182d41c447138731467f2e20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da42e1182d41c447138731467f2e20a">&#9670;&#160;</a></span>ConnectNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddEdgeAction &gt; &gt; meshkernel::Mesh::ConnectNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>collectUndo</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two existing nodes, checking if the nodes are already connected. If the nodes are not connected a new edge is formed, otherwise UInt invalid value is returned. (connectdbn) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The start node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The end node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collectUndo</td><td>Indicate whether or not an undo action should be created, if false then the undo result will be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the new edge and the undoAction to connect two nodes </dd></dl>

</div>
</div>
<a id="abb72cad3fc82f848dc6352fb324a8a3f" name="abb72cad3fc82f848dc6352fb324a8a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb72cad3fc82f848dc6352fb324a8a3f">&#9670;&#160;</a></span>DeleteEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; DeleteEdgeAction &gt; meshkernel::Mesh::DeleteEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>collectUndo</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The edge index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collectUndo</td><td>Indicate whether or not an undo action should be created, if false then the undo result will be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The undoAction to delete the edge </dd></dl>

</div>
</div>
<a id="a755064d05033b73f98f6d2543775c471" name="a755064d05033b73f98f6d2543775c471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755064d05033b73f98f6d2543775c471">&#9670;&#160;</a></span>DeleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; DeleteNodeAction &gt; meshkernel::Mesh::DeleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>collectUndo</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a node and removes any connected edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collectUndo</td><td>Indicate whether or not an undo action should be created, if false then the undo result will be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The undoAction to delete the node and any connecting edges </dd></dl>

</div>
</div>
<a id="a86a3ba1a2f8974d7367680ea71a70b28" name="a86a3ba1a2f8974d7367680ea71a70b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a3ba1a2f8974d7367680ea71a70b28">&#9670;&#160;</a></span>FindCommonNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::FindCommonNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>firstEdgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>secondEdgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstEdgeIndex</td><td>The index of the first edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondEdgeIndex</td><td>The index of the second edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shared node (constants::missing::sizetValue if no node is found) </dd></dl>

</div>
</div>
<a id="adca9e46fe37ed14e5b42ca498c8f9c42" name="adca9e46fe37ed14e5b42ca498c8f9c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca9e46fe37ed14e5b42ca498c8f9c42">&#9670;&#160;</a></span>FindEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::FindEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>firstNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>secondNodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the edge sharing two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeIndex</td><td>The index of the first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeIndex</td><td>The index of the second node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge index </dd></dl>

</div>
</div>
<a id="a5285ea22b80c3cf51e3ad1d11b7363d3" name="a5285ea22b80c3cf51e3ad1d11b7363d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5285ea22b80c3cf51e3ad1d11b7363d3">&#9670;&#160;</a></span>FindEdgeWithLinearSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::FindEdgeWithLinearSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>firstNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>secondNodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the edge using a linear search, without connectivity information (much slower than FindEdge) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeIndex</td><td>The index of the first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeIndex</td><td>The index of the second node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge index </dd></dl>

</div>
</div>
<a id="a295b39772ba615d01ee00b7cafab6a37" name="a295b39772ba615d01ee00b7cafab6a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295b39772ba615d01ee00b7cafab6a37">&#9670;&#160;</a></span>FindLocationIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::FindLocationIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>locationMask</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of a location (node/edge or face) close to a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The starting point from where to start the search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>The location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationMask</td><td>The mask to apply to each location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest node </dd></dl>

</div>
</div>
<a id="a42d72c761ca10c957623ab8b7c98e20a" name="a42d72c761ca10c957623ab8b7c98e20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d72c761ca10c957623ab8b7c98e20a">&#9670;&#160;</a></span>FindNodeCloseToAPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::FindNodeCloseToAPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_point.html">Point</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of a node close to a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The starting point from where to start the search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The search radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest node </dd></dl>

</div>
</div>
<a id="ac67a9e12803a1fbfb043d5edd0f71d79" name="ac67a9e12803a1fbfb043d5edd0f71d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67a9e12803a1fbfb043d5edd0f71d79">&#9670;&#160;</a></span>GetLocalFaceNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetLocalFaceNodeIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local index of the node belong to a face. </p>
<p>If the node cannot be found the null value will be returned. </p>

</div>
</div>
<a id="a5150280bdba56884de15211a34e64155" name="a5150280bdba56884de15211a34e64155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150280bdba56884de15211a34e64155">&#9670;&#160;</a></span>GetNumEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto meshkernel::Mesh::GetNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of valid edges. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid edges </dd></dl>

</div>
</div>
<a id="ac9d0b7f5a23cb1848df66863ec5644d9" name="ac9d0b7f5a23cb1848df66863ec5644d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d0b7f5a23cb1848df66863ec5644d9">&#9670;&#160;</a></span>GetNumEdgesFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetNumEdgesFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of faces an edges shares. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeIndex</td><td>The edge index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces an edges shares </dd></dl>

</div>
</div>
<a id="a1ed907d8c59c2d8f38edc0a9cf844440" name="a1ed907d8c59c2d8f38edc0a9cf844440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed907d8c59c2d8f38edc0a9cf844440">&#9670;&#160;</a></span>GetNumFaceEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetNumFaceEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges for a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of valid faces </dd></dl>

</div>
</div>
<a id="a50abbc0382968330e4a530e84f093194" name="a50abbc0382968330e4a530e84f093194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50abbc0382968330e4a530e84f093194">&#9670;&#160;</a></span>GetNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto meshkernel::Mesh::GetNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of valid faces. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid faces </dd></dl>

</div>
</div>
<a id="aacdde73c3f0dd734948065fc83bb7a61" name="aacdde73c3f0dd734948065fc83bb7a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdde73c3f0dd734948065fc83bb7a61">&#9670;&#160;</a></span>GetNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto meshkernel::Mesh::GetNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of valid nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid node </dd></dl>

</div>
</div>
<a id="ad2968e88cb2bd6cfd973f1a65393e32b" name="ad2968e88cb2bd6cfd973f1a65393e32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2968e88cb2bd6cfd973f1a65393e32b">&#9670;&#160;</a></span>GetNumNodesEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetNumNodesEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges for a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of valid nodes </dd></dl>

</div>
</div>
<a id="ac3513b12402aff0e4d207ad41ab6a1f7" name="ac3513b12402aff0e4d207ad41ab6a1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3513b12402aff0e4d207ad41ab6a1f7">&#9670;&#160;</a></span>GetNumValidEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetNumValidEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of valid edges. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid edges </dd></dl>

</div>
</div>
<a id="aa5092d7f49e94dfbd5c693e64f288145" name="aa5092d7f49e94dfbd5c693e64f288145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5092d7f49e94dfbd5c693e64f288145">&#9670;&#160;</a></span>GetNumValidNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh::GetNumValidNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of valid nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid nodes </dd></dl>

</div>
</div>
<a id="af6d2dacb6f55d6f640d89e37b19d0982" name="af6d2dacb6f55d6f640d89e37b19d0982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d2dacb6f55d6f640d89e37b19d0982">&#9670;&#160;</a></span>InsertNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddNodeAction &gt; &gt; meshkernel::Mesh::InsertNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>newPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node in the mesh (setnewpoint) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPoint</td><td>The coordinate of the new point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the new node and the pointer to the undoAction </dd></dl>

</div>
</div>
<a id="a7569153beacd2187549c3cdf56141a41" name="a7569153beacd2187549c3cdf56141a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569153beacd2187549c3cdf56141a41">&#9670;&#160;</a></span>IsEdgeOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Mesh::IsEdgeOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquire if an edge is on boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The edge index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the edge is on boundary </dd></dl>

</div>
</div>
<a id="a59544d3cee42126f27bed0da80518051" name="a59544d3cee42126f27bed0da80518051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59544d3cee42126f27bed0da80518051">&#9670;&#160;</a></span>IsFaceOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Mesh::IsFaceOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire if a face is on boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The face index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the face is on boundary </dd></dl>

</div>
</div>
<a id="afcb7298b6024ac7ba6782dbdb9b36f4d" name="afcb7298b6024ac7ba6782dbdb9b36f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb7298b6024ac7ba6782dbdb9b36f4d">&#9670;&#160;</a></span>IsLocationInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_boolean.html">Boolean</a> &gt; meshkernel::Mesh::IsLocationInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes if a location is in polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>The mesh location (e.g. nodes, edge centers or face circumcenters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of booleans indicating if a location is in a polygon or not. </dd></dl>

</div>
</div>
<a id="a557891a65132f1629578381c377fafb7" name="a557891a65132f1629578381c377fafb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557891a65132f1629578381c377fafb7">&#9670;&#160;</a></span>IsNodeOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Mesh::IsNodeOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquire if a node is on boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the node is on boundary </dd></dl>

</div>
</div>
<a id="a60c39d9c4107de7bf1e614a4daab1bf4" name="a60c39d9c4107de7bf1e614a4daab1bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c39d9c4107de7bf1e614a4daab1bf4">&#9670;&#160;</a></span>IsValidEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Mesh::IsValidEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the edge-id is a valid edge. </p>
<p>A valid edge satisfies four conditions: The start and end indices are not the null value, if neither is, then also the nodes indexed by the edge are valid nodes. If any of these conditions is false then the edge is in-valid. </p>

</div>
</div>
<a id="a6f33087e1341b98a7b22de95f12b6f3b" name="a6f33087e1341b98a7b22de95f12b6f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f33087e1341b98a7b22de95f12b6f3b">&#9670;&#160;</a></span>Join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh::Join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The mesh to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The undo action </dd></dl>

</div>
</div>
<a id="a5b1ff2fd9ced80bb851072bfa3d73ffc" name="a5b1ff2fd9ced80bb851072bfa3d73ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1ff2fd9ced80bb851072bfa3d73ffc">&#9670;&#160;</a></span>MergeNodesInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh::MergeNodesInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mergingDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td><a class="el" href="classmeshkernel_1_1_polygon.html" title="A closed polygon.">Polygon</a> where to perform the merging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mergingDistance</td><td>The distance below which two nodes will be merged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f607d6c23447110978de1b7fe8366ed" name="a2f607d6c23447110978de1b7fe8366ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f607d6c23447110978de1b7fe8366ed">&#9670;&#160;</a></span>MergeTwoNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh::MergeTwoNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two mesh nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The index of the first node to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The second of the second node to be merged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a028b165a838a5201547dd8ed9f1fa73c" name="a028b165a838a5201547dd8ed9f1fa73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028b165a838a5201547dd8ed9f1fa73c">&#9670;&#160;</a></span>MoveNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh::MoveNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>newPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a node to a new location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPoint</td><td>The new location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeindex</td><td>The index of the node to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adacff872b8bcecdedf5e67af403e8fbe" name="adacff872b8bcecdedf5e67af403e8fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacff872b8bcecdedf5e67af403e8fbe">&#9670;&#160;</a></span>NodeAdministration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Mesh::NodeAdministration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node administration (setnodadmin) </p>
<dl class="section return"><dt>Returns</dt><dd>An estimated indicator for a quadrilateral dominated mesh. </dd></dl>

</div>
</div>
<a id="a913cb71a6bdbe0e37e9505eba9cfddbb" name="a913cb71a6bdbe0e37e9505eba9cfddbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913cb71a6bdbe0e37e9505eba9cfddbb">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp; meshkernel::Mesh::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The mesh to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting mesh </dd></dl>

</div>
</div>
<a id="a32996870084db773349d616d915d20da" name="a32996870084db773349d616d915d20da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32996870084db773349d616d915d20da">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const AddEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add edge action. </p>
<p>Restore mesh to state before edge was added </p>

</div>
</div>
<a id="ab50999836399c1abf107447009c91599" name="ab50999836399c1abf107447009c91599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50999836399c1abf107447009c91599">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const AddNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add node action. </p>
<p>Restore mesh to state before node was added </p>

</div>
</div>
<a id="aec8c0ba1f81f51653e63d32bec74dbed" name="aec8c0ba1f81f51653e63d32bec74dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8c0ba1f81f51653e63d32bec74dbed">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const DeleteEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete edge action. </p>
<p>Restore mesh to state before edge was deleted </p>

</div>
</div>
<a id="a70f3adb13e8805d490cbe379977956a7" name="a70f3adb13e8805d490cbe379977956a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f3adb13e8805d490cbe379977956a7">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const DeleteNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete node action. </p>
<p>Restore mesh to state before node was deleted </p>

</div>
</div>
<a id="ad3a88228580bdf682918ad1be4232a7a" name="ad3a88228580bdf682918ad1be4232a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a88228580bdf682918ad1be4232a7a">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const ResetEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset edge action. </p>
<p>Restore mesh to state before edge was reset </p>

</div>
</div>
<a id="a29eceeabde32650702348e6a275aa08a" name="a29eceeabde32650702348e6a275aa08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eceeabde32650702348e6a275aa08a">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const ResetNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset node action. </p>
<p>Restore mesh to state before node was reset </p>

</div>
</div>
<a id="a9aa3bf27ec07d25b0cf214d2c0ed8565" name="a9aa3bf27ec07d25b0cf214d2c0ed8565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa3bf27ec07d25b0cf214d2c0ed8565">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">FullUnstructuredGridUndo &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo entire node and edge values. </p>
<p>Restore mesh to previous state. </p>

</div>
</div>
<a id="a423dd36a747c4b9887235c3d2a372b02" name="a423dd36a747c4b9887235c3d2a372b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423dd36a747c4b9887235c3d2a372b02">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">MeshConversionAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="a9373b8e04a8a15f955a01587d09f431f" name="a9373b8e04a8a15f955a01587d09f431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9373b8e04a8a15f955a01587d09f431f">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">NodeTranslationAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="a1a94a0519c42f3867d10c55c80275fce" name="a1a94a0519c42f3867d10c55c80275fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94a0519c42f3867d10c55c80275fce">&#9670;&#160;</a></span>SetEdgesRTreeRequiresUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::SetEdgesRTreeRequiresUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the m_edgesRTreeRequiresUpdate flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a127847d3b8a1e6c1f3217eeeb3a1fab5" name="a127847d3b8a1e6c1f3217eeeb3a1fab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127847d3b8a1e6c1f3217eeeb3a1fab5">&#9670;&#160;</a></span>SetFacesRTreeRequiresUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::SetFacesRTreeRequiresUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the m_facesRTreeRequiresUpdate flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1781b066806d37bdd5c5fd224c915af2" name="a1781b066806d37bdd5c5fd224c915af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1781b066806d37bdd5c5fd224c915af2">&#9670;&#160;</a></span>SetNodesRTreeRequiresUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::SetNodesRTreeRequiresUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the m_nodesRTreeRequiresUpdate flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accf79b4b9e80ce47284a4cb1d866790a" name="accf79b4b9e80ce47284a4cb1d866790a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf79b4b9e80ce47284a4cb1d866790a">&#9670;&#160;</a></span>SortEdgesInCounterClockWiseOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::SortEdgesInCounterClockWiseOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort mesh edges around a node in counterclockwise order (Sort_links_ccw) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The first node index where to perform edge sorting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The last node index where to perform edge sorting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="_mesh_8hpp_source.html">Mesh.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
