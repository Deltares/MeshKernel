<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Mesh2D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmeshkernel_1_1_mesh2_d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">meshkernel::Mesh2D Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes.  
 <a href="classmeshkernel_1_1_mesh2_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for meshkernel::Mesh2D:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmeshkernel_1_1_mesh2_d.png" usemap="#meshkernel::Mesh2D_map" alt=""/>
  <map id="meshkernel::Mesh2D_map" name="meshkernel::Mesh2D_map">
<area href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2..." alt="meshkernel::Mesh" shape="rect" coords="0,0,129,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memItemLeft" align="right" valign="top"><a id="a41e7c8bf5e92fec3f46ba18204e8cc6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> { <b>InsideNotIntersected</b> = 0, 
<b>InsideAndIntersected</b> = 1, 
<b>FacesWithIncludedCircumcenters</b> = 2
 }</td></tr>
<tr class="memdesc:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different options to delete a mesh. <br /></td></tr>
<tr class="separator:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db40a7b9ea9151e51231c4af416d47"><td class="memItemLeft" align="right" valign="top"><a id="a17db40a7b9ea9151e51231c4af416d47"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a17db40a7b9ea9151e51231c4af416d47">NodeTypes</a> { <br />
&#160;&#160;<b>internalNode</b>, 
<b>onRing</b>, 
<b>cornerNode</b>, 
<b>hangingNode</b>, 
<br />
&#160;&#160;<b>other</b>
<br />
 }</td></tr>
<tr class="memdesc:a17db40a7b9ea9151e51231c4af416d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different node types. <br /></td></tr>
<tr class="separator:a17db40a7b9ea9151e51231c4af416d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">Type</a> { <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc">Type::Mesh1D</a>, 
<a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13">Type::Mesh2D</a>
 }</td></tr>
<tr class="memdesc:a2bdcf8039b306fc22ee56210ac137078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different mesh types.  <a href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">More...</a><br /></td></tr>
<tr class="separator:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="memItemLeft" align="right" valign="top"><a id="a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397">~Mesh2D</a> () override=default</td></tr>
<tr class="memdesc:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e78d0c19e35d87acc5bdc82559398"><td class="memItemLeft" align="right" valign="top"><a id="a090e78d0c19e35d87acc5bdc82559398"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a090e78d0c19e35d87acc5bdc82559398">Mesh2D</a> ()</td></tr>
<tr class="memdesc:a090e78d0c19e35d87acc5bdc82559398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a090e78d0c19e35d87acc5bdc82559398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971b113521125e64ab3218bcfdaadef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab971b113521125e64ab3218bcfdaadef">Mesh2D</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ab971b113521125e64ab3218bcfdaadef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d using only the projection.  <a href="classmeshkernel_1_1_mesh2_d.html#ab971b113521125e64ab3218bcfdaadef">More...</a><br /></td></tr>
<tr class="separator:ab971b113521125e64ab3218bcfdaadef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667a2395d4b205d7c4be2536bc301eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ac667a2395d4b205d7c4be2536bc301eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">More...</a><br /></td></tr>
<tr class="separator:ac667a2395d4b205d7c4be2536bc301eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f666425d7520ef162b4c546cc8b59a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae3f666425d7520ef162b4c546cc8b59a">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;faceNodes, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;numFaceNodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ae3f666425d7520ef162b4c546cc8b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d from face nodes and num face nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#ae3f666425d7520ef162b4c546cc8b59a">More...</a><br /></td></tr>
<tr class="separator:ae3f666425d7520ef162b4c546cc8b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">Mesh2D</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:aae466a7ef61c51eb720f50d31ed94ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create triangular grid from nodes (triangulatesamplestonetwork)  <a href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">More...</a><br /></td></tr>
<tr class="separator:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="memItemLeft" align="right" valign="top"><a id="a7bcb5177e39e5d5ce3b233a5942fe6c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7bcb5177e39e5d5ce3b233a5942fe6c2">Administrate</a> (CompoundUndoAction *undoAction=nullptr) override</td></tr>
<tr class="memdesc:a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complete administration. <br /></td></tr>
<tr class="separator:a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf625bb91c465cf93bfed19ce43dad50"><td class="memItemLeft" align="right" valign="top"><a id="aaf625bb91c465cf93bfed19ce43dad50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aaf625bb91c465cf93bfed19ce43dad50">ComputeCircumcentersMassCentersAndFaceAreas</a> (bool computeMassCenters=false)</td></tr>
<tr class="memdesc:aaf625bb91c465cf93bfed19ce43dad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face circumcenters. <br /></td></tr>
<tr class="separator:aaf625bb91c465cf93bfed19ce43dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94a7acb30a64061a8767efec60811b"><td class="memItemLeft" align="right" valign="top"><a id="a5b94a7acb30a64061a8767efec60811b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5b94a7acb30a64061a8767efec60811b">FindFaces</a> ()</td></tr>
<tr class="memdesc:a5b94a7acb30a64061a8767efec60811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the face nodes mapping, face mass centers and areas. <br /></td></tr>
<tr class="separator:a5b94a7acb30a64061a8767efec60811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9b754cf034505cda1ff0f96da4e6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0e9b754cf034505cda1ff0f96da4e6f9">FindFacesGivenFaceNodesMapping</a> (const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;faceNodes, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;numFaceNodes)</td></tr>
<tr class="memdesc:a0e9b754cf034505cda1ff0f96da4e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find remaining face information given the face nodes mapping.  <a href="classmeshkernel_1_1_mesh2_d.html#a0e9b754cf034505cda1ff0f96da4e6f9">More...</a><br /></td></tr>
<tr class="separator:a0e9b754cf034505cda1ff0f96da4e6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a585009db6816cbe1b558a06a4430ce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; SphericalCoordinatesOffsetAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4a585009db6816cbe1b558a06a4430ce">OffsetSphericalCoordinates</a> (double minx, double maxx)</td></tr>
<tr class="memdesc:a4a585009db6816cbe1b558a06a4430ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset the x coordinates if m_projection is spherical.  <a href="classmeshkernel_1_1_mesh2_d.html#a4a585009db6816cbe1b558a06a4430ce">More...</a><br /></td></tr>
<tr class="separator:a4a585009db6816cbe1b558a06a4430ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7359958c3f54ba47ee48655e0f26d"><td class="memItemLeft" align="right" valign="top"><a id="a61f7359958c3f54ba47ee48655e0f26d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a61f7359958c3f54ba47ee48655e0f26d">CommitAction</a> (const SphericalCoordinatesOffsetAction &amp;undoAction)</td></tr>
<tr class="memdesc:a61f7359958c3f54ba47ee48655e0f26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the coordinate offset action. <br /></td></tr>
<tr class="separator:a61f7359958c3f54ba47ee48655e0f26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5d1e41a70cbb395250bbc7d0d2d874a6">RestoreAction</a> (const SphericalCoordinatesOffsetAction &amp;undoAction)</td></tr>
<tr class="memdesc:a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the coordinate offset action.  <a href="classmeshkernel_1_1_mesh2_d.html#a5d1e41a70cbb395250bbc7d0d2d874a6">More...</a><br /></td></tr>
<tr class="separator:a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35186078240ebfeac3c6bf9db8160cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a35186078240ebfeac3c6bf9db8160cd2">ComputeFaceClosedPolygonWithLocalMappings</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;localNodeIndicesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;globalEdgeIndicesCache) const</td></tr>
<tr class="memdesc:a35186078240ebfeac3c6bf9db8160cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon and fill local mapping caches (get_cellpolygon)  <a href="classmeshkernel_1_1_mesh2_d.html#a35186078240ebfeac3c6bf9db8160cd2">More...</a><br /></td></tr>
<tr class="separator:a35186078240ebfeac3c6bf9db8160cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbc0d31cca18d130630e3ed8fa653ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#abdbc0d31cca18d130630e3ed8fa653ff">ComputeFaceClosedPolygon</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache) const</td></tr>
<tr class="memdesc:abdbc0d31cca18d130630e3ed8fa653ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon.  <a href="classmeshkernel_1_1_mesh2_d.html#abdbc0d31cca18d130630e3ed8fa653ff">More...</a><br /></td></tr>
<tr class="separator:abdbc0d31cca18d130630e3ed8fa653ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4383fa3d1ca1d1aed4405a629330f4a1">ComputeFaceCircumenter</a> (std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edgesNumFaces) const</td></tr>
<tr class="memdesc:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a closed polygon, compute the circumcenter of a face (getcircumcenter)  <a href="classmeshkernel_1_1_mesh2_d.html#a4383fa3d1ca1d1aed4405a629330f4a1">More...</a><br /></td></tr>
<tr class="separator:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">GetObtuseTrianglesCenters</a> ()</td></tr>
<tr class="memdesc:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass centers of obtuse triangles.  <a href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">More...</a><br /></td></tr>
<tr class="separator:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a40ea7da15823130792bcb0d74214a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6a40ea7da15823130792bcb0d74214a2">GetEdgesCrossingSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a6a40ea7da15823130792bcb0d74214a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges crossing the small flow edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a6a40ea7da15823130792bcb0d74214a2">More...</a><br /></td></tr>
<tr class="separator:a6a40ea7da15823130792bcb0d74214a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acd5a26d4f62a3ef41c124b87cfbb7bae">GetFlowEdgesCenters</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edges) const</td></tr>
<tr class="memdesc:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the flow edges centers from the crossing edges.  <a href="classmeshkernel_1_1_mesh2_d.html#acd5a26d4f62a3ef41c124b87cfbb7bae">More...</a><br /></td></tr>
<tr class="separator:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e19cf1cceaac87805957720cfc2c4f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; meshkernel::UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac0e19cf1cceaac87805957720cfc2c4f">DeleteSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:ac0e19cf1cceaac87805957720cfc2c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small flow edges (removesmallflowlinks, part 1)  <a href="classmeshkernel_1_1_mesh2_d.html#ac0e19cf1cceaac87805957720cfc2c4f">More...</a><br /></td></tr>
<tr class="separator:ac0e19cf1cceaac87805957720cfc2c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d38828414c38b2e458a83abec9348ab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a2d38828414c38b2e458a83abec9348ab">DeleteSmallTrianglesAtBoundaries</a> (double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:a2d38828414c38b2e458a83abec9348ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small triangles at the boundaries (removesmallflowlinks, part 2)  <a href="classmeshkernel_1_1_mesh2_d.html#a2d38828414c38b2e458a83abec9348ab">More...</a><br /></td></tr>
<tr class="separator:a2d38828414c38b2e458a83abec9348ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ba61b67bf1c9b93d8f37124935545b"><td class="memItemLeft" align="right" valign="top"><a id="a43ba61b67bf1c9b93d8f37124935545b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a43ba61b67bf1c9b93d8f37124935545b">ComputeNodeNeighbours</a> ()</td></tr>
<tr class="memdesc:a43ba61b67bf1c9b93d8f37124935545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes m_nodesNodes, see class members. <br /></td></tr>
<tr class="separator:a43ba61b67bf1c9b93d8f37124935545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">GetOrthogonality</a> ()</td></tr>
<tr class="memdesc:afaa6bfaadd219f15bbb7b45ee696a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters.  <a href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">More...</a><br /></td></tr>
<tr class="separator:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee516031de33d12a21a5d0aae1007162"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">GetSmoothness</a> ()</td></tr>
<tr class="memdesc:aee516031de33d12a21a5d0aae1007162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smoothness values, ratios of the face areas.  <a href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">More...</a><br /></td></tr>
<tr class="separator:aee516031de33d12a21a5d0aae1007162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281602c3eee4a57f2f06a89badafa04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">ComputeAspectRatios</a> (std::vector&lt; double &gt; &amp;aspectRatios)</td></tr>
<tr class="memdesc:a281602c3eee4a57f2f06a89badafa04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the aspect ratios (the ratios edges lengths to flow edges lengths)  <a href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">More...</a><br /></td></tr>
<tr class="separator:a281602c3eee4a57f2f06a89badafa04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memItemLeft" align="right" valign="top"><a id="ae70f0bfaf5a55b9b0a76bd6a3d98041f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae70f0bfaf5a55b9b0a76bd6a3d98041f">ClassifyNodes</a> ()</td></tr>
<tr class="memdesc:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the nodes (makenetnodescoding) <br /></td></tr>
<tr class="separator:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893855b697eaa894c585960a265907c8"><td class="memItemLeft" align="right" valign="top"><a id="a893855b697eaa894c585960a265907c8"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a893855b697eaa894c585960a265907c8">DeleteDegeneratedTriangles</a> ()</td></tr>
<tr class="memdesc:a893855b697eaa894c585960a265907c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes coinciding triangles. <br /></td></tr>
<tr class="separator:a893855b697eaa894c585960a265907c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc7d6b768b66089f341be1ba92faebb"><td class="memItemLeft" align="right" valign="top"><a id="a7fc7d6b768b66089f341be1ba92faebb"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7fc7d6b768b66089f341be1ba92faebb">TriangulateFaces</a> ()</td></tr>
<tr class="memdesc:a7fc7d6b768b66089f341be1ba92faebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform non-triangular faces in triangular faces. <br /></td></tr>
<tr class="separator:a7fc7d6b768b66089f341be1ba92faebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acdab15ff562599311e2264f4728844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a1acdab15ff562599311e2264f4728844">MakeDualFace</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node, double enlargementFactor, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;dualFace)</td></tr>
<tr class="memdesc:a1acdab15ff562599311e2264f4728844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dual face around the node, enlarged by a factor.  <a href="classmeshkernel_1_1_mesh2_d.html#a1acdab15ff562599311e2264f4728844">More...</a><br /></td></tr>
<tr class="separator:a1acdab15ff562599311e2264f4728844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1a11d73e8a0c2974e5cd00d628f584"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afa1a11d73e8a0c2974e5cd00d628f584">SortedFacesAroundNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:afa1a11d73e8a0c2974e5cd00d628f584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the faces around a node, sorted in counter clock wise order.  <a href="classmeshkernel_1_1_mesh2_d.html#afa1a11d73e8a0c2974e5cd00d628f584">More...</a><br /></td></tr>
<tr class="separator:afa1a11d73e8a0c2974e5cd00d628f584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b98dd9a2026da36e037a7126f1ecc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af2b98dd9a2026da36e037a7126f1ecc7">ComputeBoundaryPolygons</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:af2b98dd9a2026da36e037a7126f1ecc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol)  <a href="classmeshkernel_1_1_mesh2_d.html#af2b98dd9a2026da36e037a7126f1ecc7">More...</a><br /></td></tr>
<tr class="separator:af2b98dd9a2026da36e037a7126f1ecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9ccf24cf23136393e36d0fd07bbbfff2">WalkBoundaryFromNode</a> (const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;polygon, std::vector&lt; bool &gt; &amp;isVisited, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;currentNode, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;meshBoundaryPolygon) const</td></tr>
<tr class="memdesc:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polygon from the meshboundary, by walking through the mesh.  <a href="classmeshkernel_1_1_mesh2_d.html#a9ccf24cf23136393e36d0fd07bbbfff2">More...</a><br /></td></tr>
<tr class="separator:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54988d04981fbfcc21077fbd44229910"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a54988d04981fbfcc21077fbd44229910">GetHangingEdges</a> () const</td></tr>
<tr class="memdesc:a54988d04981fbfcc21077fbd44229910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hanging edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a54988d04981fbfcc21077fbd44229910">More...</a><br /></td></tr>
<tr class="separator:a54988d04981fbfcc21077fbd44229910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e08244514dfd0cf3a498fa5f8e4921"><td class="memItemLeft" align="right" valign="top"><a id="a74e08244514dfd0cf3a498fa5f8e4921"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a74e08244514dfd0cf3a498fa5f8e4921">DeleteHangingEdges</a> ()</td></tr>
<tr class="memdesc:a74e08244514dfd0cf3a498fa5f8e4921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the hanging edges. <br /></td></tr>
<tr class="separator:a74e08244514dfd0cf3a498fa5f8e4921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9ad446a7de6ca7ea10fa864ef35e02c3">PointFaceIndices</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a collection of points, compute the face indices including them.  <a href="classmeshkernel_1_1_mesh2_d.html#a9ad446a7de6ca7ea10fa864ef35e02c3">More...</a><br /></td></tr>
<tr class="separator:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515a1beaf82f73f9d461d2e0f7795cd7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a515a1beaf82f73f9d461d2e0f7795cd7">DeleteMesh</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> deletionOption, bool invertDeletion)</td></tr>
<tr class="memdesc:a515a1beaf82f73f9d461d2e0f7795cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon, using several options (delnet)  <a href="classmeshkernel_1_1_mesh2_d.html#a515a1beaf82f73f9d461d2e0f7795cd7">More...</a><br /></td></tr>
<tr class="separator:a515a1beaf82f73f9d461d2e0f7795cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a8e7e8009c8aebe6d3d8420be59d7b882">IsSegmentCrossingABoundaryEdge</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;firstPoint, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;secondPoint) const</td></tr>
<tr class="memdesc:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a segment is crossing a face.  <a href="classmeshkernel_1_1_mesh2_d.html#a8e7e8009c8aebe6d3d8420be59d7b882">More...</a><br /></td></tr>
<tr class="separator:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7decde6c1988555f70610c313e68342a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7decde6c1988555f70610c313e68342a">MaskEdgesOfFacesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool invertSelection, bool includeIntersected) const</td></tr>
<tr class="memdesc:a7decde6c1988555f70610c313e68342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the edges of all faces entirely included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#a7decde6c1988555f70610c313e68342a">More...</a><br /></td></tr>
<tr class="separator:a7decde6c1988555f70610c313e68342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0842f06cb37b04dea67fb797056cd216"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">NodeMaskFromEdgeMask</a> (std::vector&lt; int &gt; const &amp;edgeMask) const</td></tr>
<tr class="memdesc:a0842f06cb37b04dea67fb797056cd216"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the edge mask compute the node mask.  <a href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">More...</a><br /></td></tr>
<tr class="separator:a0842f06cb37b04dea67fb797056cd216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">NodeMaskFromPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool inside) const</td></tr>
<tr class="memdesc:adbc47b25ff52ee8fd178b357c7abfe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask all nodes included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">More...</a><br /></td></tr>
<tr class="separator:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4db6fe647045d8c4fe81e44b1dcb7125">FindOppositeEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find edge on the opposite side of the element.  <a href="classmeshkernel_1_1_mesh2_d.html#a4db6fe647045d8c4fe81e44b1dcb7125">More...</a><br /></td></tr>
<tr class="separator:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399739726d1d913f8b23a385abe536aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a399739726d1d913f8b23a385abe536aa">NextFace</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a399739726d1d913f8b23a385abe536aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next face adjacent to the edge on the opposite side.  <a href="classmeshkernel_1_1_mesh2_d.html#a399739726d1d913f8b23a385abe536aa">More...</a><br /></td></tr>
<tr class="separator:a399739726d1d913f8b23a385abe536aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add026690951b8de12423e8722f4b62b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#add026690951b8de12423e8722f4b62b2">GetBoundingBox</a> () const</td></tr>
<tr class="memdesc:add026690951b8de12423e8722f4b62b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mesh bounding box.  <a href="classmeshkernel_1_1_mesh2_d.html#add026690951b8de12423e8722f4b62b2">More...</a><br /></td></tr>
<tr class="separator:add026690951b8de12423e8722f4b62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99b947455c2b4361988bf44711467d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4c99b947455c2b4361988bf44711467d">GetEdgesBoundingBoxes</a> () const</td></tr>
<tr class="memdesc:a4c99b947455c2b4361988bf44711467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding boxes of the mesh edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a4c99b947455c2b4361988bf44711467d">More...</a><br /></td></tr>
<tr class="separator:a4c99b947455c2b4361988bf44711467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e240cdd3977c295abfc2e3eda5d698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af0e240cdd3977c295abfc2e3eda5d698">FindFacesConnectedToNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;sharedFaces) const</td></tr>
<tr class="memdesc:af0e240cdd3977c295abfc2e3eda5d698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all faces that have the given node as a vertex.  <a href="classmeshkernel_1_1_mesh2_d.html#af0e240cdd3977c295abfc2e3eda5d698">More...</a><br /></td></tr>
<tr class="separator:af0e240cdd3977c295abfc2e3eda5d698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474f70f97d938d102081b5ac387ae8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac474f70f97d938d102081b5ac387ae8f">GetConnectingNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;connectedNodes) const</td></tr>
<tr class="memdesc:ac474f70f97d938d102081b5ac387ae8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of all nodes that are connected directly to a give node along connected edges.  <a href="classmeshkernel_1_1_mesh2_d.html#ac474f70f97d938d102081b5ac387ae8f">More...</a><br /></td></tr>
<tr class="separator:ac474f70f97d938d102081b5ac387ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64d42054dcb3624423848632036662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0d64d42054dcb3624423848632036662">FindNodesSharedByFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;sharedFaces, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;connectedNodes, std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;faceNodeMapping) const</td></tr>
<tr class="memdesc:a0d64d42054dcb3624423848632036662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all unique nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#a0d64d42054dcb3624423848632036662">More...</a><br /></td></tr>
<tr class="separator:a0d64d42054dcb3624423848632036662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b1578496d5fe255e70c968ba07b410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a90b1578496d5fe255e70c968ba07b410">IsStartOrEnd</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a90b1578496d5fe255e70c968ba07b410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is at the start or end of the edge.  <a href="classmeshkernel_1_1_mesh2_d.html#a90b1578496d5fe255e70c968ba07b410">More...</a><br /></td></tr>
<tr class="separator:a90b1578496d5fe255e70c968ba07b410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7f92829aacb6bf1ecc27a1219ea304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acd7f92829aacb6bf1ecc27a1219ea304">IsLeftOrRight</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:acd7f92829aacb6bf1ecc27a1219ea304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the element lies on the left or right side of the edge.  <a href="classmeshkernel_1_1_mesh2_d.html#acd7f92829aacb6bf1ecc27a1219ea304">More...</a><br /></td></tr>
<tr class="separator:acd7f92829aacb6bf1ecc27a1219ea304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6f2b9e4b8632901a3d5774a6a4afeea4">FindCommonFace</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge1, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge2) const</td></tr>
<tr class="memdesc:a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the id of the element that is common to both edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a6f2b9e4b8632901a3d5774a6a4afeea4">More...</a><br /></td></tr>
<tr class="separator:a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861f9236f0817b1d2d492817b4773d5"><td class="memItemLeft" align="right" valign="top"><a id="ab861f9236f0817b1d2d492817b4773d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab861f9236f0817b1d2d492817b4773d5">CommitAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab861f9236f0817b1d2d492817b4773d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset node action. <br /></td></tr>
<tr class="separator:ab861f9236f0817b1d2d492817b4773d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e9c403187516bc12e95cacf5a9efe"><td class="memItemLeft" align="right" valign="top"><a id="ae38e9c403187516bc12e95cacf5a9efe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae38e9c403187516bc12e95cacf5a9efe">CommitAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ae38e9c403187516bc12e95cacf5a9efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add node action. <br /></td></tr>
<tr class="separator:ae38e9c403187516bc12e95cacf5a9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94255cd952aa63a7dfef62a5b8316ae5"><td class="memItemLeft" align="right" valign="top"><a id="a94255cd952aa63a7dfef62a5b8316ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a94255cd952aa63a7dfef62a5b8316ae5">CommitAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a94255cd952aa63a7dfef62a5b8316ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add edge action. <br /></td></tr>
<tr class="separator:a94255cd952aa63a7dfef62a5b8316ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b364df4cef58824ace3b7fcebfa72"><td class="memItemLeft" align="right" valign="top"><a id="aec0b364df4cef58824ace3b7fcebfa72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aec0b364df4cef58824ace3b7fcebfa72">CommitAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec0b364df4cef58824ace3b7fcebfa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset edge action. <br /></td></tr>
<tr class="separator:aec0b364df4cef58824ace3b7fcebfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memItemLeft" align="right" valign="top"><a id="a7c598b30ede19fe13e5c6f5d858b57d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7c598b30ede19fe13e5c6f5d858b57d9">CommitAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete node action. <br /></td></tr>
<tr class="separator:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memItemLeft" align="right" valign="top"><a id="a4858c17e1f3bcf4d4d499890eb51b8d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4858c17e1f3bcf4d4d499890eb51b8d7">CommitAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memItemLeft" align="right" valign="top"><a id="a703c00e8af6aa7a5ffdce9d1819d800c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a703c00e8af6aa7a5ffdce9d1819d800c">CommitAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3af477c78c430087b9503e8cca204"><td class="memItemLeft" align="right" valign="top"><a id="a07d3af477c78c430087b9503e8cca204"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a07d3af477c78c430087b9503e8cca204">CommitAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a07d3af477c78c430087b9503e8cca204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete edge action. <br /></td></tr>
<tr class="separator:a07d3af477c78c430087b9503e8cca204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memItemLeft" align="right" valign="top"><a id="a5b6f6003e1fc09bf1ca888bdcc81fb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5b6f6003e1fc09bf1ca888bdcc81fb32">CommitAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node and edge values. <br /></td></tr>
<tr class="separator:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eceeabde32650702348e6a275aa08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a29eceeabde32650702348e6a275aa08a">RestoreAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a29eceeabde32650702348e6a275aa08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset node action.  <a href="classmeshkernel_1_1_mesh2_d.html#a29eceeabde32650702348e6a275aa08a">More...</a><br /></td></tr>
<tr class="separator:a29eceeabde32650702348e6a275aa08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50999836399c1abf107447009c91599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab50999836399c1abf107447009c91599">RestoreAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab50999836399c1abf107447009c91599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add node action.  <a href="classmeshkernel_1_1_mesh2_d.html#ab50999836399c1abf107447009c91599">More...</a><br /></td></tr>
<tr class="separator:ab50999836399c1abf107447009c91599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32996870084db773349d616d915d20da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a32996870084db773349d616d915d20da">RestoreAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a32996870084db773349d616d915d20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add edge action.  <a href="classmeshkernel_1_1_mesh2_d.html#a32996870084db773349d616d915d20da">More...</a><br /></td></tr>
<tr class="separator:a32996870084db773349d616d915d20da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a88228580bdf682918ad1be4232a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ad3a88228580bdf682918ad1be4232a7a">RestoreAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ad3a88228580bdf682918ad1be4232a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset edge action.  <a href="classmeshkernel_1_1_mesh2_d.html#ad3a88228580bdf682918ad1be4232a7a">More...</a><br /></td></tr>
<tr class="separator:ad3a88228580bdf682918ad1be4232a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f3adb13e8805d490cbe379977956a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a70f3adb13e8805d490cbe379977956a7">RestoreAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a70f3adb13e8805d490cbe379977956a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete node action.  <a href="classmeshkernel_1_1_mesh2_d.html#a70f3adb13e8805d490cbe379977956a7">More...</a><br /></td></tr>
<tr class="separator:a70f3adb13e8805d490cbe379977956a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9373b8e04a8a15f955a01587d09f431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9373b8e04a8a15f955a01587d09f431f">RestoreAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a9373b8e04a8a15f955a01587d09f431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <a href="classmeshkernel_1_1_mesh2_d.html#a9373b8e04a8a15f955a01587d09f431f">More...</a><br /></td></tr>
<tr class="separator:a9373b8e04a8a15f955a01587d09f431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dd36a747c4b9887235c3d2a372b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a423dd36a747c4b9887235c3d2a372b02">RestoreAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a423dd36a747c4b9887235c3d2a372b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <a href="classmeshkernel_1_1_mesh2_d.html#a423dd36a747c4b9887235c3d2a372b02">More...</a><br /></td></tr>
<tr class="separator:a423dd36a747c4b9887235c3d2a372b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c0ba1f81f51653e63d32bec74dbed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aec8c0ba1f81f51653e63d32bec74dbed">RestoreAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec8c0ba1f81f51653e63d32bec74dbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete edge action.  <a href="classmeshkernel_1_1_mesh2_d.html#aec8c0ba1f81f51653e63d32bec74dbed">More...</a><br /></td></tr>
<tr class="separator:aec8c0ba1f81f51653e63d32bec74dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">RestoreAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo entire node and edge values.  <a href="classmeshkernel_1_1_mesh2_d.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">More...</a><br /></td></tr>
<tr class="separator:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa6e629107d83c68b952351d071140059"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa6e629107d83c68b952351d071140059">~Mesh</a> ()=default</td></tr>
<tr class="memdesc:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define virtual destructor. <br /></td></tr>
<tr class="separator:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a92e9e838039533bdaf003a150b96834b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a92e9e838039533bdaf003a150b96834b">Mesh</a> ()</td></tr>
<tr class="memdesc:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, setting a cartesian projection. <br /></td></tr>
<tr class="separator:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12d5fbb2e768f70d0b3f7fc8451755 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a1b12d5fbb2e768f70d0b3f7fc8451755"></a>
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1b12d5fbb2e768f70d0b3f7fc8451755">operator=</a> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:a1b12d5fbb2e768f70d0b3f7fc8451755 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete assignment operator. <br /></td></tr>
<tr class="separator:a1b12d5fbb2e768f70d0b3f7fc8451755 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad756d224e6cfd422e7fccc417e2d22c2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ad756d224e6cfd422e7fccc417e2d22c2"></a>
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad756d224e6cfd422e7fccc417e2d22c2">operator=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:ad756d224e6cfd422e7fccc417e2d22c2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete move assignment operator. <br /></td></tr>
<tr class="separator:ad756d224e6cfd422e7fccc417e2d22c2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="afc6c0a003e5bea44c88abdc1836dacbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afc6c0a003e5bea44c88abdc1836dacbb">Mesh</a> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor taking only a mesh. <br /></td></tr>
<tr class="separator:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a105eab06d2e36deef97fe359fd648115"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a105eab06d2e36deef97fe359fd648115">Mesh</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor taking only a mesh. <br /></td></tr>
<tr class="separator:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">Mesh</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty mesh, sets only the projection.  <a href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">More...</a><br /></td></tr>
<tr class="separator:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">Mesh</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">More...</a><br /></td></tr>
<tr class="separator:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">IsNodeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a node is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">More...</a><br /></td></tr>
<tr class="separator:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <a href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">More...</a><br /></td></tr>
<tr class="separator:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">GetNumEdges</a> () const</td></tr>
<tr class="memdesc:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <a href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">More...</a><br /></td></tr>
<tr class="separator:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid faces.  <a href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">More...</a><br /></td></tr>
<tr class="separator:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa5092d7f49e94dfbd5c693e64f288145">GetNumValidNodes</a> () const</td></tr>
<tr class="memdesc:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <a href="classmeshkernel_1_1_mesh.html#aa5092d7f49e94dfbd5c693e64f288145">More...</a><br /></td></tr>
<tr class="separator:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac3513b12402aff0e4d207ad41ab6a1f7">GetNumValidEdges</a> () const</td></tr>
<tr class="memdesc:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <a href="classmeshkernel_1_1_mesh.html#ac3513b12402aff0e4d207ad41ab6a1f7">More...</a><br /></td></tr>
<tr class="separator:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aca36da6ddea6ea4112324aa175820703">GetNumFaceEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex) const</td></tr>
<tr class="memdesc:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a face.  <a href="classmeshkernel_1_1_mesh.html#aca36da6ddea6ea4112324aa175820703">More...</a><br /></td></tr>
<tr class="separator:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a37a524e94ec09b4464618a6e4f060bb2">GetNumEdgesFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeIndex) const</td></tr>
<tr class="memdesc:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces an edges shares.  <a href="classmeshkernel_1_1_mesh.html#a37a524e94ec09b4464618a6e4f060bb2">More...</a><br /></td></tr>
<tr class="separator:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a125c046bcd8bcbd58c3e9b1e1a1eb71a"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a125c046bcd8bcbd58c3e9b1e1a1eb71a">GetEdgeIndex</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local edge number for an element edge. <br /></td></tr>
<tr class="separator:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a63117852b466d3600ecf3574da268173"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a63117852b466d3600ecf3574da268173">GetNodeIndex</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local node number for an element node. <br /></td></tr>
<tr class="separator:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">IsEdgeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge) const</td></tr>
<tr class="memdesc:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if an edge is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">More...</a><br /></td></tr>
<tr class="separator:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">IsFaceOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> face) const</td></tr>
<tr class="memdesc:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a face is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">More...</a><br /></td></tr>
<tr class="separator:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7ca0f6253491d56310e50e820a97c9e7"></a>
const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7ca0f6253491d56310e50e820a97c9e7">Nodes</a> () const</td></tr>
<tr class="memdesc:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vector of all nodes. <br /></td></tr>
<tr class="separator:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a36d4f99b05e95ee10af584d047f879b8"></a>
const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a36d4f99b05e95ee10af584d047f879b8">Node</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node at the position. <br /></td></tr>
<tr class="separator:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a463bb2c80412b27f0d8bbc32ff2c7320"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a463bb2c80412b27f0d8bbc32ff2c7320">SetNodes</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all nodes to a new set of values. <br /></td></tr>
<tr class="separator:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a1f9594e484c99c5faf0de1edc85488f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1f9594e484c99c5faf0de1edc85488f9">SetNode</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node to a new value, bypassing the undo action. <br /></td></tr>
<tr class="separator:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeb531d0a0a90ecfc3edf2a2011bdfb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5aeb531d0a0a90ecfc3edf2a2011bdfb"></a>
std::unique_ptr&lt; ResetNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5aeb531d0a0a90ecfc3edf2a2011bdfb">ResetNode</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:a5aeb531d0a0a90ecfc3edf2a2011bdfb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node to a new value, this value may be the in-valid value. <br /></td></tr>
<tr class="separator:a5aeb531d0a0a90ecfc3edf2a2011bdfb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a099baaed247afdd5ec2f82e7ce9ced4d"></a>
const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a099baaed247afdd5ec2f82e7ce9ced4d">GetEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reference to an edge. <br /></td></tr>
<tr class="separator:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbf46b1fb7d93114eb723b3f81f7ab8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a3cbf46b1fb7d93114eb723b3f81f7ab8"></a>
<a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3cbf46b1fb7d93114eb723b3f81f7ab8">GetEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index)</td></tr>
<tr class="memdesc:a3cbf46b1fb7d93114eb723b3f81f7ab8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-constant reference to an edge. <br /></td></tr>
<tr class="separator:a3cbf46b1fb7d93114eb723b3f81f7ab8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a022bc47ffb98b18a28c7e4b56ae085f4"></a>
const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a022bc47ffb98b18a28c7e4b56ae085f4">Edges</a> () const</td></tr>
<tr class="memdesc:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all edges. <br /></td></tr>
<tr class="separator:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aee197c80cffe9346c7fd74d9d13fa4f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aee197c80cffe9346c7fd74d9d13fa4f0">SetEdges</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all edges to a new set of values. <br /></td></tr>
<tr class="separator:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac67a9e12803a1fbfb043d5edd0f71d79">GetLocalFaceNodeIndex</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex) const</td></tr>
<tr class="memdesc:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index of the node belong to a face.  <a href="classmeshkernel_1_1_mesh.html#ac67a9e12803a1fbfb043d5edd0f71d79">More...</a><br /></td></tr>
<tr class="separator:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6992df078705ad8679054402b94e99 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7d6992df078705ad8679054402b94e99">MergeTwoNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:a7d6992df078705ad8679054402b94e99 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh nodes.  <a href="classmeshkernel_1_1_mesh.html#a7d6992df078705ad8679054402b94e99">More...</a><br /></td></tr>
<tr class="separator:a7d6992df078705ad8679054402b94e99 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baeb5ac7f47b332c86092885b53bca0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3baeb5ac7f47b332c86092885b53bca0">MergeNodesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double mergingDistance)</td></tr>
<tr class="memdesc:a3baeb5ac7f47b332c86092885b53bca0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON)  <a href="classmeshkernel_1_1_mesh.html#a3baeb5ac7f47b332c86092885b53bca0">More...</a><br /></td></tr>
<tr class="separator:a3baeb5ac7f47b332c86092885b53bca0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed1c5cead3d0d000340c0a9650a6eb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddNodeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab2ed1c5cead3d0d000340c0a9650a6eb">InsertNode</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newPoint)</td></tr>
<tr class="memdesc:ab2ed1c5cead3d0d000340c0a9650a6eb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the mesh (setnewpoint)  <a href="classmeshkernel_1_1_mesh.html#ab2ed1c5cead3d0d000340c0a9650a6eb">More...</a><br /></td></tr>
<tr class="separator:ab2ed1c5cead3d0d000340c0a9650a6eb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c96e8923f5255b6a8b5569dce959ec inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddEdgeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac1c96e8923f5255b6a8b5569dce959ec">ConnectNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:ac1c96e8923f5255b6a8b5569dce959ec inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two existing nodes, checking if the nodes are already connected. If the nodes are not connected a new edge is formed, otherwise UInt invalid value is returned. (connectdbn)  <a href="classmeshkernel_1_1_mesh.html#ac1c96e8923f5255b6a8b5569dce959ec">More...</a><br /></td></tr>
<tr class="separator:ac1c96e8923f5255b6a8b5569dce959ec inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba4439acb07a52e8987337c79d7bdd inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a24ba4439acb07a52e8987337c79d7bdd"></a>
std::unique_ptr&lt; ResetEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a24ba4439acb07a52e8987337c79d7bdd">ResetEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId, const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a24ba4439acb07a52e8987337c79d7bdd inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the nodes referenced by the edge. <br /></td></tr>
<tr class="separator:a24ba4439acb07a52e8987337c79d7bdd inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbae141f2126fd84b0ea35bc8b4818c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aabbae141f2126fd84b0ea35bc8b4818c">DeleteNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node)</td></tr>
<tr class="memdesc:aabbae141f2126fd84b0ea35bc8b4818c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node and removes any connected edges.  <a href="classmeshkernel_1_1_mesh.html#aabbae141f2126fd84b0ea35bc8b4818c">More...</a><br /></td></tr>
<tr class="separator:aabbae141f2126fd84b0ea35bc8b4818c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">FindEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge sharing two nodes.  <a href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">More...</a><br /></td></tr>
<tr class="separator:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5285ea22b80c3cf51e3ad1d11b7363d3">FindEdgeWithLinearSearch</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge using a linear search, without connectivity information (much slower than FindEdge)  <a href="classmeshkernel_1_1_mesh.html#a5285ea22b80c3cf51e3ad1d11b7363d3">More...</a><br /></td></tr>
<tr class="separator:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359453dc8b4c1bd4760c2bf72ab32603 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a359453dc8b4c1bd4760c2bf72ab32603">MoveNode</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> newPoint, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeindex)</td></tr>
<tr class="memdesc:a359453dc8b4c1bd4760c2bf72ab32603 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a node to a new location.  <a href="classmeshkernel_1_1_mesh.html#a359453dc8b4c1bd4760c2bf72ab32603">More...</a><br /></td></tr>
<tr class="separator:a359453dc8b4c1bd4760c2bf72ab32603 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a295b39772ba615d01ee00b7cafab6a37">FindLocationIndex</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const std::vector&lt; bool &gt; &amp;locationMask={}, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a location (node/edge or face) close to a point.  <a href="classmeshkernel_1_1_mesh.html#a295b39772ba615d01ee00b7cafab6a37">More...</a><br /></td></tr>
<tr class="separator:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">FindNodeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> const &amp;point, double searchRadius)</td></tr>
<tr class="memdesc:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <a href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">More...</a><br /></td></tr>
<tr class="separator:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad738d054aab158c848e5bb2e5cdbb651 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad738d054aab158c848e5bb2e5cdbb651">DeleteEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge)</td></tr>
<tr class="memdesc:ad738d054aab158c848e5bb2e5cdbb651 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an edge.  <a href="classmeshkernel_1_1_mesh.html#ad738d054aab158c848e5bb2e5cdbb651">More...</a><br /></td></tr>
<tr class="separator:ad738d054aab158c848e5bb2e5cdbb651 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">FindCommonNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstEdgeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondEdgeIndex) const</td></tr>
<tr class="memdesc:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop.  <a href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">More...</a><br /></td></tr>
<tr class="separator:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2d007633404f80e3fb1f2e789bc2859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2d007633404f80e3fb1f2e789bc2859f">ComputeEdgesLengths</a> ()</td></tr>
<tr class="memdesc:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the lengths of all edges in one go. <br /></td></tr>
<tr class="separator:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e71e81d029e40fe4ead76cd7577d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a763e71e81d029e40fe4ead76cd7577d9">ComputeMinEdgeLength</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon) const</td></tr>
<tr class="memdesc:a763e71e81d029e40fe4ead76cd7577d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum edge length of the edges included in the polygon. An edge is considered included if one of the two nodes is inside the polygon.  <a href="classmeshkernel_1_1_mesh.html#a763e71e81d029e40fe4ead76cd7577d9">More...</a><br /></td></tr>
<tr class="separator:a763e71e81d029e40fe4ead76cd7577d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a48b2912121a8b224b96f3f8e15397884"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a48b2912121a8b224b96f3f8e15397884">ComputeEdgesCenters</a> ()</td></tr>
<tr class="memdesc:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the edges centers in one go. <br /></td></tr>
<tr class="separator:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">NodeAdministration</a> ()</td></tr>
<tr class="memdesc:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node administration (setnodadmin)  <a href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">More...</a><br /></td></tr>
<tr class="separator:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="adadf16bf95337fec05384a2dc07798fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adadf16bf95337fec05384a2dc07798fe">DeleteInvalidNodesAndEdges</a> ()</td></tr>
<tr class="memdesc:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all invalid nodes and edges. <br /></td></tr>
<tr class="separator:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5f6053a6652a47c5954eb9f38f61530d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5f6053a6652a47c5954eb9f38f61530d">AdministrateNodesEdges</a> (CompoundUndoAction *undoAction=nullptr)</td></tr>
<tr class="memdesc:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform node and edges administration. <br /></td></tr>
<tr class="separator:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">SortEdgesInCounterClockWiseOrder</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort mesh edges around a node in counterclockwise order (Sort_links_ccw)  <a href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">More...</a><br /></td></tr>
<tr class="separator:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afe1805fbb756c7f015c609eda23a3d4b">ComputeMaxLengthSurroundingEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node)</td></tr>
<tr class="memdesc:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the max length of the edges connected to a node.  <a href="classmeshkernel_1_1_mesh.html#afe1805fbb756c7f015c609eda23a3d4b">More...</a><br /></td></tr>
<tr class="separator:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#acffd09195a02e96eac266e7463ac8e8b">BuildTree</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location, using only the locations inside the bounding box.  <a href="classmeshkernel_1_1_mesh.html#acffd09195a02e96eac266e7463ac8e8b">More...</a><br /></td></tr>
<tr class="separator:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab712987123157ee36c0bdc471bba55fe">ComputeLocations</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates).  <a href="classmeshkernel_1_1_mesh.html#ab712987123157ee36c0bdc471bba55fe">More...</a><br /></td></tr>
<tr class="separator:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a0f889bfa8cbd8c8aa6391a06f6c6 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a486a0f889bfa8cbd8c8aa6391a06f6c6">IsLocationInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a486a0f889bfa8cbd8c8aa6391a06f6c6 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes if a location is in polygon.  <a href="classmeshkernel_1_1_mesh.html#a486a0f889bfa8cbd8c8aa6391a06f6c6">More...</a><br /></td></tr>
<tr class="separator:a486a0f889bfa8cbd8c8aa6391a06f6c6 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">operator+=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;rhs)</td></tr>
<tr class="memdesc:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <a href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">More...</a><br /></td></tr>
<tr class="separator:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ced87b590b72a13a98645223271cf1b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a3ced87b590b72a13a98645223271cf1b"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3ced87b590b72a13a98645223271cf1b">GetValidNodeMapping</a> () const</td></tr>
<tr class="memdesc:a3ced87b590b72a13a98645223271cf1b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the node array mapped to valid nodes. <br /></td></tr>
<tr class="separator:a3ced87b590b72a13a98645223271cf1b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb88655e1e53dfb30be4a710a23ddc39 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="abb88655e1e53dfb30be4a710a23ddc39"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abb88655e1e53dfb30be4a710a23ddc39">GetValidEdgeMapping</a> () const</td></tr>
<tr class="memdesc:abb88655e1e53dfb30be4a710a23ddc39 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the edge array mapped to valid edges. <br /></td></tr>
<tr class="separator:abb88655e1e53dfb30be4a710a23ddc39 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a60c39d9c4107de7bf1e614a4daab1bf4">IsValidEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the edge-id is a valid edge.  <a href="classmeshkernel_1_1_mesh.html#a60c39d9c4107de7bf1e614a4daab1bf4">More...</a><br /></td></tr>
<tr class="separator:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ab861f9236f0817b1d2d492817b4773d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab861f9236f0817b1d2d492817b4773d5">CommitAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset node action. <br /></td></tr>
<tr class="separator:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ae38e9c403187516bc12e95cacf5a9efe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ae38e9c403187516bc12e95cacf5a9efe">CommitAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add node action. <br /></td></tr>
<tr class="separator:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a94255cd952aa63a7dfef62a5b8316ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a94255cd952aa63a7dfef62a5b8316ae5">CommitAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add edge action. <br /></td></tr>
<tr class="separator:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aec0b364df4cef58824ace3b7fcebfa72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aec0b364df4cef58824ace3b7fcebfa72">CommitAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset edge action. <br /></td></tr>
<tr class="separator:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7c598b30ede19fe13e5c6f5d858b57d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7c598b30ede19fe13e5c6f5d858b57d9">CommitAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete node action. <br /></td></tr>
<tr class="separator:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a4858c17e1f3bcf4d4d499890eb51b8d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a4858c17e1f3bcf4d4d499890eb51b8d7">CommitAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a703c00e8af6aa7a5ffdce9d1819d800c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a703c00e8af6aa7a5ffdce9d1819d800c">CommitAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a07d3af477c78c430087b9503e8cca204"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a07d3af477c78c430087b9503e8cca204">CommitAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete edge action. <br /></td></tr>
<tr class="separator:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5b6f6003e1fc09bf1ca888bdcc81fb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5b6f6003e1fc09bf1ca888bdcc81fb32">CommitAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node and edge values. <br /></td></tr>
<tr class="separator:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a29eceeabde32650702348e6a275aa08a">RestoreAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset node action.  <a href="classmeshkernel_1_1_mesh.html#a29eceeabde32650702348e6a275aa08a">More...</a><br /></td></tr>
<tr class="separator:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab50999836399c1abf107447009c91599">RestoreAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add node action.  <a href="classmeshkernel_1_1_mesh.html#ab50999836399c1abf107447009c91599">More...</a><br /></td></tr>
<tr class="separator:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a32996870084db773349d616d915d20da">RestoreAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add edge action.  <a href="classmeshkernel_1_1_mesh.html#a32996870084db773349d616d915d20da">More...</a><br /></td></tr>
<tr class="separator:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad3a88228580bdf682918ad1be4232a7a">RestoreAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset edge action.  <a href="classmeshkernel_1_1_mesh.html#ad3a88228580bdf682918ad1be4232a7a">More...</a><br /></td></tr>
<tr class="separator:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a70f3adb13e8805d490cbe379977956a7">RestoreAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete node action.  <a href="classmeshkernel_1_1_mesh.html#a70f3adb13e8805d490cbe379977956a7">More...</a><br /></td></tr>
<tr class="separator:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9373b8e04a8a15f955a01587d09f431f">RestoreAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <a href="classmeshkernel_1_1_mesh.html#a9373b8e04a8a15f955a01587d09f431f">More...</a><br /></td></tr>
<tr class="separator:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a423dd36a747c4b9887235c3d2a372b02">RestoreAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <a href="classmeshkernel_1_1_mesh.html#a423dd36a747c4b9887235c3d2a372b02">More...</a><br /></td></tr>
<tr class="separator:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aec8c0ba1f81f51653e63d32bec74dbed">RestoreAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete edge action.  <a href="classmeshkernel_1_1_mesh.html#aec8c0ba1f81f51653e63d32bec74dbed">More...</a><br /></td></tr>
<tr class="separator:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">RestoreAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo entire node and edge values.  <a href="classmeshkernel_1_1_mesh.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">More...</a><br /></td></tr>
<tr class="separator:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca1edafa531ecc3454cf2c76d8f3615 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5ca1edafa531ecc3454cf2c76d8f3615"></a>
RTreeBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5ca1edafa531ecc3454cf2c76d8f3615">GetRTree</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a5ca1edafa531ecc3454cf2c76d8f3615 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the RTree for a specific location. <br /></td></tr>
<tr class="separator:a5ca1edafa531ecc3454cf2c76d8f3615 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1781b066806d37bdd5c5fd224c915af2">SetNodesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_nodesRTreeRequiresUpdate flag.  <a href="classmeshkernel_1_1_mesh.html#a1781b066806d37bdd5c5fd224c915af2">More...</a><br /></td></tr>
<tr class="separator:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1a94a0519c42f3867d10c55c80275fce">SetEdgesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_edgesRTreeRequiresUpdate flag.  <a href="classmeshkernel_1_1_mesh.html#a1a94a0519c42f3867d10c55c80275fce">More...</a><br /></td></tr>
<tr class="separator:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a127847d3b8a1e6c1f3217eeeb3a1fab5">SetFacesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_facesRTreeRequiresUpdate flag.  <a href="classmeshkernel_1_1_mesh.html#a127847d3b8a1e6c1f3217eeeb3a1fab5">More...</a><br /></td></tr>
<tr class="separator:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa5e650ff2465fd4798a53f5c81fd6a19"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aa5e650ff2465fd4798a53f5c81fd6a19">Merge</a> (const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh1, const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2)</td></tr>
<tr class="memdesc:aa5e650ff2465fd4798a53f5c81fd6a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges mesh connectivity.  <a href="classmeshkernel_1_1_mesh2_d.html#aa5e650ff2465fd4798a53f5c81fd6a19">More...</a><br /></td></tr>
<tr class="separator:aa5e650ff2465fd4798a53f5c81fd6a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af8b567d8f2cc02909e8c084adca28f9f"><td class="memItemLeft" align="right" valign="top"><a id="af8b567d8f2cc02909e8c084adca28f9f"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af8b567d8f2cc02909e8c084adca28f9f">m_maxNumNeighbours</a> = 0</td></tr>
<tr class="memdesc:af8b567d8f2cc02909e8c084adca28f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of neighbours. <br /></td></tr>
<tr class="separator:af8b567d8f2cc02909e8c084adca28f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a03dea09629645fd2274c4fdff46b7fbe"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a03dea09629645fd2274c4fdff46b7fbe">m_nodesEdges</a></td></tr>
<tr class="memdesc:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the indices of connected edges (nodlin) <br /></td></tr>
<tr class="separator:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa3e9286d4ca6faaa3d67efd1ba641124"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa3e9286d4ca6faaa3d67efd1ba641124">m_nodesNumEdges</a></td></tr>
<tr class="memdesc:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the number of connected edges (nmk) <br /></td></tr>
<tr class="separator:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a626c93ced5e58d4d36ca0cec5479d148"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a626c93ced5e58d4d36ca0cec5479d148">m_nodesNodes</a></td></tr>
<tr class="memdesc:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, its neighbors. <br /></td></tr>
<tr class="separator:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a69248de9529d1c0ad698d056760e5900"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a69248de9529d1c0ad698d056760e5900">m_nodesTypes</a></td></tr>
<tr class="memdesc:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node types (nb) <br /></td></tr>
<tr class="separator:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa6634281d78a1ef707bc5a2376a84524"></a>
std::vector&lt; std::array&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa6634281d78a1ef707bc5a2376a84524">m_edgesFaces</a></td></tr>
<tr class="memdesc:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the shared face index (lne) <br /></td></tr>
<tr class="separator:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a0d9b82e327f0e73333cfb51c94cef5a1"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0d9b82e327f0e73333cfb51c94cef5a1">m_edgesNumFaces</a></td></tr>
<tr class="memdesc:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the number of shared faces(lnn) <br /></td></tr>
<tr class="separator:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5ff01e492e6674565a62206fdead6762"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5ff01e492e6674565a62206fdead6762">m_edgeLengths</a></td></tr>
<tr class="memdesc:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge lengths. <br /></td></tr>
<tr class="separator:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a231d2889405c66b1b5e4db91d86a6ee8"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a231d2889405c66b1b5e4db91d86a6ee8">m_edgesCenters</a></td></tr>
<tr class="memdesc:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges centers. <br /></td></tr>
<tr class="separator:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a38b44ebfdf5d280a25d566fa5a763c78"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a38b44ebfdf5d280a25d566fa5a763c78">m_facesNodes</a></td></tr>
<tr class="memdesc:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes composing the faces, in ccw order (netcellNod) <br /></td></tr>
<tr class="separator:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a61b727bc265546c7da3afd63059060ab"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a61b727bc265546c7da3afd63059060ab">m_numFacesNodes</a></td></tr>
<tr class="memdesc:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes composing the face (netcellN) <br /></td></tr>
<tr class="separator:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a1f33714b34fd0bcd708efc4b44f30b34"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1f33714b34fd0bcd708efc4b44f30b34">m_facesEdges</a></td></tr>
<tr class="memdesc:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge indices composing the face (netcelllin) <br /></td></tr>
<tr class="separator:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a3342f40eb06afd71cc336010e641a227"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3342f40eb06afd71cc336010e641a227">m_facesCircumcenters</a></td></tr>
<tr class="memdesc:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face circumcenters the face circumcenter (xz, yz) <br /></td></tr>
<tr class="separator:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a79821f2e74e22834dcfce0ce0a326e2e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a79821f2e74e22834dcfce0ce0a326e2e">m_facesMassCenters</a></td></tr>
<tr class="memdesc:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces centers of mass (xzw, yzw) <br /></td></tr>
<tr class="separator:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2b24f1ea21171bfd6f803b06a4997d56"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2b24f1ea21171bfd6f803b06a4997d56">m_faceArea</a></td></tr>
<tr class="memdesc:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face area. <br /></td></tr>
<tr class="separator:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a01c05988ff2a54a0ddf3082c7e4aeeb6"></a>
<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a01c05988ff2a54a0ddf3082c7e4aeeb6">m_projection</a></td></tr>
<tr class="memdesc:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection used. <br /></td></tr>
<tr class="separator:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a40fbec78aa3205dd3aa45393869672c5"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a40fbec78aa3205dd3aa45393869672c5">m_maximumNumberOfEdgesPerNode</a> = 16</td></tr>
<tr class="memdesc:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of edges per node. <br /></td></tr>
<tr class="separator:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7fd1f56e9f2ca719b52e92c5e59aa6e4"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7fd1f56e9f2ca719b52e92c5e59aa6e4">m_maximumNumberOfEdgesPerFace</a> = 6</td></tr>
<tr class="memdesc:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of edges per face. <br /></td></tr>
<tr class="separator:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa0ba1181dd7432ce3e1cd77169c4b6a0"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa0ba1181dd7432ce3e1cd77169c4b6a0">m_maximumNumberOfNodesPerFace</a> = 6</td></tr>
<tr class="memdesc:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of nodes per face. <br /></td></tr>
<tr class="separator:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7951192d95f5fd0a5c13b26084f69df7"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7951192d95f5fd0a5c13b26084f69df7">m_maximumNumberOfConnectedNodes</a> = <a class="el" href="classmeshkernel_1_1_mesh.html#a40fbec78aa3205dd3aa45393869672c5">m_maximumNumberOfEdgesPerNode</a> * 4</td></tr>
<tr class="memdesc:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of connected nodes. <br /></td></tr>
<tr class="separator:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a130c483ec12ccfc11cddc0b1162a318e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a130c483ec12ccfc11cddc0b1162a318e">m_nodes</a></td></tr>
<tr class="memdesc:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh nodes (xk, yk) <br /></td></tr>
<tr class="separator:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a84b337f739ad083ffe320366f6e9dc0e"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a84b337f739ad083ffe320366f6e9dc0e">m_edges</a></td></tr>
<tr class="memdesc:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges, defined as first and second node(kn) <br /></td></tr>
<tr class="separator:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes. </p>
<p>When communicating with the client only unstructured meshes are used. Some algorithms generate curvilinear grids, but these are converted to a mesh instance when communicating with the client. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab971b113521125e64ab3218bcfdaadef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab971b113521125e64ab3218bcfdaadef">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a mesh2d using only the projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac667a2395d4b205d7c4be2536bc301eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667a2395d4b205d7c4be2536bc301eb">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d starting from the edges and nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3f666425d7520ef162b4c546cc8b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f666425d7520ef162b4c546cc8b59a">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d from face nodes and num face nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The mesh projection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae466a7ef61c51eb720f50d31ed94ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae466a7ef61c51eb720f50d31ed94ca1">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create triangular grid from nodes (triangulatesamplestonetwork) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>Selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a281602c3eee4a57f2f06a89badafa04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281602c3eee4a57f2f06a89badafa04d">&#9670;&nbsp;</a></span>ComputeAspectRatios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeAspectRatios </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aspectRatios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the aspect ratios (the ratios edges lengths to flow edges lengths) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aspectRatios</td><td>The aspect ratios (passed as reference to avoid re-allocation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2b98dd9a2026da36e037a7126f1ecc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b98dd9a2026da36e037a7126f1ecc7">&#9670;&nbsp;</a></span>ComputeBoundaryPolygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::ComputeBoundaryPolygons </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where the operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polygon mesh boundary </dd></dl>

</div>
</div>
<a id="a4383fa3d1ca1d1aed4405a629330f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4383fa3d1ca1d1aed4405a629330f4a1">&#9670;&nbsp;</a></span>ComputeFaceCircumenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_point.html">Point</a> meshkernel::Mesh2D::ComputeFaceCircumenter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesNumFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a closed polygon, compute the circumcenter of a face (getcircumcenter) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygon</td><td>Cache storing the face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgesNumFaces</td><td>For meshes, the number of faces sharing the edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed circumcenter </dd></dl>

</div>
</div>
<a id="abdbc0d31cca18d130630e3ed8fa653ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbc0d31cca18d130630e3ed8fa653ff">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygonNodesCache</td><td>The cache array to be filled with the nodes values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35186078240ebfeac3c6bf9db8160cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35186078240ebfeac3c6bf9db8160cd2">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygonWithLocalMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygonWithLocalMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>localNodeIndicesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalEdgeIndicesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon and fill local mapping caches (get_cellpolygon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygonNodesCache</td><td>The node cache array filled with the nodes values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localNodeIndicesCache</td><td>The consecutive node index in polygonNodesCache (0, 1, 2,...) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">globalEdgeIndicesCache</td><td>The edge cache array filled with the global edge indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a515a1beaf82f73f9d461d2e0f7795cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515a1beaf82f73f9d461d2e0f7795cd7">&#9670;&nbsp;</a></span>DeleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;UndoAction&gt; meshkernel::Mesh2D::DeleteMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a>&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon, using several options (delnet) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation If this <a class="el" href="classmeshkernel_1_1_polygons.html" title="A class containing a list of polygonaly enclosed regions.">Polygons</a> instance contains multiple polygons, the first one will be taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Inverts the selected node to delete (instead of outside the polygon, inside the polygon) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0e19cf1cceaac87805957720cfc2c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e19cf1cceaac87805957720cfc2c4f">&#9670;&nbsp;</a></span>DeleteSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;meshkernel::UndoAction&gt; meshkernel::Mesh2D::DeleteSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small flow edges (removesmallflowlinks, part 1) </p>
<p>An unstructured mesh can be used to calculate water flow. This involves a pressure gradient between the circumcenters of neighbouring faces. That procedure is numerically unreliable when the distance between face circumcenters (flow edges) becomes too small. Let's consider the following figure </p><div class="image">
<object type="image/svg+xml" data="coincide_circumcenter.svg" style="pointer-events: none;"></object>
<div class="caption">
Coincide circumcenter</div></div>
<p> The algorithm works as follow:</p>
<ul>
<li>Any degenerated triangle (e.g. those having a coinciding node) is removed by collapsing the second and third node into the first one.</li>
<li><p class="startli">The edges crossing small flow edges are found. The flow edge length is computed from the face circumcenters and compared to an estimated cut off distance. The cutoff distance is computed using the face areas as follow:</p>
<p class="startli">\(\textrm{cutOffDistance} = \textrm{threshold} \cdot 0.5 \cdot (\sqrt{\textrm{Area}_I}+\sqrt{\textrm{Area}_{II}})\)</p>
</li>
<li>All small flow edges are flagged with invalid indices and removed from the mesh. Removal occors in the <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7bcb5177e39e5d5ce3b233a5942fe6c2">Mesh2D::Administrate</a> method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a2d38828414c38b2e458a83abec9348ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d38828414c38b2e458a83abec9348ab">&#9670;&nbsp;</a></span>DeleteSmallTrianglesAtBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;UndoAction&gt; meshkernel::Mesh2D::DeleteSmallTrianglesAtBoundaries </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small triangles at the boundaries (removesmallflowlinks, part 2) </p>
<p>This algorithm removes triangles having the following properties:</p><ul>
<li>The are at mesh boundary.</li>
<li>One or more neighboring faces are non-triangles.</li>
<li>The ratio of the face area to the average area of neighboring non triangles is less than a minimum ratio (defaults to 0.2).</li>
<li>The absolute cosine of one internal angle is less than 0.2.</li>
</ul>
<p>These triangles having the above properties are merged by collapsing the face nodes to the node having the minimum absolute cosine (e.g. the node where the internal angle is closer to 90 degrees). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>Small triangles at the boundaries will be eliminated. This threshold is the ration of the face area to the average area of neighboring faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2b9e4b8632901a3d5774a6a4afeea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2b9e4b8632901a3d5774a6a4afeea4">&#9670;&nbsp;</a></span>FindCommonFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::FindCommonFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the id of the element that is common to both edges. </p>
<p>If no such element can be found then the null value will be returned. </p>

</div>
</div>
<a id="af0e240cdd3977c295abfc2e3eda5d698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e240cdd3977c295abfc2e3eda5d698">&#9670;&nbsp;</a></span>FindFacesConnectedToNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindFacesConnectedToNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharedFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all faces that have the given node as a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sharedFaces</td><td>On exit will contain only indices of faces that contain nodeIndex as a node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e9b754cf034505cda1ff0f96da4e6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9b754cf034505cda1ff0f96da4e6f9">&#9670;&nbsp;</a></span>FindFacesGivenFaceNodesMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindFacesGivenFaceNodesMapping </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find remaining face information given the face nodes mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d64d42054dcb3624423848632036662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d64d42054dcb3624423848632036662">&#9670;&nbsp;</a></span>FindNodesSharedByFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindNodesSharedByFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharedFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodeMapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all unique nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sharedFaces</td><td>List of faces that share the nodeIndex as a common node </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">connectedNodes</td><td>List of nodes that are in the patch of shared faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceNodeMapping</td><td>Mapping from node index to the position in connectedNodes list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db6fe647045d8c4fe81e44b1dcb7125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db6fe647045d8c4fe81e44b1dcb7125">&#9670;&nbsp;</a></span>FindOppositeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::FindOppositeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find edge on the opposite side of the element. </p>
<dl class="section note"><dt>Note</dt><dd>Currently only valid of quadrilateral elements. Will throw exception <a class="el" href="classmeshkernel_1_1_not_implemented_error.html" title="A class for throwing not implemented exceptions.">NotImplementedError</a> for non-quadrilateral element shapes. </dd></dl>

</div>
</div>
<a id="add026690951b8de12423e8722f4b62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add026690951b8de12423e8722f4b62b2">&#9670;&nbsp;</a></span>GetBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> meshkernel::Mesh2D::GetBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mesh bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd>The mesh bounding box </dd></dl>

</div>
</div>
<a id="ac474f70f97d938d102081b5ac387ae8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474f70f97d938d102081b5ac387ae8f">&#9670;&nbsp;</a></span>GetConnectingNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::GetConnectingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indices of all nodes that are connected directly to a give node along connected edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connectedNodes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c99b947455c2b4361988bf44711467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99b947455c2b4361988bf44711467d">&#9670;&nbsp;</a></span>GetEdgesBoundingBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a>&gt; meshkernel::Mesh2D::GetEdgesBoundingBoxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bounding boxes of the mesh edges. </p>
<dl class="section return"><dt>Returns</dt><dd>The mesh edges bounding boxes </dd></dl>

</div>
</div>
<a id="a6a40ea7da15823130792bcb0d74214a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a40ea7da15823130792bcb0d74214a2">&#9670;&nbsp;</a></span>GetEdgesCrossingSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::GetEdgesCrossingSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges crossing the small flow edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices of the edges crossing small flow edges </dd></dl>

</div>
</div>
<a id="acd5a26d4f62a3ef41c124b87cfbb7bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5a26d4f62a3ef41c124b87cfbb7bae">&#9670;&nbsp;</a></span>GetFlowEdgesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetFlowEdgesCenters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the flow edges centers from the crossing edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The crossing edges indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The centers of the flow edges </dd></dl>

</div>
</div>
<a id="a54988d04981fbfcc21077fbd44229910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54988d04981fbfcc21077fbd44229910">&#9670;&nbsp;</a></span>GetHangingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::GetHangingEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hanging edges. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the indices of the hanging edges </dd></dl>

</div>
</div>
<a id="aea6575301bc3c4c17e3a76c5efca4ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6575301bc3c4c17e3a76c5efca4ad5">&#9670;&nbsp;</a></span>GetObtuseTrianglesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetObtuseTrianglesCenters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mass centers of obtuse triangles. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of obtuse triangles </dd></dl>

</div>
</div>
<a id="afaa6bfaadd219f15bbb7b45ee696a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa6bfaadd219f15bbb7b45ee696a256">&#9670;&nbsp;</a></span>GetOrthogonality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetOrthogonality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters. </p>
<dl class="section return"><dt>Returns</dt><dd>The edge orthogonality </dd></dl>

</div>
</div>
<a id="aee516031de33d12a21a5d0aae1007162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee516031de33d12a21a5d0aae1007162">&#9670;&nbsp;</a></span>GetSmoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetSmoothness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smoothness values, ratios of the face areas. </p>
<dl class="section return"><dt>Returns</dt><dd>The smoothness at the edges </dd></dl>

</div>
</div>
<a id="acd7f92829aacb6bf1ecc27a1219ea304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7f92829aacb6bf1ecc27a1219ea304">&#9670;&nbsp;</a></span>IsLeftOrRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::IsLeftOrRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>elementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the element lies on the left or right side of the edge. </p>
<p>Returns 0 when the element is on the left and 1 when it is on the right. If one or other edge is not connected to the element then a null value will be returned. </p>

</div>
</div>
<a id="a8e7e8009c8aebe6d3d8420be59d7b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7e8009c8aebe6d3d8420be59d7b882">&#9670;&nbsp;</a></span>IsSegmentCrossingABoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::IsSegmentCrossingABoundaryEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>secondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire if a segment is crossing a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPoint</td><td>The first point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondPoint</td><td>The second point of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the intersectedFace face index and intersected edge index </dd></dl>

</div>
</div>
<a id="a90b1578496d5fe255e70c968ba07b410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b1578496d5fe255e70c968ba07b410">&#9670;&nbsp;</a></span>IsStartOrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::IsStartOrEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is at the start or end of the edge. </p>
<p>Returns 0 when the node is at the start of the edge, 1 when it is at the end and the null value when the edge is not connected to the node. </p>

</div>
</div>
<a id="a1acdab15ff562599311e2264f4728844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acdab15ff562599311e2264f4728844">&#9670;&nbsp;</a></span>MakeDualFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::MakeDualFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>enlargementFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dual face around the node, enlarged by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enlargementFactor</td><td>The factor by which the dual face is enlarged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dualFace</td><td>The dual face to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7decde6c1988555f70610c313e68342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7decde6c1988555f70610c313e68342a">&#9670;&nbsp;</a></span>MaskEdgesOfFacesInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::MaskEdgesOfFacesInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeIntersected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the edges of all faces entirely included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertSelection</td><td>Invert selection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeIntersected</td><td>Included the edges intersected by the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge mask </dd></dl>

</div>
</div>
<a id="aa5e650ff2465fd4798a53f5c81fd6a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e650ff2465fd4798a53f5c81fd6a19">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a>&gt; meshkernel::Mesh2D::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges mesh connectivity. </p>
<p>Only merges the mesh connectivity graphs and updates indices. </p><dl class="section note"><dt>Note</dt><dd>Does not do any administration on the node, edges or elements, it may be required to call Administrate after merging </dd></dl>

</div>
</div>
<a id="a399739726d1d913f8b23a385abe536aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399739726d1d913f8b23a385abe536aa">&#9670;&nbsp;</a></span>NextFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::NextFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next face adjacent to the edge on the opposite side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>The starting face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The starting edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of neighbour face along the edge </dd></dl>

</div>
</div>
<a id="a0842f06cb37b04dea67fb797056cd216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0842f06cb37b04dea67fb797056cd216">&#9670;&nbsp;</a></span>NodeMaskFromEdgeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromEdgeMask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>edgeMask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the edge mask compute the node mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeMask</td><td>The edge mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="adbc47b25ff52ee8fd178b357c7abfe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc47b25ff52ee8fd178b357c7abfe91">&#9670;&nbsp;</a></span>NodeMaskFromPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask all nodes included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Inside or outside option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="a4a585009db6816cbe1b558a06a4430ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a585009db6816cbe1b558a06a4430ce">&#9670;&nbsp;</a></span>OffsetSphericalCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;SphericalCoordinatesOffsetAction&gt; meshkernel::Mesh2D::OffsetSphericalCoordinates </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset the x coordinates if m_projection is spherical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minx</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxx</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad446a7de6ca7ea10fa864ef35e02c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad446a7de6ca7ea10fa864ef35e02c3">&#9670;&nbsp;</a></span>PointFaceIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::PointFaceIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a collection of points, compute the face indices including them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The input point vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indices including the points. </dd></dl>

</div>
</div>
<a id="a32996870084db773349d616d915d20da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32996870084db773349d616d915d20da">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add edge action. </p>
<p>Restore mesh to state before edge was added </p>

</div>
</div>
<a id="ab50999836399c1abf107447009c91599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50999836399c1abf107447009c91599">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add node action. </p>
<p>Restore mesh to state before node was added </p>

</div>
</div>
<a id="aec8c0ba1f81f51653e63d32bec74dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8c0ba1f81f51653e63d32bec74dbed">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete edge action. </p>
<p>Restore mesh to state before edge was deleted </p>

</div>
</div>
<a id="a70f3adb13e8805d490cbe379977956a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f3adb13e8805d490cbe379977956a7">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete node action. </p>
<p>Restore mesh to state before node was deleted </p>

</div>
</div>
<a id="ad3a88228580bdf682918ad1be4232a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a88228580bdf682918ad1be4232a7a">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset edge action. </p>
<p>Restore mesh to state before edge was reset </p>

</div>
</div>
<a id="a29eceeabde32650702348e6a275aa08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eceeabde32650702348e6a275aa08a">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset node action. </p>
<p>Restore mesh to state before node was reset </p>

</div>
</div>
<a id="a5d1e41a70cbb395250bbc7d0d2d874a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e41a70cbb395250bbc7d0d2d874a6">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const SphericalCoordinatesOffsetAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the coordinate offset action. </p>
<p>Restore mesh to state before coordinate offset action was applied </p>

</div>
</div>
<a id="a9aa3bf27ec07d25b0cf214d2c0ed8565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa3bf27ec07d25b0cf214d2c0ed8565">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo entire node and edge values. </p>
<p>Restore mesh to previous state. </p>

</div>
</div>
<a id="a423dd36a747c4b9887235c3d2a372b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423dd36a747c4b9887235c3d2a372b02">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="a9373b8e04a8a15f955a01587d09f431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9373b8e04a8a15f955a01587d09f431f">&#9670;&nbsp;</a></span>RestoreAction() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="afa1a11d73e8a0c2974e5cd00d628f584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1a11d73e8a0c2974e5cd00d628f584">&#9670;&nbsp;</a></span>SortedFacesAroundNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::SortedFacesAroundNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the faces around a node, sorted in counter clock wise order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indexses </dd></dl>

</div>
</div>
<a id="a9ccf24cf23136393e36d0fd07bbbfff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccf24cf23136393e36d0fd07bbbfff2">&#9670;&nbsp;</a></span>WalkBoundaryFromNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::WalkBoundaryFromNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>isVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshBoundaryPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a polygon from the meshboundary, by walking through the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">isVisited</td><td>the visited mesh nodes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">currentNode</td><td>the current node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshBoundaryPolygon</td><td>The resulting polygon points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
