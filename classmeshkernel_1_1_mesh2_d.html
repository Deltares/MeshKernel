<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Mesh2D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmeshkernel_1_1_mesh2_d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">meshkernel::Mesh2D Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes.  
 <a href="classmeshkernel_1_1_mesh2_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for meshkernel::Mesh2D:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmeshkernel_1_1_mesh2_d.png" usemap="#meshkernel::Mesh2D_map" alt=""/>
  <map id="meshkernel::Mesh2D_map" name="meshkernel::Mesh2D_map">
<area href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2..." alt="meshkernel::Mesh" shape="rect" coords="0,0,129,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a41e7c8bf5e92fec3f46ba18204e8cc6e" id="r_a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memItemLeft" align="right" valign="top"><a id="a41e7c8bf5e92fec3f46ba18204e8cc6e" name="a41e7c8bf5e92fec3f46ba18204e8cc6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> { <b>InsideNotIntersected</b> = 0
, <b>InsideAndIntersected</b> = 1
, <b>FacesWithIncludedCircumcenters</b> = 2
 }</td></tr>
<tr class="memdesc:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different options to delete a mesh. <br /></td></tr>
<tr class="separator:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302769bc3f1dd3291f60b7bb62fe85c" id="r_a5302769bc3f1dd3291f60b7bb62fe85c"><td class="memItemLeft" align="right" valign="top"><a id="a5302769bc3f1dd3291f60b7bb62fe85c" name="a5302769bc3f1dd3291f60b7bb62fe85c"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5302769bc3f1dd3291f60b7bb62fe85c">Property</a> { <b>Orthogonality</b> = 0
, <b>EdgeLength</b> = 1
 }</td></tr>
<tr class="memdesc:a5302769bc3f1dd3291f60b7bb62fe85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator for different properties on a 2D mesh. <br /></td></tr>
<tr class="separator:a5302769bc3f1dd3291f60b7bb62fe85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh" id="r_a2bdcf8039b306fc22ee56210ac137078"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">Type</a> { <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc">Mesh1D</a>
, <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13">Mesh2D</a>
 }</td></tr>
<tr class="memdesc:a2bdcf8039b306fc22ee56210ac137078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different mesh types.  <a href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">More...</a><br /></td></tr>
<tr class="separator:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397" id="r_a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="memItemLeft" align="right" valign="top"><a id="a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397" name="a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Mesh2D</b> () override=default</td></tr>
<tr class="memdesc:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a0c3fc6a9a0db8fa5e2ca5ce5a3ba3397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e78d0c19e35d87acc5bdc82559398" id="r_a090e78d0c19e35d87acc5bdc82559398"><td class="memItemLeft" align="right" valign="top"><a id="a090e78d0c19e35d87acc5bdc82559398" name="a090e78d0c19e35d87acc5bdc82559398"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh2D</b> ()</td></tr>
<tr class="memdesc:a090e78d0c19e35d87acc5bdc82559398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a090e78d0c19e35d87acc5bdc82559398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971b113521125e64ab3218bcfdaadef" id="r_ab971b113521125e64ab3218bcfdaadef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab971b113521125e64ab3218bcfdaadef">Mesh2D</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ab971b113521125e64ab3218bcfdaadef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d using only the projection.  <br /></td></tr>
<tr class="separator:ab971b113521125e64ab3218bcfdaadef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667a2395d4b205d7c4be2536bc301eb" id="r_ac667a2395d4b205d7c4be2536bc301eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ac667a2395d4b205d7c4be2536bc301eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d starting from the edges and nodes.  <br /></td></tr>
<tr class="separator:ac667a2395d4b205d7c4be2536bc301eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a715728f7bbf687dc65a05750684b93" id="r_a0a715728f7bbf687dc65a05750684b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0a715728f7bbf687dc65a05750684b93">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;faceNodes, const std::vector&lt; std::uint8_t &gt; &amp;numFaceNodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a0a715728f7bbf687dc65a05750684b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d from face nodes and num face nodes.  <br /></td></tr>
<tr class="separator:a0a715728f7bbf687dc65a05750684b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae466a7ef61c51eb720f50d31ed94ca1" id="r_aae466a7ef61c51eb720f50d31ed94ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">Mesh2D</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:aae466a7ef61c51eb720f50d31ed94ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create triangular grid from nodes (triangulatesamplestonetwork)  <br /></td></tr>
<tr class="separator:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb5177e39e5d5ce3b233a5942fe6c2" id="r_a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7bcb5177e39e5d5ce3b233a5942fe6c2">Administrate</a> (CompoundUndoAction *undoAction=nullptr) override</td></tr>
<tr class="memdesc:a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complete administration.  <br /></td></tr>
<tr class="separator:a7bcb5177e39e5d5ce3b233a5942fe6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf625bb91c465cf93bfed19ce43dad50" id="r_aaf625bb91c465cf93bfed19ce43dad50"><td class="memItemLeft" align="right" valign="top"><a id="aaf625bb91c465cf93bfed19ce43dad50" name="aaf625bb91c465cf93bfed19ce43dad50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeCircumcentersMassCentersAndFaceAreas</b> (bool computeMassCenters=false)</td></tr>
<tr class="memdesc:aaf625bb91c465cf93bfed19ce43dad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face circumcenters. <br /></td></tr>
<tr class="separator:aaf625bb91c465cf93bfed19ce43dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94a7acb30a64061a8767efec60811b" id="r_a5b94a7acb30a64061a8767efec60811b"><td class="memItemLeft" align="right" valign="top"><a id="a5b94a7acb30a64061a8767efec60811b" name="a5b94a7acb30a64061a8767efec60811b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FindFaces</b> ()</td></tr>
<tr class="memdesc:a5b94a7acb30a64061a8767efec60811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the face nodes mapping, face mass centers and areas. <br /></td></tr>
<tr class="separator:a5b94a7acb30a64061a8767efec60811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf9e2a9bfff9bd1d5dd57461e6dc35e" id="r_afdf9e2a9bfff9bd1d5dd57461e6dc35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afdf9e2a9bfff9bd1d5dd57461e6dc35e">FindFacesGivenFaceNodesMapping</a> (const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;faceNodes, const std::vector&lt; std::uint8_t &gt; &amp;numFaceNodes)</td></tr>
<tr class="memdesc:afdf9e2a9bfff9bd1d5dd57461e6dc35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find remaining face information given the face nodes mapping.  <br /></td></tr>
<tr class="separator:afdf9e2a9bfff9bd1d5dd57461e6dc35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c531142aeba050555f0e3a0bbd511a" id="r_af2c531142aeba050555f0e3a0bbd511a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; SphericalCoordinatesOffsetAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af2c531142aeba050555f0e3a0bbd511a">OffsetSphericalCoordinates</a> (double minx, double maxx)</td></tr>
<tr class="memdesc:af2c531142aeba050555f0e3a0bbd511a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset the x coordinates if m_projection is spherical.  <br /></td></tr>
<tr class="separator:af2c531142aeba050555f0e3a0bbd511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7359958c3f54ba47ee48655e0f26d" id="r_a61f7359958c3f54ba47ee48655e0f26d"><td class="memItemLeft" align="right" valign="top"><a id="a61f7359958c3f54ba47ee48655e0f26d" name="a61f7359958c3f54ba47ee48655e0f26d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const SphericalCoordinatesOffsetAction &amp;undoAction)</td></tr>
<tr class="memdesc:a61f7359958c3f54ba47ee48655e0f26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the coordinate offset action. <br /></td></tr>
<tr class="separator:a61f7359958c3f54ba47ee48655e0f26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e41a70cbb395250bbc7d0d2d874a6" id="r_a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5d1e41a70cbb395250bbc7d0d2d874a6">RestoreAction</a> (const SphericalCoordinatesOffsetAction &amp;undoAction)</td></tr>
<tr class="memdesc:a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the coordinate offset action.  <br /></td></tr>
<tr class="separator:a5d1e41a70cbb395250bbc7d0d2d874a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35186078240ebfeac3c6bf9db8160cd2" id="r_a35186078240ebfeac3c6bf9db8160cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a35186078240ebfeac3c6bf9db8160cd2">ComputeFaceClosedPolygonWithLocalMappings</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;localNodeIndicesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;globalEdgeIndicesCache) const</td></tr>
<tr class="memdesc:a35186078240ebfeac3c6bf9db8160cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon and fill local mapping caches (get_cellpolygon)  <br /></td></tr>
<tr class="separator:a35186078240ebfeac3c6bf9db8160cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4383fa3d1ca1d1aed4405a629330f4a1" id="r_a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4383fa3d1ca1d1aed4405a629330f4a1">ComputeFaceCircumenter</a> (std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edgesNumFaces) const</td></tr>
<tr class="memdesc:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a closed polygon, compute the circumcenter of a face (getcircumcenter)  <br /></td></tr>
<tr class="separator:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aa28083ecf38015872214ecdbe09b3" id="r_ad6aa28083ecf38015872214ecdbe09b3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ad6aa28083ecf38015872214ecdbe09b3">GetObtuseTrianglesCenters</a> ()</td></tr>
<tr class="memdesc:ad6aa28083ecf38015872214ecdbe09b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass centers of obtuse triangles.  <br /></td></tr>
<tr class="separator:ad6aa28083ecf38015872214ecdbe09b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db7365c9a2a241c042db6c0356e72e" id="r_a94db7365c9a2a241c042db6c0356e72e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a94db7365c9a2a241c042db6c0356e72e">GetEdgesCrossingSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a94db7365c9a2a241c042db6c0356e72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges crossing the small flow edges.  <br /></td></tr>
<tr class="separator:a94db7365c9a2a241c042db6c0356e72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13131ed214a8cd74427989b5ecfdedb" id="r_ab13131ed214a8cd74427989b5ecfdedb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab13131ed214a8cd74427989b5ecfdedb">GetFlowEdgesCenters</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edges) const</td></tr>
<tr class="memdesc:ab13131ed214a8cd74427989b5ecfdedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the flow edges centers from the crossing edges.  <br /></td></tr>
<tr class="separator:ab13131ed214a8cd74427989b5ecfdedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2321d2206bfadce36a204e90aaab8275" id="r_a2321d2206bfadce36a204e90aaab8275"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; meshkernel::UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a2321d2206bfadce36a204e90aaab8275">DeleteSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a2321d2206bfadce36a204e90aaab8275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small flow edges (removesmallflowlinks, part 1)  <br /></td></tr>
<tr class="separator:a2321d2206bfadce36a204e90aaab8275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76811ff4607395880ad6de6b0e9da326" id="r_a76811ff4607395880ad6de6b0e9da326"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a76811ff4607395880ad6de6b0e9da326">DeleteSmallTrianglesAtBoundaries</a> (double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:a76811ff4607395880ad6de6b0e9da326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small triangles at the boundaries (removesmallflowlinks, part 2)  <br /></td></tr>
<tr class="separator:a76811ff4607395880ad6de6b0e9da326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40fc4f9f371af536d8056eec7353ba" id="r_adc40fc4f9f371af536d8056eec7353ba"><td class="memItemLeft" align="right" valign="top"><a id="adc40fc4f9f371af536d8056eec7353ba" name="adc40fc4f9f371af536d8056eec7353ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeNodeNeighbours</b> (std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;nodesNodes, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;maxNumNeighbours) const</td></tr>
<tr class="memdesc:adc40fc4f9f371af536d8056eec7353ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes node neighbours. <br /></td></tr>
<tr class="separator:adc40fc4f9f371af536d8056eec7353ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636d15e559130e894343536165ea038f" id="r_a636d15e559130e894343536165ea038f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a636d15e559130e894343536165ea038f">ComputeAspectRatios</a> (std::vector&lt; double &gt; &amp;aspectRatios) const</td></tr>
<tr class="memdesc:a636d15e559130e894343536165ea038f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the aspect ratios (the ratios edges lengths to flow edges lengths)  <br /></td></tr>
<tr class="separator:a636d15e559130e894343536165ea038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f0bfaf5a55b9b0a76bd6a3d98041f" id="r_ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memItemLeft" align="right" valign="top"><a id="ae70f0bfaf5a55b9b0a76bd6a3d98041f" name="ae70f0bfaf5a55b9b0a76bd6a3d98041f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClassifyNodes</b> ()</td></tr>
<tr class="memdesc:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the nodes (makenetnodescoding) <br /></td></tr>
<tr class="separator:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ba0114567498045ed60d7243a4bc9" id="r_a3b6ba0114567498045ed60d7243a4bc9"><td class="memItemLeft" align="right" valign="top"><a id="a3b6ba0114567498045ed60d7243a4bc9" name="a3b6ba0114567498045ed60d7243a4bc9"></a>
<a class="el" href="namespacemeshkernel.html#a296258ed24b382bc57ad5d4fe5f325ca">MeshNodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeType</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a3b6ba0114567498045ed60d7243a4bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node type. <br /></td></tr>
<tr class="separator:a3b6ba0114567498045ed60d7243a4bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b0b7e88efb44bdc493a7878a36347d" id="r_af1b0b7e88efb44bdc493a7878a36347d"><td class="memItemLeft" align="right" valign="top"><a id="af1b0b7e88efb44bdc493a7878a36347d" name="af1b0b7e88efb44bdc493a7878a36347d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeTypes</b> (std::vector&lt; <a class="el" href="namespacemeshkernel.html#a296258ed24b382bc57ad5d4fe5f325ca">MeshNodeType</a> &gt; &amp;nodeTypes) const</td></tr>
<tr class="memdesc:af1b0b7e88efb44bdc493a7878a36347d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node type. <br /></td></tr>
<tr class="separator:af1b0b7e88efb44bdc493a7878a36347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dbd80b937d9ceef1b744e0660b89eb" id="r_aa0dbd80b937d9ceef1b744e0660b89eb"><td class="memItemLeft" align="right" valign="top"><a id="aa0dbd80b937d9ceef1b744e0660b89eb" name="aa0dbd80b937d9ceef1b744e0660b89eb"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteDegeneratedTriangles</b> ()</td></tr>
<tr class="memdesc:aa0dbd80b937d9ceef1b744e0660b89eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes coinciding triangles. <br /></td></tr>
<tr class="separator:aa0dbd80b937d9ceef1b744e0660b89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff82e08ce6d7d82eb347c0cc62b2eea4" id="r_aff82e08ce6d7d82eb347c0cc62b2eea4"><td class="memItemLeft" align="right" valign="top"><a id="aff82e08ce6d7d82eb347c0cc62b2eea4" name="aff82e08ce6d7d82eb347c0cc62b2eea4"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TriangulateFaces</b> ()</td></tr>
<tr class="memdesc:aff82e08ce6d7d82eb347c0cc62b2eea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform non-triangular faces in triangular faces. <br /></td></tr>
<tr class="separator:aff82e08ce6d7d82eb347c0cc62b2eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5569ff6833e47a9aeef783f9cccda9f2" id="r_a5569ff6833e47a9aeef783f9cccda9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5569ff6833e47a9aeef783f9cccda9f2">MakeDualFace</a> (const std::span&lt; const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; edgeCentres, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node, double enlargementFactor, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;dualFace) const</td></tr>
<tr class="memdesc:a5569ff6833e47a9aeef783f9cccda9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dual face around the node, enlarged by a factor.  <br /></td></tr>
<tr class="separator:a5569ff6833e47a9aeef783f9cccda9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb634b77ad961d6bf07ef7c91ae1706" id="r_a4eb634b77ad961d6bf07ef7c91ae1706"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4eb634b77ad961d6bf07ef7c91ae1706">SortedFacesAroundNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:a4eb634b77ad961d6bf07ef7c91ae1706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the faces around a node, sorted in counter clock wise order.  <br /></td></tr>
<tr class="separator:a4eb634b77ad961d6bf07ef7c91ae1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fe66dcf09a227009a48bc2f0480845" id="r_a80fe66dcf09a227009a48bc2f0480845"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a80fe66dcf09a227009a48bc2f0480845">ComputeBoundaryPolygons</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:a80fe66dcf09a227009a48bc2f0480845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol)  <br /></td></tr>
<tr class="separator:a80fe66dcf09a227009a48bc2f0480845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccf24cf23136393e36d0fd07bbbfff2" id="r_a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9ccf24cf23136393e36d0fd07bbbfff2">WalkBoundaryFromNode</a> (const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;polygon, std::vector&lt; bool &gt; &amp;isVisited, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;currentNode, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;meshBoundaryPolygon) const</td></tr>
<tr class="memdesc:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polygon from the meshboundary, by walking through the mesh.  <br /></td></tr>
<tr class="separator:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502d0128e5203b330d2bf77f2db30a87" id="r_a502d0128e5203b330d2bf77f2db30a87"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a502d0128e5203b330d2bf77f2db30a87">GetHangingEdges</a> () const</td></tr>
<tr class="memdesc:a502d0128e5203b330d2bf77f2db30a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hanging edges.  <br /></td></tr>
<tr class="separator:a502d0128e5203b330d2bf77f2db30a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e137acb6090e974dccfcb585fdf680" id="r_af7e137acb6090e974dccfcb585fdf680"><td class="memItemLeft" align="right" valign="top"><a id="af7e137acb6090e974dccfcb585fdf680" name="af7e137acb6090e974dccfcb585fdf680"></a>
std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteHangingEdges</b> ()</td></tr>
<tr class="memdesc:af7e137acb6090e974dccfcb585fdf680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the hanging edges. <br /></td></tr>
<tr class="separator:af7e137acb6090e974dccfcb585fdf680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aee37806a7a28ea40ea0ee4fa64c514" id="r_a8aee37806a7a28ea40ea0ee4fa64c514"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a8aee37806a7a28ea40ea0ee4fa64c514">PointFaceIndices</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:a8aee37806a7a28ea40ea0ee4fa64c514"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a collection of points, compute the face indices including them.  <br /></td></tr>
<tr class="separator:a8aee37806a7a28ea40ea0ee4fa64c514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aff255bad361448c527200cfe16e09" id="r_ab9aff255bad361448c527200cfe16e09"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab9aff255bad361448c527200cfe16e09">DeleteMesh</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> deletionOption, bool invertDeletion)</td></tr>
<tr class="memdesc:ab9aff255bad361448c527200cfe16e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon, using several options (delnet)  <br /></td></tr>
<tr class="separator:ab9aff255bad361448c527200cfe16e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6d18641ef8bbc49a66eb948b5669c8" id="r_aec6d18641ef8bbc49a66eb948b5669c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aec6d18641ef8bbc49a66eb948b5669c8">FilterBasedOnMetric</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5302769bc3f1dd3291f60b7bb62fe85c">Property</a> property, double minValue, double maxValue) const</td></tr>
<tr class="memdesc:aec6d18641ef8bbc49a66eb948b5669c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method generates a mask indicating which locations are within the specified range of the given metric.  <br /></td></tr>
<tr class="separator:aec6d18641ef8bbc49a66eb948b5669c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6364f16211c5e72047cfbbbd70f11768" id="r_a6364f16211c5e72047cfbbbd70f11768"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6364f16211c5e72047cfbbbd70f11768">IsSegmentCrossingABoundaryEdge</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;firstPoint, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;secondPoint) const</td></tr>
<tr class="memdesc:a6364f16211c5e72047cfbbbd70f11768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a segment is crossing a face.  <br /></td></tr>
<tr class="separator:a6364f16211c5e72047cfbbbd70f11768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536bf345d626c420afdc8db64804d69e" id="r_a536bf345d626c420afdc8db64804d69e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a536bf345d626c420afdc8db64804d69e">MaskEdgesOfFacesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool invertSelection, bool includeIntersected) const</td></tr>
<tr class="memdesc:a536bf345d626c420afdc8db64804d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the edges of all faces entirely included in all polygons.  <br /></td></tr>
<tr class="separator:a536bf345d626c420afdc8db64804d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2069e81384498a1406d63716bd6f450b" id="r_a2069e81384498a1406d63716bd6f450b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a2069e81384498a1406d63716bd6f450b">NodeMaskFromEdgeMask</a> (std::vector&lt; int &gt; const &amp;edgeMask) const</td></tr>
<tr class="memdesc:a2069e81384498a1406d63716bd6f450b"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the edge mask compute the node mask.  <br /></td></tr>
<tr class="separator:a2069e81384498a1406d63716bd6f450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabeb33421e4c1b1a2f5c4dd40e68397" id="r_acabeb33421e4c1b1a2f5c4dd40e68397"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acabeb33421e4c1b1a2f5c4dd40e68397">NodeMaskFromPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool inside) const</td></tr>
<tr class="memdesc:acabeb33421e4c1b1a2f5c4dd40e68397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask all nodes included in all polygons.  <br /></td></tr>
<tr class="separator:acabeb33421e4c1b1a2f5c4dd40e68397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db6fe647045d8c4fe81e44b1dcb7125" id="r_a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4db6fe647045d8c4fe81e44b1dcb7125">FindOppositeEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find edge on the opposite side of the element.  <br /></td></tr>
<tr class="separator:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399739726d1d913f8b23a385abe536aa" id="r_a399739726d1d913f8b23a385abe536aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a399739726d1d913f8b23a385abe536aa">NextFace</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a399739726d1d913f8b23a385abe536aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next face adjacent to the edge on the opposite side.  <br /></td></tr>
<tr class="separator:a399739726d1d913f8b23a385abe536aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add026690951b8de12423e8722f4b62b2" id="r_add026690951b8de12423e8722f4b62b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#add026690951b8de12423e8722f4b62b2">GetBoundingBox</a> () const</td></tr>
<tr class="memdesc:add026690951b8de12423e8722f4b62b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mesh bounding box.  <br /></td></tr>
<tr class="separator:add026690951b8de12423e8722f4b62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45077997017c259c80222fd03f353107" id="r_a45077997017c259c80222fd03f353107"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a45077997017c259c80222fd03f353107">GetEdgesBoundingBoxes</a> () const</td></tr>
<tr class="memdesc:a45077997017c259c80222fd03f353107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding boxes of the mesh edges.  <br /></td></tr>
<tr class="separator:a45077997017c259c80222fd03f353107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e240cdd3977c295abfc2e3eda5d698" id="r_af0e240cdd3977c295abfc2e3eda5d698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af0e240cdd3977c295abfc2e3eda5d698">FindFacesConnectedToNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;sharedFaces) const</td></tr>
<tr class="memdesc:af0e240cdd3977c295abfc2e3eda5d698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all faces that have the given node as a vertex.  <br /></td></tr>
<tr class="separator:af0e240cdd3977c295abfc2e3eda5d698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474f70f97d938d102081b5ac387ae8f" id="r_ac474f70f97d938d102081b5ac387ae8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac474f70f97d938d102081b5ac387ae8f">GetConnectingNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;connectedNodes) const</td></tr>
<tr class="memdesc:ac474f70f97d938d102081b5ac387ae8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of all nodes that are connected directly to a give node along connected edges.  <br /></td></tr>
<tr class="separator:ac474f70f97d938d102081b5ac387ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c39d2f9df75a0c98f8d63a10f240dee" id="r_a4c39d2f9df75a0c98f8d63a10f240dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4c39d2f9df75a0c98f8d63a10f240dee">FindNodesSharedByFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;sharedFaces, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;connectedNodes, std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;faceNodeMapping) const</td></tr>
<tr class="memdesc:a4c39d2f9df75a0c98f8d63a10f240dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all unique nodes.  <br /></td></tr>
<tr class="separator:a4c39d2f9df75a0c98f8d63a10f240dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b1578496d5fe255e70c968ba07b410" id="r_a90b1578496d5fe255e70c968ba07b410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a90b1578496d5fe255e70c968ba07b410">IsStartOrEnd</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a90b1578496d5fe255e70c968ba07b410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is at the start or end of the edge.  <br /></td></tr>
<tr class="separator:a90b1578496d5fe255e70c968ba07b410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7f92829aacb6bf1ecc27a1219ea304" id="r_acd7f92829aacb6bf1ecc27a1219ea304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acd7f92829aacb6bf1ecc27a1219ea304">IsLeftOrRight</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:acd7f92829aacb6bf1ecc27a1219ea304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the element lies on the left or right side of the edge.  <br /></td></tr>
<tr class="separator:acd7f92829aacb6bf1ecc27a1219ea304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2b9e4b8632901a3d5774a6a4afeea4" id="r_a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6f2b9e4b8632901a3d5774a6a4afeea4">FindCommonFace</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge1, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge2) const</td></tr>
<tr class="memdesc:a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the id of the element that is common to both edges.  <br /></td></tr>
<tr class="separator:a6f2b9e4b8632901a3d5774a6a4afeea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861f9236f0817b1d2d492817b4773d5" id="r_ab861f9236f0817b1d2d492817b4773d5"><td class="memItemLeft" align="right" valign="top"><a id="ab861f9236f0817b1d2d492817b4773d5" name="ab861f9236f0817b1d2d492817b4773d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab861f9236f0817b1d2d492817b4773d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset node action. <br /></td></tr>
<tr class="separator:ab861f9236f0817b1d2d492817b4773d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e9c403187516bc12e95cacf5a9efe" id="r_ae38e9c403187516bc12e95cacf5a9efe"><td class="memItemLeft" align="right" valign="top"><a id="ae38e9c403187516bc12e95cacf5a9efe" name="ae38e9c403187516bc12e95cacf5a9efe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ae38e9c403187516bc12e95cacf5a9efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add node action. <br /></td></tr>
<tr class="separator:ae38e9c403187516bc12e95cacf5a9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94255cd952aa63a7dfef62a5b8316ae5" id="r_a94255cd952aa63a7dfef62a5b8316ae5"><td class="memItemLeft" align="right" valign="top"><a id="a94255cd952aa63a7dfef62a5b8316ae5" name="a94255cd952aa63a7dfef62a5b8316ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a94255cd952aa63a7dfef62a5b8316ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add edge action. <br /></td></tr>
<tr class="separator:a94255cd952aa63a7dfef62a5b8316ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b364df4cef58824ace3b7fcebfa72" id="r_aec0b364df4cef58824ace3b7fcebfa72"><td class="memItemLeft" align="right" valign="top"><a id="aec0b364df4cef58824ace3b7fcebfa72" name="aec0b364df4cef58824ace3b7fcebfa72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec0b364df4cef58824ace3b7fcebfa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset edge action. <br /></td></tr>
<tr class="separator:aec0b364df4cef58824ace3b7fcebfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c598b30ede19fe13e5c6f5d858b57d9" id="r_a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memItemLeft" align="right" valign="top"><a id="a7c598b30ede19fe13e5c6f5d858b57d9" name="a7c598b30ede19fe13e5c6f5d858b57d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete node action. <br /></td></tr>
<tr class="separator:a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858c17e1f3bcf4d4d499890eb51b8d7" id="r_a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memItemLeft" align="right" valign="top"><a id="a4858c17e1f3bcf4d4d499890eb51b8d7" name="a4858c17e1f3bcf4d4d499890eb51b8d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c00e8af6aa7a5ffdce9d1819d800c" id="r_a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memItemLeft" align="right" valign="top"><a id="a703c00e8af6aa7a5ffdce9d1819d800c" name="a703c00e8af6aa7a5ffdce9d1819d800c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3af477c78c430087b9503e8cca204" id="r_a07d3af477c78c430087b9503e8cca204"><td class="memItemLeft" align="right" valign="top"><a id="a07d3af477c78c430087b9503e8cca204" name="a07d3af477c78c430087b9503e8cca204"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a07d3af477c78c430087b9503e8cca204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete edge action. <br /></td></tr>
<tr class="separator:a07d3af477c78c430087b9503e8cca204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f6003e1fc09bf1ca888bdcc81fb32" id="r_a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memItemLeft" align="right" valign="top"><a id="a5b6f6003e1fc09bf1ca888bdcc81fb32" name="a5b6f6003e1fc09bf1ca888bdcc81fb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node and edge values. <br /></td></tr>
<tr class="separator:a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eceeabde32650702348e6a275aa08a" id="r_a29eceeabde32650702348e6a275aa08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a29eceeabde32650702348e6a275aa08a">RestoreAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a29eceeabde32650702348e6a275aa08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset node action.  <br /></td></tr>
<tr class="separator:a29eceeabde32650702348e6a275aa08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50999836399c1abf107447009c91599" id="r_ab50999836399c1abf107447009c91599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab50999836399c1abf107447009c91599">RestoreAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab50999836399c1abf107447009c91599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add node action.  <br /></td></tr>
<tr class="separator:ab50999836399c1abf107447009c91599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32996870084db773349d616d915d20da" id="r_a32996870084db773349d616d915d20da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a32996870084db773349d616d915d20da">RestoreAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a32996870084db773349d616d915d20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add edge action.  <br /></td></tr>
<tr class="separator:a32996870084db773349d616d915d20da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a88228580bdf682918ad1be4232a7a" id="r_ad3a88228580bdf682918ad1be4232a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ad3a88228580bdf682918ad1be4232a7a">RestoreAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ad3a88228580bdf682918ad1be4232a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset edge action.  <br /></td></tr>
<tr class="separator:ad3a88228580bdf682918ad1be4232a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f3adb13e8805d490cbe379977956a7" id="r_a70f3adb13e8805d490cbe379977956a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a70f3adb13e8805d490cbe379977956a7">RestoreAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a70f3adb13e8805d490cbe379977956a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete node action.  <br /></td></tr>
<tr class="separator:a70f3adb13e8805d490cbe379977956a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9373b8e04a8a15f955a01587d09f431f" id="r_a9373b8e04a8a15f955a01587d09f431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9373b8e04a8a15f955a01587d09f431f">RestoreAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a9373b8e04a8a15f955a01587d09f431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a9373b8e04a8a15f955a01587d09f431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dd36a747c4b9887235c3d2a372b02" id="r_a423dd36a747c4b9887235c3d2a372b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a423dd36a747c4b9887235c3d2a372b02">RestoreAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a423dd36a747c4b9887235c3d2a372b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a423dd36a747c4b9887235c3d2a372b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c0ba1f81f51653e63d32bec74dbed" id="r_aec8c0ba1f81f51653e63d32bec74dbed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aec8c0ba1f81f51653e63d32bec74dbed">RestoreAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec8c0ba1f81f51653e63d32bec74dbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete edge action.  <br /></td></tr>
<tr class="separator:aec8c0ba1f81f51653e63d32bec74dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3bf27ec07d25b0cf214d2c0ed8565" id="r_a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">RestoreAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo entire node and edge values.  <br /></td></tr>
<tr class="separator:a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aa6e629107d83c68b952351d071140059"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Mesh</b> ()=default</td></tr>
<tr class="memdesc:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define virtual destructor. <br /></td></tr>
<tr class="separator:aa6e629107d83c68b952351d071140059 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a92e9e838039533bdaf003a150b96834b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> ()</td></tr>
<tr class="memdesc:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, setting a cartesian projection. <br /></td></tr>
<tr class="separator:a92e9e838039533bdaf003a150b96834b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3025be7c99cbd8c75390591234513957 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a3025be7c99cbd8c75390591234513957"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:a3025be7c99cbd8c75390591234513957 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete assignment operator. <br /></td></tr>
<tr class="separator:a3025be7c99cbd8c75390591234513957 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7666c2ed76bb22467bc2c85c00b27e inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a6a7666c2ed76bb22467bc2c85c00b27e"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:a6a7666c2ed76bb22467bc2c85c00b27e inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete move assignment operator. <br /></td></tr>
<tr class="separator:a6a7666c2ed76bb22467bc2c85c00b27e inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh" id="r_afc6c0a003e5bea44c88abdc1836dacbb"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;mesh)=delete</td></tr>
<tr class="memdesc:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor taking only a mesh. <br /></td></tr>
<tr class="separator:afc6c0a003e5bea44c88abdc1836dacbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a105eab06d2e36deef97fe359fd648115"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)=delete</td></tr>
<tr class="memdesc:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor taking only a mesh. <br /></td></tr>
<tr class="separator:a105eab06d2e36deef97fe359fd648115 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a6b01249e9753c76d0ec3942bd5027105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">Mesh</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty mesh, sets only the projection.  <br /></td></tr>
<tr class="separator:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a77a21a6199afcf9444f0e7ae17856dcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">Mesh</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh starting from the edges and nodes.  <br /></td></tr>
<tr class="separator:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a557891a65132f1629578381c377fafb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">IsNodeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a node is on boundary.  <br /></td></tr>
<tr class="separator:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aacdde73c3f0dd734948065fc83bb7a61"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <br /></td></tr>
<tr class="separator:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a5150280bdba56884de15211a34e64155"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">GetNumEdges</a> () const</td></tr>
<tr class="memdesc:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <br /></td></tr>
<tr class="separator:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a50abbc0382968330e4a530e84f093194"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid faces.  <br /></td></tr>
<tr class="separator:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aa5092d7f49e94dfbd5c693e64f288145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa5092d7f49e94dfbd5c693e64f288145">GetNumValidNodes</a> () const</td></tr>
<tr class="memdesc:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <br /></td></tr>
<tr class="separator:aa5092d7f49e94dfbd5c693e64f288145 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ac3513b12402aff0e4d207ad41ab6a1f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac3513b12402aff0e4d207ad41ab6a1f7">GetNumValidEdges</a> () const</td></tr>
<tr class="memdesc:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <br /></td></tr>
<tr class="separator:ac3513b12402aff0e4d207ad41ab6a1f7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2968e88cb2bd6cfd973f1a65393e32b inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ad2968e88cb2bd6cfd973f1a65393e32b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad2968e88cb2bd6cfd973f1a65393e32b">GetNumNodesEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex) const</td></tr>
<tr class="memdesc:ad2968e88cb2bd6cfd973f1a65393e32b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a node.  <br /></td></tr>
<tr class="separator:ad2968e88cb2bd6cfd973f1a65393e32b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed907d8c59c2d8f38edc0a9cf844440 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a1ed907d8c59c2d8f38edc0a9cf844440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1ed907d8c59c2d8f38edc0a9cf844440">GetNumFaceEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex) const</td></tr>
<tr class="memdesc:a1ed907d8c59c2d8f38edc0a9cf844440 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a face.  <br /></td></tr>
<tr class="separator:a1ed907d8c59c2d8f38edc0a9cf844440 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0b7f5a23cb1848df66863ec5644d9 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ac9d0b7f5a23cb1848df66863ec5644d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac9d0b7f5a23cb1848df66863ec5644d9">GetNumEdgesFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeIndex) const</td></tr>
<tr class="memdesc:ac9d0b7f5a23cb1848df66863ec5644d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces an edges shares.  <br /></td></tr>
<tr class="separator:ac9d0b7f5a23cb1848df66863ec5644d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a125c046bcd8bcbd58c3e9b1e1a1eb71a"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEdgeIndex</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local edge number for an element edge. <br /></td></tr>
<tr class="separator:a125c046bcd8bcbd58c3e9b1e1a1eb71a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a63117852b466d3600ecf3574da268173"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeIndex</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> elementId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeId) const</td></tr>
<tr class="memdesc:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local node number for an element node. <br /></td></tr>
<tr class="separator:a63117852b466d3600ecf3574da268173 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a7569153beacd2187549c3cdf56141a41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">IsEdgeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge) const</td></tr>
<tr class="memdesc:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if an edge is on boundary.  <br /></td></tr>
<tr class="separator:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a59544d3cee42126f27bed0da80518051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">IsFaceOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> face) const</td></tr>
<tr class="memdesc:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a face is on boundary.  <br /></td></tr>
<tr class="separator:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a7ca0f6253491d56310e50e820a97c9e7"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes</b> () const</td></tr>
<tr class="memdesc:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vector of all nodes. <br /></td></tr>
<tr class="separator:a7ca0f6253491d56310e50e820a97c9e7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a36d4f99b05e95ee10af584d047f879b8"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node at the position. <br /></td></tr>
<tr class="separator:a36d4f99b05e95ee10af584d047f879b8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a463bb2c80412b27f0d8bbc32ff2c7320"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNodes</b> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all nodes to a new set of values. <br /></td></tr>
<tr class="separator:a463bb2c80412b27f0d8bbc32ff2c7320 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a1f9594e484c99c5faf0de1edc85488f9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNode</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node to a new value, bypassing the undo action. <br /></td></tr>
<tr class="separator:a1f9594e484c99c5faf0de1edc85488f9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71c7c4357d19525efffa3ccb069dc61 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aa71c7c4357d19525efffa3ccb069dc61"><td class="memItemLeft" align="right" valign="top">
std::unique_ptr&lt; ResetNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ResetNode</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newValue)</td></tr>
<tr class="memdesc:aa71c7c4357d19525efffa3ccb069dc61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node to a new value, this value may be the in-valid value. <br /></td></tr>
<tr class="separator:aa71c7c4357d19525efffa3ccb069dc61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a022bc47ffb98b18a28c7e4b56ae085f4"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Edges</b> () const</td></tr>
<tr class="memdesc:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all edges. <br /></td></tr>
<tr class="separator:a022bc47ffb98b18a28c7e4b56ae085f4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a099baaed247afdd5ec2f82e7ce9ced4d"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetEdge</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index) const</td></tr>
<tr class="memdesc:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reference to an edge. <br /></td></tr>
<tr class="separator:a099baaed247afdd5ec2f82e7ce9ced4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aee197c80cffe9346c7fd74d9d13fa4f0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEdges</b> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;newValues)</td></tr>
<tr class="memdesc:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all edges to a new set of values. <br /></td></tr>
<tr class="separator:aee197c80cffe9346c7fd74d9d13fa4f0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96acfe8f0f96766a3de452bb44b170 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a9a96acfe8f0f96766a3de452bb44b170"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEdge</b> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a9a96acfe8f0f96766a3de452bb44b170 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the edge to a new value, bypassing the undo action. <br /></td></tr>
<tr class="separator:a9a96acfe8f0f96766a3de452bb44b170 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf883f0fa0f96b983fcd0d09e315270 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a8cf883f0fa0f96b983fcd0d09e315270"><td class="memItemLeft" align="right" valign="top">
std::unique_ptr&lt; ResetEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ResetEdge</b> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId, const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a8cf883f0fa0f96b983fcd0d09e315270 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the nodes referenced by the edge. <br /></td></tr>
<tr class="separator:a8cf883f0fa0f96b983fcd0d09e315270 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ac67a9e12803a1fbfb043d5edd0f71d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac67a9e12803a1fbfb043d5edd0f71d79">GetLocalFaceNodeIndex</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeIndex) const</td></tr>
<tr class="memdesc:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index of the node belong to a face.  <br /></td></tr>
<tr class="separator:ac67a9e12803a1fbfb043d5edd0f71d79 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f607d6c23447110978de1b7fe8366ed inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a2f607d6c23447110978de1b7fe8366ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2f607d6c23447110978de1b7fe8366ed">MergeTwoNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:a2f607d6c23447110978de1b7fe8366ed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh nodes.  <br /></td></tr>
<tr class="separator:a2f607d6c23447110978de1b7fe8366ed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1ff2fd9ced80bb851072bfa3d73ffc inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a5b1ff2fd9ced80bb851072bfa3d73ffc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5b1ff2fd9ced80bb851072bfa3d73ffc">MergeNodesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double mergingDistance)</td></tr>
<tr class="memdesc:a5b1ff2fd9ced80bb851072bfa3d73ffc inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON)  <br /></td></tr>
<tr class="separator:a5b1ff2fd9ced80bb851072bfa3d73ffc inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d2dacb6f55d6f640d89e37b19d0982 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_af6d2dacb6f55d6f640d89e37b19d0982"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddNodeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#af6d2dacb6f55d6f640d89e37b19d0982">InsertNode</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newPoint)</td></tr>
<tr class="memdesc:af6d2dacb6f55d6f640d89e37b19d0982 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the mesh (setnewpoint)  <br /></td></tr>
<tr class="separator:af6d2dacb6f55d6f640d89e37b19d0982 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da42e1182d41c447138731467f2e20a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a3da42e1182d41c447138731467f2e20a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, std::unique_ptr&lt; AddEdgeAction &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3da42e1182d41c447138731467f2e20a">ConnectNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode, const bool collectUndo=true)</td></tr>
<tr class="memdesc:a3da42e1182d41c447138731467f2e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two existing nodes, checking if the nodes are already connected. If the nodes are not connected a new edge is formed, otherwise UInt invalid value is returned. (connectdbn)  <br /></td></tr>
<tr class="separator:a3da42e1182d41c447138731467f2e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755064d05033b73f98f6d2543775c471 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a755064d05033b73f98f6d2543775c471"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteNodeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a755064d05033b73f98f6d2543775c471">DeleteNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node, const bool collectUndo=true)</td></tr>
<tr class="memdesc:a755064d05033b73f98f6d2543775c471 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node and removes any connected edges.  <br /></td></tr>
<tr class="separator:a755064d05033b73f98f6d2543775c471 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_adca9e46fe37ed14e5b42ca498c8f9c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">FindEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge sharing two nodes.  <br /></td></tr>
<tr class="separator:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a5285ea22b80c3cf51e3ad1d11b7363d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5285ea22b80c3cf51e3ad1d11b7363d3">FindEdgeWithLinearSearch</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge using a linear search, without connectivity information (much slower than FindEdge)  <br /></td></tr>
<tr class="separator:a5285ea22b80c3cf51e3ad1d11b7363d3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b165a838a5201547dd8ed9f1fa73c inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a028b165a838a5201547dd8ed9f1fa73c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a028b165a838a5201547dd8ed9f1fa73c">MoveNode</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> newPoint, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeindex)</td></tr>
<tr class="memdesc:a028b165a838a5201547dd8ed9f1fa73c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a node to a new location.  <br /></td></tr>
<tr class="separator:a028b165a838a5201547dd8ed9f1fa73c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a295b39772ba615d01ee00b7cafab6a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a295b39772ba615d01ee00b7cafab6a37">FindLocationIndex</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const std::vector&lt; bool &gt; &amp;locationMask={}, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a location (node/edge or face) close to a point.  <br /></td></tr>
<tr class="separator:a295b39772ba615d01ee00b7cafab6a37 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a42d72c761ca10c957623ab8b7c98e20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">FindNodeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> const &amp;point, double searchRadius)</td></tr>
<tr class="memdesc:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <br /></td></tr>
<tr class="separator:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb72cad3fc82f848dc6352fb324a8a3f inherit pub_methods_classmeshkernel_1_1_mesh" id="r_abb72cad3fc82f848dc6352fb324a8a3f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; DeleteEdgeAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abb72cad3fc82f848dc6352fb324a8a3f">DeleteEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge, const bool collectUndo=true)</td></tr>
<tr class="memdesc:abb72cad3fc82f848dc6352fb324a8a3f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an edge.  <br /></td></tr>
<tr class="separator:abb72cad3fc82f848dc6352fb324a8a3f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a86a3ba1a2f8974d7367680ea71a70b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">FindCommonNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstEdgeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondEdgeIndex) const</td></tr>
<tr class="memdesc:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop.  <br /></td></tr>
<tr class="separator:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh" id="r_adacff872b8bcecdedf5e67af403e8fbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">NodeAdministration</a> ()</td></tr>
<tr class="memdesc:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node administration (setnodadmin)  <br /></td></tr>
<tr class="separator:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh" id="r_adadf16bf95337fec05384a2dc07798fe"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteInvalidNodesAndEdges</b> ()</td></tr>
<tr class="memdesc:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all invalid nodes and edges. <br /></td></tr>
<tr class="separator:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a5f6053a6652a47c5954eb9f38f61530d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AdministrateNodesEdges</b> (CompoundUndoAction *undoAction=nullptr)</td></tr>
<tr class="memdesc:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform node and edges administration. <br /></td></tr>
<tr class="separator:a5f6053a6652a47c5954eb9f38f61530d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_accf79b4b9e80ce47284a4cb1d866790a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">SortEdgesInCounterClockWiseOrder</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort mesh edges around a node in counterclockwise order (Sort_links_ccw)  <br /></td></tr>
<tr class="separator:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh" id="r_acffd09195a02e96eac266e7463ac8e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#acffd09195a02e96eac266e7463ac8e8b">BuildTree</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox={})</td></tr>
<tr class="memdesc:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location, using only the locations inside the bounding box.  <br /></td></tr>
<tr class="separator:acffd09195a02e96eac266e7463ac8e8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075ded54a29dee5b05496aa50b6b3c50 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a075ded54a29dee5b05496aa50b6b3c50"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a075ded54a29dee5b05496aa50b6b3c50">ComputeLocations</a> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a075ded54a29dee5b05496aa50b6b3c50 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates).  <br /></td></tr>
<tr class="separator:a075ded54a29dee5b05496aa50b6b3c50 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb7298b6024ac7ba6782dbdb9b36f4d inherit pub_methods_classmeshkernel_1_1_mesh" id="r_afcb7298b6024ac7ba6782dbdb9b36f4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_boolean.html">Boolean</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afcb7298b6024ac7ba6782dbdb9b36f4d">IsLocationInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:afcb7298b6024ac7ba6782dbdb9b36f4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes if a location is in polygon.  <br /></td></tr>
<tr class="separator:afcb7298b6024ac7ba6782dbdb9b36f4d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913cb71a6bdbe0e37e9505eba9cfddbb inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a913cb71a6bdbe0e37e9505eba9cfddbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a913cb71a6bdbe0e37e9505eba9cfddbb">operator+=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a913cb71a6bdbe0e37e9505eba9cfddbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <br /></td></tr>
<tr class="separator:a913cb71a6bdbe0e37e9505eba9cfddbb inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33087e1341b98a7b22de95f12b6f3b inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a6f33087e1341b98a7b22de95f12b6f3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; UndoAction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6f33087e1341b98a7b22de95f12b6f3b">Join</a> (const <a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6f33087e1341b98a7b22de95f12b6f3b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <br /></td></tr>
<tr class="separator:a6f33087e1341b98a7b22de95f12b6f3b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a751df055464fae2e83a717599744c7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a8a751df055464fae2e83a717599744c7"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidNodeMapping</b> () const</td></tr>
<tr class="memdesc:a8a751df055464fae2e83a717599744c7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the node array mapped to valid nodes. <br /></td></tr>
<tr class="separator:a8a751df055464fae2e83a717599744c7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f54085e7a7cbaee1c777c6c15d52a3 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a35f54085e7a7cbaee1c777c6c15d52a3"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidEdgeMapping</b> () const</td></tr>
<tr class="memdesc:a35f54085e7a7cbaee1c777c6c15d52a3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapping/indexing from the edge array mapped to valid edges. <br /></td></tr>
<tr class="separator:a35f54085e7a7cbaee1c777c6c15d52a3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a60c39d9c4107de7bf1e614a4daab1bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a60c39d9c4107de7bf1e614a4daab1bf4">IsValidEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the edge-id is a valid edge.  <br /></td></tr>
<tr class="separator:a60c39d9c4107de7bf1e614a4daab1bf4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ab861f9236f0817b1d2d492817b4773d5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset node action. <br /></td></tr>
<tr class="separator:ab861f9236f0817b1d2d492817b4773d5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ae38e9c403187516bc12e95cacf5a9efe"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add node action. <br /></td></tr>
<tr class="separator:ae38e9c403187516bc12e95cacf5a9efe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a94255cd952aa63a7dfef62a5b8316ae5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the add edge action. <br /></td></tr>
<tr class="separator:a94255cd952aa63a7dfef62a5b8316ae5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aec0b364df4cef58824ace3b7fcebfa72"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reset edge action. <br /></td></tr>
<tr class="separator:aec0b364df4cef58824ace3b7fcebfa72 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a7c598b30ede19fe13e5c6f5d858b57d9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete node action. <br /></td></tr>
<tr class="separator:a7c598b30ede19fe13e5c6f5d858b57d9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a4858c17e1f3bcf4d4d499890eb51b8d7"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a4858c17e1f3bcf4d4d499890eb51b8d7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a703c00e8af6aa7a5ffdce9d1819d800c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the node translation action. <br /></td></tr>
<tr class="separator:a703c00e8af6aa7a5ffdce9d1819d800c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a07d3af477c78c430087b9503e8cca204"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the delete edge action. <br /></td></tr>
<tr class="separator:a07d3af477c78c430087b9503e8cca204 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a5b6f6003e1fc09bf1ca888bdcc81fb32"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>CommitAction</b> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node and edge values. <br /></td></tr>
<tr class="separator:a5b6f6003e1fc09bf1ca888bdcc81fb32 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a29eceeabde32650702348e6a275aa08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a29eceeabde32650702348e6a275aa08a">RestoreAction</a> (const ResetNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset node action.  <br /></td></tr>
<tr class="separator:a29eceeabde32650702348e6a275aa08a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ab50999836399c1abf107447009c91599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab50999836399c1abf107447009c91599">RestoreAction</a> (const AddNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add node action.  <br /></td></tr>
<tr class="separator:ab50999836399c1abf107447009c91599 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a32996870084db773349d616d915d20da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a32996870084db773349d616d915d20da">RestoreAction</a> (const AddEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the add edge action.  <br /></td></tr>
<tr class="separator:a32996870084db773349d616d915d20da inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh" id="r_ad3a88228580bdf682918ad1be4232a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad3a88228580bdf682918ad1be4232a7a">RestoreAction</a> (const ResetEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the reset edge action.  <br /></td></tr>
<tr class="separator:ad3a88228580bdf682918ad1be4232a7a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a70f3adb13e8805d490cbe379977956a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a70f3adb13e8805d490cbe379977956a7">RestoreAction</a> (const DeleteNodeAction &amp;undoAction)</td></tr>
<tr class="memdesc:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete node action.  <br /></td></tr>
<tr class="separator:a70f3adb13e8805d490cbe379977956a7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a9373b8e04a8a15f955a01587d09f431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9373b8e04a8a15f955a01587d09f431f">RestoreAction</a> (NodeTranslationAction &amp;undoAction)</td></tr>
<tr class="memdesc:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a9373b8e04a8a15f955a01587d09f431f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a423dd36a747c4b9887235c3d2a372b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a423dd36a747c4b9887235c3d2a372b02">RestoreAction</a> (MeshConversionAction &amp;undoAction)</td></tr>
<tr class="memdesc:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the node translation action.  <br /></td></tr>
<tr class="separator:a423dd36a747c4b9887235c3d2a372b02 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh" id="r_aec8c0ba1f81f51653e63d32bec74dbed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aec8c0ba1f81f51653e63d32bec74dbed">RestoreAction</a> (const DeleteEdgeAction &amp;undoAction)</td></tr>
<tr class="memdesc:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the delete edge action.  <br /></td></tr>
<tr class="separator:aec8c0ba1f81f51653e63d32bec74dbed inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a9aa3bf27ec07d25b0cf214d2c0ed8565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9aa3bf27ec07d25b0cf214d2c0ed8565">RestoreAction</a> (FullUnstructuredGridUndo &amp;undoAction)</td></tr>
<tr class="memdesc:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo entire node and edge values.  <br /></td></tr>
<tr class="separator:a9aa3bf27ec07d25b0cf214d2c0ed8565 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78aac5163ea0222e691ff11d7ddc56 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a1f78aac5163ea0222e691ff11d7ddc56"><td class="memItemLeft" align="right" valign="top">
RTreeBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRTree</b> (<a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a> location) const</td></tr>
<tr class="memdesc:a1f78aac5163ea0222e691ff11d7ddc56 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the RTree for a specific location. <br /></td></tr>
<tr class="separator:a1f78aac5163ea0222e691ff11d7ddc56 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a1781b066806d37bdd5c5fd224c915af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1781b066806d37bdd5c5fd224c915af2">SetNodesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_nodesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a1781b066806d37bdd5c5fd224c915af2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a1a94a0519c42f3867d10c55c80275fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1a94a0519c42f3867d10c55c80275fce">SetEdgesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_edgesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a1a94a0519c42f3867d10c55c80275fce inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a127847d3b8a1e6c1f3217eeeb3a1fab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a127847d3b8a1e6c1f3217eeeb3a1fab5">SetFacesRTreeRequiresUpdate</a> (bool value)</td></tr>
<tr class="memdesc:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the m_facesRTreeRequiresUpdate flag.  <br /></td></tr>
<tr class="separator:a127847d3b8a1e6c1f3217eeeb3a1fab5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26b86c6e8ab77c1dc9d4c56cf4cca3 inherit pub_methods_classmeshkernel_1_1_mesh" id="r_a2e26b86c6e8ab77c1dc9d4c56cf4cca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2e26b86c6e8ab77c1dc9d4c56cf4cca3">ComputeFaceClosedPolygon</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache) const</td></tr>
<tr class="memdesc:a2e26b86c6e8ab77c1dc9d4c56cf4cca3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon.  <br /></td></tr>
<tr class="separator:a2e26b86c6e8ab77c1dc9d4c56cf4cca3 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab99b0b57e9ee6d2df28ca664b6ad6f01" id="r_ab99b0b57e9ee6d2df28ca664b6ad6f01"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab99b0b57e9ee6d2df28ca664b6ad6f01">Merge</a> (const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh1, const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2)</td></tr>
<tr class="memdesc:ab99b0b57e9ee6d2df28ca664b6ad6f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges mesh connectivity.  <br /></td></tr>
<tr class="separator:ab99b0b57e9ee6d2df28ca664b6ad6f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a9dafab2a2322bffd3251e9782586f" id="r_a20a9dafab2a2322bffd3251e9782586f"><td class="memItemLeft" align="right" valign="top"><a id="a20a9dafab2a2322bffd3251e9782586f" name="a20a9dafab2a2322bffd3251e9782586f"></a>
static std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Merge</b> (const std::span&lt; const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;mesh1Nodes, const std::span&lt; const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;mesh1Edges, const std::span&lt; const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;mesh2Nodes, const std::span&lt; const <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;mesh2Edges, const <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a20a9dafab2a2322bffd3251e9782586f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges mesh node and edge connectivity into a single mesh. <br /></td></tr>
<tr class="separator:a20a9dafab2a2322bffd3251e9782586f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a03dea09629645fd2274c4fdff46b7fbe"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodesEdges</b></td></tr>
<tr class="memdesc:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the indices of connected edges (nodlin) <br /></td></tr>
<tr class="separator:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a20dfcb763cb48498c07d9e177fb7d inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a35a20dfcb763cb48498c07d9e177fb7d"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodesNumEdges</b></td></tr>
<tr class="memdesc:a35a20dfcb763cb48498c07d9e177fb7d inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the number of connected edges (nmk) <br /></td></tr>
<tr class="separator:a35a20dfcb763cb48498c07d9e177fb7d inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_aa6634281d78a1ef707bc5a2376a84524"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::array&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edgesFaces</b></td></tr>
<tr class="memdesc:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the shared face index (lne) <br /></td></tr>
<tr class="separator:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569032e726ac6a9b127dcb285ddca3a7 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a569032e726ac6a9b127dcb285ddca3a7"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edgesNumFaces</b></td></tr>
<tr class="memdesc:a569032e726ac6a9b127dcb285ddca3a7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the number of shared faces(lnn) <br /></td></tr>
<tr class="separator:a569032e726ac6a9b127dcb285ddca3a7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a38b44ebfdf5d280a25d566fa5a763c78"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesNodes</b></td></tr>
<tr class="memdesc:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes composing the faces, in ccw order (netcellNod) <br /></td></tr>
<tr class="separator:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34f60c2fbe9b1f9e2a93b3a0759d6ca inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_af34f60c2fbe9b1f9e2a93b3a0759d6ca"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_numFacesNodes</b></td></tr>
<tr class="memdesc:af34f60c2fbe9b1f9e2a93b3a0759d6ca inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes composing the face (netcellN) <br /></td></tr>
<tr class="separator:af34f60c2fbe9b1f9e2a93b3a0759d6ca inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a1f33714b34fd0bcd708efc4b44f30b34"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesEdges</b></td></tr>
<tr class="memdesc:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge indices composing the face (netcelllin) <br /></td></tr>
<tr class="separator:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a79821f2e74e22834dcfce0ce0a326e2e"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_facesMassCenters</b></td></tr>
<tr class="memdesc:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces centers of mass (xzw, yzw) <br /></td></tr>
<tr class="separator:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a2b24f1ea21171bfd6f803b06a4997d56"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_faceArea</b></td></tr>
<tr class="memdesc:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face area. <br /></td></tr>
<tr class="separator:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh" id="r_a01c05988ff2a54a0ddf3082c7e4aeeb6"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_projection</b></td></tr>
<tr class="memdesc:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection used. <br /></td></tr>
<tr class="separator:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a6cefdee88e13794b67efd4fb46da9d83 inherit pro_methods_classmeshkernel_1_1_mesh" id="r_a6cefdee88e13794b67efd4fb46da9d83"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdministrationRequired</b> () const</td></tr>
<tr class="memdesc:a6cefdee88e13794b67efd4fb46da9d83 inherit pro_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a administration is required. <br /></td></tr>
<tr class="separator:a6cefdee88e13794b67efd4fb46da9d83 inherit pro_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d3b03c50a0a43cff8d2d437257758 inherit pro_methods_classmeshkernel_1_1_mesh" id="r_aad9d3b03c50a0a43cff8d2d437257758"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAdministrationRequired</b> (const bool value)</td></tr>
<tr class="memdesc:aad9d3b03c50a0a43cff8d2d437257758 inherit pro_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a administration is required. <br /></td></tr>
<tr class="separator:aad9d3b03c50a0a43cff8d2d437257758 inherit pro_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh" id="r_a130c483ec12ccfc11cddc0b1162a318e"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodes</b></td></tr>
<tr class="memdesc:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh nodes (xk, yk) <br /></td></tr>
<tr class="separator:a130c483ec12ccfc11cddc0b1162a318e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh" id="r_a84b337f739ad083ffe320366f6e9dc0e"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edges</b></td></tr>
<tr class="memdesc:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges, defined as first and second node(kn) <br /></td></tr>
<tr class="separator:a84b337f739ad083ffe320366f6e9dc0e inherit pro_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes. </p>
<p>When communicating with the client only unstructured meshes are used. Some algorithms generate curvilinear grids, but these are converted to a mesh instance when communicating with the client. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab971b113521125e64ab3218bcfdaadef" name="ab971b113521125e64ab3218bcfdaadef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab971b113521125e64ab3218bcfdaadef">&#9670;&#160;</a></span>Mesh2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a mesh2d using only the projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac667a2395d4b205d7c4be2536bc301eb" name="ac667a2395d4b205d7c4be2536bc301eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667a2395d4b205d7c4be2536bc301eb">&#9670;&#160;</a></span>Mesh2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d starting from the edges and nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a715728f7bbf687dc65a05750684b93" name="a0a715728f7bbf687dc65a05750684b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a715728f7bbf687dc65a05750684b93">&#9670;&#160;</a></span>Mesh2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d from face nodes and num face nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The mesh projection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae466a7ef61c51eb720f50d31ed94ca1" name="aae466a7ef61c51eb720f50d31ed94ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae466a7ef61c51eb720f50d31ed94ca1">&#9670;&#160;</a></span>Mesh2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create triangular grid from nodes (triangulatesamplestonetwork) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>Selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7bcb5177e39e5d5ce3b233a5942fe6c2" name="a7bcb5177e39e5d5ce3b233a5942fe6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcb5177e39e5d5ce3b233a5942fe6c2">&#9670;&#160;</a></span>Administrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::Administrate </td>
          <td>(</td>
          <td class="paramtype">CompoundUndoAction *&#160;</td>
          <td class="paramname"><em>undoAction</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform complete administration. </p>

<p>Reimplemented from <a class="el" href="classmeshkernel_1_1_mesh.html#a301daf1e7c422cf9a52ed4e42911c481">meshkernel::Mesh</a>.</p>

</div>
</div>
<a id="a636d15e559130e894343536165ea038f" name="a636d15e559130e894343536165ea038f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636d15e559130e894343536165ea038f">&#9670;&#160;</a></span>ComputeAspectRatios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeAspectRatios </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aspectRatios</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the aspect ratios (the ratios edges lengths to flow edges lengths) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aspectRatios</td><td>The aspect ratios (passed as reference to avoid re-allocation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80fe66dcf09a227009a48bc2f0480845" name="a80fe66dcf09a227009a48bc2f0480845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fe66dcf09a227009a48bc2f0480845">&#9670;&#160;</a></span>ComputeBoundaryPolygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; meshkernel::Mesh2D::ComputeBoundaryPolygons </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where the operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polygon mesh boundary </dd></dl>

</div>
</div>
<a id="a4383fa3d1ca1d1aed4405a629330f4a1" name="a4383fa3d1ca1d1aed4405a629330f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4383fa3d1ca1d1aed4405a629330f4a1">&#9670;&#160;</a></span>ComputeFaceCircumenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_point.html">Point</a> meshkernel::Mesh2D::ComputeFaceCircumenter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesNumFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a closed polygon, compute the circumcenter of a face (getcircumcenter) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygon</td><td>Cache storing the face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgesNumFaces</td><td>For meshes, the number of faces sharing the edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed circumcenter </dd></dl>

</div>
</div>
<a id="a35186078240ebfeac3c6bf9db8160cd2" name="a35186078240ebfeac3c6bf9db8160cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35186078240ebfeac3c6bf9db8160cd2">&#9670;&#160;</a></span>ComputeFaceClosedPolygonWithLocalMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygonWithLocalMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>localNodeIndicesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalEdgeIndicesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon and fill local mapping caches (get_cellpolygon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygonNodesCache</td><td>The node cache array filled with the nodes values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localNodeIndicesCache</td><td>The consecutive node index in polygonNodesCache (0, 1, 2,...) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">globalEdgeIndicesCache</td><td>The edge cache array filled with the global edge indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9aff255bad361448c527200cfe16e09" name="ab9aff255bad361448c527200cfe16e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aff255bad361448c527200cfe16e09">&#9670;&#160;</a></span>DeleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh2D::DeleteMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a>&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon, using several options (delnet) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation If this <a class="el" href="classmeshkernel_1_1_polygons.html" title="A class containing a list of polygonaly enclosed regions.">Polygons</a> instance contains multiple polygons, the first one will be taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Inverts the selected node to delete (instead of outside the polygon, inside the polygon) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2321d2206bfadce36a204e90aaab8275" name="a2321d2206bfadce36a204e90aaab8275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2321d2206bfadce36a204e90aaab8275">&#9670;&#160;</a></span>DeleteSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; meshkernel::UndoAction &gt; meshkernel::Mesh2D::DeleteSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small flow edges (removesmallflowlinks, part 1) </p>
<p>An unstructured mesh can be used to calculate water flow. This involves a pressure gradient between the circumcenters of neighbouring faces. That procedure is numerically unreliable when the distance between face circumcenters (flow edges) becomes too small. Let's consider the following figure </p><div class="image">
<object type="image/svg+xml" data="coincide_circumcenter.svg" style="pointer-events: none;"></object>
<div class="caption">
Coincide circumcenter</div></div>
<p> The algorithm works as follow:</p>
<ul>
<li>Any degenerated triangle (e.g. those having a coinciding node) is removed by collapsing the second and third node into the first one.</li>
<li><p class="startli">The edges crossing small flow edges are found. The flow edge length is computed from the face circumcenters and compared to an estimated cut off distance. The cutoff distance is computed using the face areas as follow:</p>
<p class="startli">\(\textrm{cutOffDistance} = \textrm{threshold} \cdot 0.5 \cdot (\sqrt{\textrm{Area}_I}+\sqrt{\textrm{Area}_{II}})\)</p>
</li>
<li>All small flow edges are flagged with invalid indices and removed from the mesh. Removal occors in the <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7bcb5177e39e5d5ce3b233a5942fe6c2">Mesh2D::Administrate</a> method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a76811ff4607395880ad6de6b0e9da326" name="a76811ff4607395880ad6de6b0e9da326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76811ff4607395880ad6de6b0e9da326">&#9670;&#160;</a></span>DeleteSmallTrianglesAtBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; UndoAction &gt; meshkernel::Mesh2D::DeleteSmallTrianglesAtBoundaries </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small triangles at the boundaries (removesmallflowlinks, part 2) </p>
<p>This algorithm removes triangles having the following properties:</p><ul>
<li>The are at mesh boundary.</li>
<li>One or more neighboring faces are non-triangles.</li>
<li>The ratio of the face area to the average area of neighboring non triangles is less than a minimum ratio (defaults to 0.2).</li>
<li>The absolute cosine of one internal angle is less than 0.2.</li>
</ul>
<p>These triangles having the above properties are merged by collapsing the face nodes to the node having the minimum absolute cosine (e.g. the node where the internal angle is closer to 90 degrees). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>Small triangles at the boundaries will be eliminated. This threshold is the ration of the face area to the average area of neighboring faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec6d18641ef8bbc49a66eb948b5669c8" name="aec6d18641ef8bbc49a66eb948b5669c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6d18641ef8bbc49a66eb948b5669c8">&#9670;&#160;</a></span>FilterBasedOnMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; meshkernel::Mesh2D::FilterBasedOnMetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5302769bc3f1dd3291f60b7bb62fe85c">Property</a>&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method generates a mask indicating which locations are within the specified range of the given metric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>The location representing the location where to filter the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>The property by which to filter locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minValue</td><td>The minimum value of the metric for filtering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxValue</td><td>The maximum value of the metric for filtering. @ return A vector of boolean values. Each element corresponds to a location and is <code>true</code> if the location's metric is within the specified range, and <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2b9e4b8632901a3d5774a6a4afeea4" name="a6f2b9e4b8632901a3d5774a6a4afeea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2b9e4b8632901a3d5774a6a4afeea4">&#9670;&#160;</a></span>FindCommonFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::FindCommonFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edge2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the id of the element that is common to both edges. </p>
<p>If no such element can be found then the null value will be returned. </p>

</div>
</div>
<a id="af0e240cdd3977c295abfc2e3eda5d698" name="af0e240cdd3977c295abfc2e3eda5d698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e240cdd3977c295abfc2e3eda5d698">&#9670;&#160;</a></span>FindFacesConnectedToNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindFacesConnectedToNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharedFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all faces that have the given node as a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sharedFaces</td><td>On exit will contain only indices of faces that contain nodeIndex as a node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdf9e2a9bfff9bd1d5dd57461e6dc35e" name="afdf9e2a9bfff9bd1d5dd57461e6dc35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf9e2a9bfff9bd1d5dd57461e6dc35e">&#9670;&#160;</a></span>FindFacesGivenFaceNodesMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindFacesGivenFaceNodesMapping </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find remaining face information given the face nodes mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c39d2f9df75a0c98f8d63a10f240dee" name="a4c39d2f9df75a0c98f8d63a10f240dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c39d2f9df75a0c98f8d63a10f240dee">&#9670;&#160;</a></span>FindNodesSharedByFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::FindNodesSharedByFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharedFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodeMapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all unique nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sharedFaces</td><td>List of faces that share the nodeIndex as a common node </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">connectedNodes</td><td>List of nodes that are in the patch of shared faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceNodeMapping</td><td>Mapping from node index to the position in connectedNodes list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db6fe647045d8c4fe81e44b1dcb7125" name="a4db6fe647045d8c4fe81e44b1dcb7125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db6fe647045d8c4fe81e44b1dcb7125">&#9670;&#160;</a></span>FindOppositeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::FindOppositeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find edge on the opposite side of the element. </p>
<dl class="section note"><dt>Note</dt><dd>Currently only valid of quadrilateral elements. Will throw exception <a class="el" href="classmeshkernel_1_1_not_implemented_error.html" title="A class for throwing not implemented exceptions.">NotImplementedError</a> for non-quadrilateral element shapes. </dd></dl>

</div>
</div>
<a id="add026690951b8de12423e8722f4b62b2" name="add026690951b8de12423e8722f4b62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add026690951b8de12423e8722f4b62b2">&#9670;&#160;</a></span>GetBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> meshkernel::Mesh2D::GetBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mesh bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd>The mesh bounding box </dd></dl>

</div>
</div>
<a id="ac474f70f97d938d102081b5ac387ae8f" name="ac474f70f97d938d102081b5ac387ae8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474f70f97d938d102081b5ac387ae8f">&#9670;&#160;</a></span>GetConnectingNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::GetConnectingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indices of all nodes that are connected directly to a give node along connected edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>Index of the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connectedNodes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45077997017c259c80222fd03f353107" name="a45077997017c259c80222fd03f353107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45077997017c259c80222fd03f353107">&#9670;&#160;</a></span>GetEdgesBoundingBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &gt; meshkernel::Mesh2D::GetEdgesBoundingBoxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bounding boxes of the mesh edges. </p>
<dl class="section return"><dt>Returns</dt><dd>The mesh edges bounding boxes </dd></dl>

</div>
</div>
<a id="a94db7365c9a2a241c042db6c0356e72e" name="a94db7365c9a2a241c042db6c0356e72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94db7365c9a2a241c042db6c0356e72e">&#9670;&#160;</a></span>GetEdgesCrossingSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; meshkernel::Mesh2D::GetEdgesCrossingSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges crossing the small flow edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices of the edges crossing small flow edges </dd></dl>

</div>
</div>
<a id="ab13131ed214a8cd74427989b5ecfdedb" name="ab13131ed214a8cd74427989b5ecfdedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13131ed214a8cd74427989b5ecfdedb">&#9670;&#160;</a></span>GetFlowEdgesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; meshkernel::Mesh2D::GetFlowEdgesCenters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the flow edges centers from the crossing edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The crossing edges indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The centers of the flow edges </dd></dl>

</div>
</div>
<a id="a502d0128e5203b330d2bf77f2db30a87" name="a502d0128e5203b330d2bf77f2db30a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502d0128e5203b330d2bf77f2db30a87">&#9670;&#160;</a></span>GetHangingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; meshkernel::Mesh2D::GetHangingEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hanging edges. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the indices of the hanging edges </dd></dl>

</div>
</div>
<a id="ad6aa28083ecf38015872214ecdbe09b3" name="ad6aa28083ecf38015872214ecdbe09b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6aa28083ecf38015872214ecdbe09b3">&#9670;&#160;</a></span>GetObtuseTrianglesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; meshkernel::Mesh2D::GetObtuseTrianglesCenters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mass centers of obtuse triangles. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of obtuse triangles </dd></dl>

</div>
</div>
<a id="acd7f92829aacb6bf1ecc27a1219ea304" name="acd7f92829aacb6bf1ecc27a1219ea304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7f92829aacb6bf1ecc27a1219ea304">&#9670;&#160;</a></span>IsLeftOrRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::IsLeftOrRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>elementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the element lies on the left or right side of the edge. </p>
<p>Returns 0 when the element is on the left and 1 when it is on the right. If one or other edge is not connected to the element then a null value will be returned. </p>

</div>
</div>
<a id="a6364f16211c5e72047cfbbbd70f11768" name="a6364f16211c5e72047cfbbbd70f11768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6364f16211c5e72047cfbbbd70f11768">&#9670;&#160;</a></span>IsSegmentCrossingABoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; meshkernel::Mesh2D::IsSegmentCrossingABoundaryEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>secondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire if a segment is crossing a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPoint</td><td>The first point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondPoint</td><td>The second point of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the intersectedFace face index and intersected edge index </dd></dl>

</div>
</div>
<a id="a90b1578496d5fe255e70c968ba07b410" name="a90b1578496d5fe255e70c968ba07b410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b1578496d5fe255e70c968ba07b410">&#9670;&#160;</a></span>IsStartOrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::IsStartOrEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>nodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is at the start or end of the edge. </p>
<p>Returns 0 when the node is at the start of the edge, 1 when it is at the end and the null value when the edge is not connected to the node. </p>

</div>
</div>
<a id="a5569ff6833e47a9aeef783f9cccda9f2" name="a5569ff6833e47a9aeef783f9cccda9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5569ff6833e47a9aeef783f9cccda9f2">&#9670;&#160;</a></span>MakeDualFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::MakeDualFace </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>edgeCentres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>enlargementFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dual face around the node, enlarged by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeCentres</td><td>Centre point of each of the edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enlargementFactor</td><td>The factor by which the dual face is enlarged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dualFace</td><td>The dual face to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a536bf345d626c420afdc8db64804d69e" name="a536bf345d626c420afdc8db64804d69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536bf345d626c420afdc8db64804d69e">&#9670;&#160;</a></span>MaskEdgesOfFacesInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; meshkernel::Mesh2D::MaskEdgesOfFacesInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeIntersected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the edges of all faces entirely included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertSelection</td><td>Invert selection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeIntersected</td><td>Included the edges intersected by the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge mask </dd></dl>

</div>
</div>
<a id="ab99b0b57e9ee6d2df28ca664b6ad6f01" name="ab99b0b57e9ee6d2df28ca664b6ad6f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99b0b57e9ee6d2df28ca664b6ad6f01">&#9670;&#160;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &gt; meshkernel::Mesh2D::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges mesh connectivity. </p>
<p>Only merges the mesh connectivity graphs and updates indices. </p><dl class="section note"><dt>Note</dt><dd>Does not do any administration on the node, edges or elements, it may be required to call Administrate after merging </dd></dl>

</div>
</div>
<a id="a399739726d1d913f8b23a385abe536aa" name="a399739726d1d913f8b23a385abe536aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399739726d1d913f8b23a385abe536aa">&#9670;&#160;</a></span>NextFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::NextFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next face adjacent to the edge on the opposite side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>The starting face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The starting edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of neighbour face along the edge </dd></dl>

</div>
</div>
<a id="a2069e81384498a1406d63716bd6f450b" name="a2069e81384498a1406d63716bd6f450b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2069e81384498a1406d63716bd6f450b">&#9670;&#160;</a></span>NodeMaskFromEdgeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; meshkernel::Mesh2D::NodeMaskFromEdgeMask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>edgeMask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the edge mask compute the node mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeMask</td><td>The edge mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="acabeb33421e4c1b1a2f5c4dd40e68397" name="acabeb33421e4c1b1a2f5c4dd40e68397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabeb33421e4c1b1a2f5c4dd40e68397">&#9670;&#160;</a></span>NodeMaskFromPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; meshkernel::Mesh2D::NodeMaskFromPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask all nodes included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Inside or outside option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="af2c531142aeba050555f0e3a0bbd511a" name="af2c531142aeba050555f0e3a0bbd511a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c531142aeba050555f0e3a0bbd511a">&#9670;&#160;</a></span>OffsetSphericalCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; SphericalCoordinatesOffsetAction &gt; meshkernel::Mesh2D::OffsetSphericalCoordinates </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset the x coordinates if m_projection is spherical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minx</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxx</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aee37806a7a28ea40ea0ee4fa64c514" name="a8aee37806a7a28ea40ea0ee4fa64c514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aee37806a7a28ea40ea0ee4fa64c514">&#9670;&#160;</a></span>PointFaceIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; meshkernel::Mesh2D::PointFaceIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a collection of points, compute the face indices including them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The input point vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indices including the points. </dd></dl>

</div>
</div>
<a id="a32996870084db773349d616d915d20da" name="a32996870084db773349d616d915d20da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32996870084db773349d616d915d20da">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const AddEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add edge action. </p>
<p>Restore mesh to state before edge was added </p>

</div>
</div>
<a id="ab50999836399c1abf107447009c91599" name="ab50999836399c1abf107447009c91599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50999836399c1abf107447009c91599">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const AddNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the add node action. </p>
<p>Restore mesh to state before node was added </p>

</div>
</div>
<a id="aec8c0ba1f81f51653e63d32bec74dbed" name="aec8c0ba1f81f51653e63d32bec74dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8c0ba1f81f51653e63d32bec74dbed">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const DeleteEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete edge action. </p>
<p>Restore mesh to state before edge was deleted </p>

</div>
</div>
<a id="a70f3adb13e8805d490cbe379977956a7" name="a70f3adb13e8805d490cbe379977956a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f3adb13e8805d490cbe379977956a7">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const DeleteNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the delete node action. </p>
<p>Restore mesh to state before node was deleted </p>

</div>
</div>
<a id="ad3a88228580bdf682918ad1be4232a7a" name="ad3a88228580bdf682918ad1be4232a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a88228580bdf682918ad1be4232a7a">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const ResetEdgeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset edge action. </p>
<p>Restore mesh to state before edge was reset </p>

</div>
</div>
<a id="a29eceeabde32650702348e6a275aa08a" name="a29eceeabde32650702348e6a275aa08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eceeabde32650702348e6a275aa08a">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const ResetNodeAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the reset node action. </p>
<p>Restore mesh to state before node was reset </p>

</div>
</div>
<a id="a5d1e41a70cbb395250bbc7d0d2d874a6" name="a5d1e41a70cbb395250bbc7d0d2d874a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e41a70cbb395250bbc7d0d2d874a6">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">const SphericalCoordinatesOffsetAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the coordinate offset action. </p>
<p>Restore mesh to state before coordinate offset action was applied </p>

</div>
</div>
<a id="a9aa3bf27ec07d25b0cf214d2c0ed8565" name="a9aa3bf27ec07d25b0cf214d2c0ed8565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa3bf27ec07d25b0cf214d2c0ed8565">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">FullUnstructuredGridUndo &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo entire node and edge values. </p>
<p>Restore mesh to previous state. </p>

</div>
</div>
<a id="a423dd36a747c4b9887235c3d2a372b02" name="a423dd36a747c4b9887235c3d2a372b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423dd36a747c4b9887235c3d2a372b02">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">MeshConversionAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="a9373b8e04a8a15f955a01587d09f431f" name="a9373b8e04a8a15f955a01587d09f431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9373b8e04a8a15f955a01587d09f431f">&#9670;&#160;</a></span>RestoreAction() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh::RestoreAction </td>
          <td>(</td>
          <td class="paramtype">NodeTranslationAction &amp;&#160;</td>
          <td class="paramname"><em>undoAction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the node translation action. </p>
<p>Restore mesh to state before node was translated </p>

</div>
</div>
<a id="a4eb634b77ad961d6bf07ef7c91ae1706" name="a4eb634b77ad961d6bf07ef7c91ae1706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb634b77ad961d6bf07ef7c91ae1706">&#9670;&#160;</a></span>SortedFacesAroundNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; meshkernel::Mesh2D::SortedFacesAroundNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the faces around a node, sorted in counter clock wise order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indexses </dd></dl>

</div>
</div>
<a id="a9ccf24cf23136393e36d0fd07bbbfff2" name="a9ccf24cf23136393e36d0fd07bbbfff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccf24cf23136393e36d0fd07bbbfff2">&#9670;&#160;</a></span>WalkBoundaryFromNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::WalkBoundaryFromNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>isVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshBoundaryPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a polygon from the meshboundary, by walking through the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">isVisited</td><td>the visited mesh nodes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">currentNode</td><td>the current node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshBoundaryPolygon</td><td>The resulting polygon points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
