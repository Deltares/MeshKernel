<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernelapi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">meshkernelapi Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains all structs and functions exposed at the API level.  
<a href="namespacemeshkernelapi.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct describing a bounding box.  <a href="structmeshkernelapi_1_1_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe contacts between a 1d and a 2d mesh.  <a href="structmeshkernelapi_1_1_contacts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_curvilinear_frozen_lines_add_undo_action.html">CurvilinearFrozenLinesAddUndoAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo action for adding frozen lines.  <a href="classmeshkernelapi_1_1_curvilinear_frozen_lines_add_undo_action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_curvilinear_frozen_lines_delete_undo_action.html">CurvilinearFrozenLinesDeleteUndoAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo action for deleting a frozen lines.  <a href="classmeshkernelapi_1_1_curvilinear_frozen_lines_delete_undo_action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of a curvilinear grid in a C-compatible manner.  <a href="structmeshkernelapi_1_1_curvilinear_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_edge_length_property_calculator.html">EdgeLengthPropertyCalculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculator for the edge lengths for a mesh.  <a href="classmeshkernelapi_1_1_edge_length_property_calculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe a list of geometries in a C-compatible manner.  <a href="structmeshkernelapi_1_1_geometry_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_gridded_samples.html">GriddedSamples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct describing gridded samples.  <a href="structmeshkernelapi_1_1_gridded_samples.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_interpolated_sample_property_calculator.html">InterpolatedSamplePropertyCalculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the depths at the mesh node points.  <a href="classmeshkernelapi_1_1_interpolated_sample_property_calculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of a mesh 1d in a C-compatible manner.  <a href="structmeshkernelapi_1_1_mesh1_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manner.  <a href="structmeshkernelapi_1_1_mesh2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_mesh_kernel_state.html">MeshKernelState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class holding the state of the C API library.  <a href="structmeshkernelapi_1_1_mesh_kernel_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_m_k_state_undo_action.html">MKStateUndoAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo action for <a class="el" href="structmeshkernelapi_1_1_mesh_kernel_state.html" title="The class holding the state of the C API library.">MeshKernelState</a>.  <a href="classmeshkernelapi_1_1_m_k_state_undo_action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_orthogonality_property_calculator.html">OrthogonalityPropertyCalculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculator for orthogonality of a mesh.  <a href="classmeshkernelapi_1_1_orthogonality_property_calculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_property_calculator.html">PropertyCalculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for calculating properties for a mesh.  <a href="classmeshkernelapi_1_1_property_calculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fa4028baafe51cdd5e87fe898b4a426" id="r_a0fa4028baafe51cdd5e87fe898b4a426"><td class="memItemLeft" align="right" valign="top">MKERNEL_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a> ()</td></tr>
<tr class="memdesc:a0fa4028baafe51cdd5e87fe898b4a426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the double value used in the back-end library as separator and missing value.  <br /></td></tr>
<tr class="separator:a0fa4028baafe51cdd5e87fe898b4a426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329b68c1ddf16b487d2954b65481e3c4" id="r_a329b68c1ddf16b487d2954b65481e3c4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a329b68c1ddf16b487d2954b65481e3c4">mkernel_get_inner_outer_separator</a> ()</td></tr>
<tr class="memdesc:a329b68c1ddf16b487d2954b65481e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the double value used to separate the inner part of a polygon from its outer part.  <br /></td></tr>
<tr class="separator:a329b68c1ddf16b487d2954b65481e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d3ce03b109b6aaff17396f63aac" id="r_a8e737d3ce03b109b6aaff17396f63aac"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8e737d3ce03b109b6aaff17396f63aac">mkernel_allocate_state</a> (int projectionType, int &amp;meshKernelId)</td></tr>
<tr class="memdesc:a8e737d3ce03b109b6aaff17396f63aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mesh state and returns the generated <code>meshKernelId</code>.  <br /></td></tr>
<tr class="separator:a8e737d3ce03b109b6aaff17396f63aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b7f49c043fe26218d479d986a4b61" id="r_ad49b7f49c043fe26218d479d986a4b61"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad49b7f49c043fe26218d479d986a4b61">mkernel_is_valid_state</a> (int meshKernelId, bool &amp;isValid)</td></tr>
<tr class="memdesc:ad49b7f49c043fe26218d479d986a4b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the meshKernelId is valid.  <br /></td></tr>
<tr class="separator:ad49b7f49c043fe26218d479d986a4b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca112975478ad5720cab80bd3330c7a0" id="r_aca112975478ad5720cab80bd3330c7a0"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aca112975478ad5720cab80bd3330c7a0">mkernel_set_undo_size</a> (int undoStackSize)</td></tr>
<tr class="memdesc:aca112975478ad5720cab80bd3330c7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum size of the undo stack.  <br /></td></tr>
<tr class="separator:aca112975478ad5720cab80bd3330c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e78675445f77fcf3fdfa7d2d3ea972" id="r_af1e78675445f77fcf3fdfa7d2d3ea972"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af1e78675445f77fcf3fdfa7d2d3ea972">mkernel_undo_state</a> (bool &amp;undone, int &amp;meshKernelId)</td></tr>
<tr class="memdesc:af1e78675445f77fcf3fdfa7d2d3ea972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to undo by one undo-action.  <br /></td></tr>
<tr class="separator:af1e78675445f77fcf3fdfa7d2d3ea972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef00f9a1f84dd07f80ae270d908f2b0a" id="r_aef00f9a1f84dd07f80ae270d908f2b0a"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aef00f9a1f84dd07f80ae270d908f2b0a">mkernel_undo_state_count</a> (int &amp;committedCount, int &amp;restoredCount)</td></tr>
<tr class="memdesc:aef00f9a1f84dd07f80ae270d908f2b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of undo actions.  <br /></td></tr>
<tr class="separator:aef00f9a1f84dd07f80ae270d908f2b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1984f7e35632db869ead6e5eeeabf86c" id="r_a1984f7e35632db869ead6e5eeeabf86c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1984f7e35632db869ead6e5eeeabf86c">mkernel_undo_state_count_for_id</a> (int meshKernelId, int &amp;committedCount, int &amp;restoredCount)</td></tr>
<tr class="memdesc:a1984f7e35632db869ead6e5eeeabf86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of undo actions for a particular meshKernelId.  <br /></td></tr>
<tr class="separator:a1984f7e35632db869ead6e5eeeabf86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2c4a68c9f17c7401f226b8e3f81070" id="r_a3f2c4a68c9f17c7401f226b8e3f81070"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3f2c4a68c9f17c7401f226b8e3f81070">mkernel_redo_state</a> (bool &amp;redone, int &amp;meshKernelId)</td></tr>
<tr class="memdesc:a3f2c4a68c9f17c7401f226b8e3f81070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to redo by one undo-action.  <br /></td></tr>
<tr class="separator:a3f2c4a68c9f17c7401f226b8e3f81070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635acda90d728526dbbf6b9180f9bde8" id="r_a635acda90d728526dbbf6b9180f9bde8"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a635acda90d728526dbbf6b9180f9bde8">mkernel_clear_state</a> ()</td></tr>
<tr class="memdesc:a635acda90d728526dbbf6b9180f9bde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all internal mesh kernel state and undo actions, no undo will be possible after this.  <br /></td></tr>
<tr class="separator:a635acda90d728526dbbf6b9180f9bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a35a4e10c61d1b109ae10f46939b9" id="r_a300a35a4e10c61d1b109ae10f46939b9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a300a35a4e10c61d1b109ae10f46939b9">mkernel_clear_undo_state</a> ()</td></tr>
<tr class="memdesc:a300a35a4e10c61d1b109ae10f46939b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the undo state for all mesh kernel ids, no undo is possible after this.  <br /></td></tr>
<tr class="separator:a300a35a4e10c61d1b109ae10f46939b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8f7b19c80078a6bd41e0676e3a0910" id="r_aeb8f7b19c80078a6bd41e0676e3a0910"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aeb8f7b19c80078a6bd41e0676e3a0910">mkernel_clear_undo_state_for_id</a> (int meshKernelId)</td></tr>
<tr class="memdesc:aeb8f7b19c80078a6bd41e0676e3a0910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the undo state for particular mesh kernel id, no undo for the id is possible after this.  <br /></td></tr>
<tr class="separator:aeb8f7b19c80078a6bd41e0676e3a0910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23418612b67e544a81b53b49da588b8c" id="r_a23418612b67e544a81b53b49da588b8c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a23418612b67e544a81b53b49da588b8c">mkernel_contacts_compute_boundary</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, double searchRadius)</td></tr>
<tr class="memdesc:a23418612b67e544a81b53b49da588b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll)  <br /></td></tr>
<tr class="separator:a23418612b67e544a81b53b49da588b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667f8bfc3d51f8150d1c01476b7a724" id="r_ac667f8bfc3d51f8150d1c01476b7a724"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac667f8bfc3d51f8150d1c01476b7a724">mkernel_contacts_compute_multiple</a> (int meshKernelId, const int *oneDNodeMask)</td></tr>
<tr class="memdesc:ac667f8bfc3d51f8150d1c01476b7a724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll)  <br /></td></tr>
<tr class="separator:ac667f8bfc3d51f8150d1c01476b7a724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85a128cb85ceb3ad6af908c18e9c5ee" id="r_ab85a128cb85ceb3ad6af908c18e9c5ee"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab85a128cb85ceb3ad6af908c18e9c5ee">mkernel_contacts_compute_single</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, double projectionFactor)</td></tr>
<tr class="memdesc:ab85a128cb85ceb3ad6af908c18e9c5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where each single 1d node is connected to one mesh2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll)  <br /></td></tr>
<tr class="separator:ab85a128cb85ceb3ad6af908c18e9c5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5ad63d129f4cabde4ba06a663436e5" id="r_a9b5ad63d129f4cabde4ba06a663436e5"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9b5ad63d129f4cabde4ba06a663436e5">mkernel_contacts_compute_with_points</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;points)</td></tr>
<tr class="memdesc:a9b5ad63d129f4cabde4ba06a663436e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll)  <br /></td></tr>
<tr class="separator:a9b5ad63d129f4cabde4ba06a663436e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9defc8833031f7c5d24fcbd7b0b3f17e" id="r_a9defc8833031f7c5d24fcbd7b0b3f17e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9defc8833031f7c5d24fcbd7b0b3f17e">mkernel_contacts_compute_with_polygons</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons)</td></tr>
<tr class="memdesc:a9defc8833031f7c5d24fcbd7b0b3f17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll)  <br /></td></tr>
<tr class="separator:a9defc8833031f7c5d24fcbd7b0b3f17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b3e7255f0763e4d904de90e58b510b" id="r_ac3b3e7255f0763e4d904de90e58b510b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac3b3e7255f0763e4d904de90e58b510b">mkernel_contacts_get_data</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;contacts)</td></tr>
<tr class="memdesc:ac3b3e7255f0763e4d904de90e58b510b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 1d-2d contacts indices (from index / to indices)  <br /></td></tr>
<tr class="separator:ac3b3e7255f0763e4d904de90e58b510b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f74ded5da96ab12bd145e907f6ccd9" id="r_a76f74ded5da96ab12bd145e907f6ccd9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a76f74ded5da96ab12bd145e907f6ccd9">mkernel_contacts_get_dimensions</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;contacts)</td></tr>
<tr class="memdesc:a76f74ded5da96ab12bd145e907f6ccd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of 1d-2d contacts.  <br /></td></tr>
<tr class="separator:a76f74ded5da96ab12bd145e907f6ccd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0c92956bf8370a1fb79f3d07ca711e" id="r_abf0c92956bf8370a1fb79f3d07ca711e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#abf0c92956bf8370a1fb79f3d07ca711e">mkernel_contacts_set</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;contacts)</td></tr>
<tr class="memdesc:abf0c92956bf8370a1fb79f3d07ca711e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 1d-2d contacts.  <br /></td></tr>
<tr class="separator:abf0c92956bf8370a1fb79f3d07ca711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf56f8ac784e53c26207dcc7c450b36" id="r_addf56f8ac784e53c26207dcc7c450b36"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#addf56f8ac784e53c26207dcc7c450b36">mkernel_curvilinear_compute_curvature</a> (int meshKernelId, int direction, double *curvature)</td></tr>
<tr class="memdesc:addf56f8ac784e53c26207dcc7c450b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curvature of a curvilinear grid.  <br /></td></tr>
<tr class="separator:addf56f8ac784e53c26207dcc7c450b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2656f8f1ebfbbc3d8086e17310b924" id="r_a2f2656f8f1ebfbbc3d8086e17310b924"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a2f2656f8f1ebfbbc3d8086e17310b924">mkernel_curvilinear_compute_orthogonal_grid_from_splines</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;curvilinearParameters, const <a class="el" href="structmeshkernel_1_1_splines_to_curvilinear_parameters.html">meshkernel::SplinesToCurvilinearParameters</a> &amp;splinesToCurvilinearParameters)</td></tr>
<tr class="memdesc:a2f2656f8f1ebfbbc3d8086e17310b924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates curvilinear grid from splines with the advancing front method.  <br /></td></tr>
<tr class="separator:a2f2656f8f1ebfbbc3d8086e17310b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53496b0bd662667221bdd981ccaed584" id="r_a53496b0bd662667221bdd981ccaed584"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a53496b0bd662667221bdd981ccaed584">mkernel_curvilinear_compute_grid_from_splines</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;curvilinearParameters)</td></tr>
<tr class="memdesc:a53496b0bd662667221bdd981ccaed584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates curvilinear grid from splines.  <br /></td></tr>
<tr class="separator:a53496b0bd662667221bdd981ccaed584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ac58ccc4d78dd7073399ea61e777e9" id="r_a55ac58ccc4d78dd7073399ea61e777e9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a55ac58ccc4d78dd7073399ea61e777e9">mkernel_curvilinear_compute_smoothness</a> (int meshKernelId, int direction, double *smoothness)</td></tr>
<tr class="memdesc:a55ac58ccc4d78dd7073399ea61e777e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smoothness of a curvilinear grid.  <br /></td></tr>
<tr class="separator:a55ac58ccc4d78dd7073399ea61e777e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf779508dd21bfb7f0d261af7ddffa27" id="r_acf779508dd21bfb7f0d261af7ddffa27"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acf779508dd21bfb7f0d261af7ddffa27">mkernel_curvilinear_compute_transfinite_from_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, int firstNode, int secondNode, int thirdNode, int useFourthSide)</td></tr>
<tr class="memdesc:acf779508dd21bfb7f0d261af7ddffa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a curvilinear grid in a polygon. 3 separate polygon nodes need to be selected.  <br /></td></tr>
<tr class="separator:acf779508dd21bfb7f0d261af7ddffa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3780512c9d4271e04741cc485d828" id="r_ab8c3780512c9d4271e04741cc485d828"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab8c3780512c9d4271e04741cc485d828">mkernel_curvilinear_compute_transfinite_from_splines</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;splines, const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;curvilinearParameters)</td></tr>
<tr class="memdesc:ab8c3780512c9d4271e04741cc485d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates curvilinear grid from splines with transfinite interpolation.  <br /></td></tr>
<tr class="separator:ab8c3780512c9d4271e04741cc485d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a116ed7b36b018f8f2e3de5438bb97" id="r_a96a116ed7b36b018f8f2e3de5438bb97"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a96a116ed7b36b018f8f2e3de5438bb97">mkernel_curvilinear_compute_transfinite_from_triangle</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygon, int firstNode, int secondNode, int thirdNode)</td></tr>
<tr class="memdesc:a96a116ed7b36b018f8f2e3de5438bb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a curvilinear grid in a triangle. 3 separate polygon nodes need to be selected.  <br /></td></tr>
<tr class="separator:a96a116ed7b36b018f8f2e3de5438bb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc98d41e263377e95dcd66dff42a996" id="r_a2cc98d41e263377e95dcd66dff42a996"><td class="memItemLeft" align="right" valign="top"><a id="a2cc98d41e263377e95dcd66dff42a996" name="a2cc98d41e263377e95dcd66dff42a996"></a>
MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>mkernel_curvilinear_convert_to_mesh2d</b> (int meshKernelId)</td></tr>
<tr class="memdesc:a2cc98d41e263377e95dcd66dff42a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a curvilinear grid to an unstructured mesh. <br /></td></tr>
<tr class="separator:a2cc98d41e263377e95dcd66dff42a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd10e0beda7681e4577da06e1b1dd48" id="r_a9fd10e0beda7681e4577da06e1b1dd48"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9fd10e0beda7681e4577da06e1b1dd48">mkernel_curvilinear_delete_exterior</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox)</td></tr>
<tr class="memdesc:a9fd10e0beda7681e4577da06e1b1dd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the exterior part of a curvilinear grid.  <br /></td></tr>
<tr class="separator:a9fd10e0beda7681e4577da06e1b1dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ec15d80f7c46e3b9ee0558e968516d" id="r_a96ec15d80f7c46e3b9ee0558e968516d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a96ec15d80f7c46e3b9ee0558e968516d">mkernel_curvilinear_delete_interior</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox)</td></tr>
<tr class="memdesc:a96ec15d80f7c46e3b9ee0558e968516d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the interior part of a curvilinear grid.  <br /></td></tr>
<tr class="separator:a96ec15d80f7c46e3b9ee0558e968516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828c734b99cf7e4a75065b93750e7c3" id="r_a8828c734b99cf7e4a75065b93750e7c3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8828c734b99cf7e4a75065b93750e7c3">mkernel_curvilinear_delete_node</a> (int meshKernelId, double xPointCoordinate, double yPointCoordinate)</td></tr>
<tr class="memdesc:a8828c734b99cf7e4a75065b93750e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node closest to a point.  <br /></td></tr>
<tr class="separator:a8828c734b99cf7e4a75065b93750e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4058e2207ebb8a74b5f80024a02e888" id="r_ae4058e2207ebb8a74b5f80024a02e888"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae4058e2207ebb8a74b5f80024a02e888">mkernel_curvilinear_delete_orthogonal_grid_from_splines</a> (int meshKernelId)</td></tr>
<tr class="memdesc:ae4058e2207ebb8a74b5f80024a02e888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes curvilinear grid from splines algorithm.  <br /></td></tr>
<tr class="separator:ae4058e2207ebb8a74b5f80024a02e888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2ba28c078686437dce5b9fe5a3d82" id="r_a6de2ba28c078686437dce5b9fe5a3d82"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6de2ba28c078686437dce5b9fe5a3d82">mkernel_curvilinear_derefine</a> (int meshKernelId, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner)</td></tr>
<tr class="memdesc:a6de2ba28c078686437dce5b9fe5a3d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directional curvilinear grid de-refinement. Grid lines are removed perpendicularly to the segment defined by lowerLeftCorner and xUpperRightCorner.  <br /></td></tr>
<tr class="separator:a6de2ba28c078686437dce5b9fe5a3d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc4804f0c3e0d14b9ea7e9d217081d6" id="r_a9fc4804f0c3e0d14b9ea7e9d217081d6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9fc4804f0c3e0d14b9ea7e9d217081d6">mkernel_curvilinear_finalize_line_shift</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a9fc4804f0c3e0d14b9ea7e9d217081d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the instance of the line shift algorithm in <a class="el" href="structmeshkernelapi_1_1_mesh_kernel_state.html" title="The class holding the state of the C API library.">MeshKernelState</a>.  <br /></td></tr>
<tr class="separator:a9fc4804f0c3e0d14b9ea7e9d217081d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677b6613ca808dd8bfd900532cfbe930" id="r_a677b6613ca808dd8bfd900532cfbe930"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a677b6613ca808dd8bfd900532cfbe930">mkernel_curvilinear_get_data</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;curvilinearGrid)</td></tr>
<tr class="memdesc:a677b6613ca808dd8bfd900532cfbe930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the curvilinear grid data as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes)  <br /></td></tr>
<tr class="separator:a677b6613ca808dd8bfd900532cfbe930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373ebc3a04b5c89ab016a0fc2f8d03d5" id="r_a373ebc3a04b5c89ab016a0fc2f8d03d5"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a373ebc3a04b5c89ab016a0fc2f8d03d5">mkernel_curvilinear_get_boundaries_as_polygons</a> (int meshKernelId, int lowerLeftN, int lowerLeftM, int upperRightN, int upperRightM, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;boundaryPolygons)</td></tr>
<tr class="memdesc:a373ebc3a04b5c89ab016a0fc2f8d03d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary polygon of a curvilinear grid, nodes with invalid coordinates are excluded.  <br /></td></tr>
<tr class="separator:a373ebc3a04b5c89ab016a0fc2f8d03d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ff97512d0d44db769f0d317473f5b" id="r_ae97ff97512d0d44db769f0d317473f5b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae97ff97512d0d44db769f0d317473f5b">mkernel_curvilinear_count_boundaries_as_polygons</a> (int meshKernelId, int lowerLeftN, int lowerLeftM, int upperRightN, int upperRightM, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:ae97ff97512d0d44db769f0d317473f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of nodes in curvilinear grid boundary polygons.  <br /></td></tr>
<tr class="separator:ae97ff97512d0d44db769f0d317473f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82506e242e61fa0a70d63e669a936d67" id="r_a82506e242e61fa0a70d63e669a936d67"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a82506e242e61fa0a70d63e669a936d67">mkernel_curvilinear_get_dimensions</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;curvilinearGrid)</td></tr>
<tr class="memdesc:a82506e242e61fa0a70d63e669a936d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the curvilinear grid dimensions as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes).  <br /></td></tr>
<tr class="separator:a82506e242e61fa0a70d63e669a936d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f93061a0c885e18b266968ebf45e69e" id="r_a0f93061a0c885e18b266968ebf45e69e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0f93061a0c885e18b266968ebf45e69e">mkernel_curvilinear_get_location_index</a> (int meshKernelId, double xCoordinate, double yCoordinate, int locationType, const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox, int &amp;locationIndex)</td></tr>
<tr class="memdesc:a0f93061a0c885e18b266968ebf45e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the grid location closet to a specific coordinate.  <br /></td></tr>
<tr class="separator:a0f93061a0c885e18b266968ebf45e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613dd90bec5a91a28dee0d31788401a7" id="r_a613dd90bec5a91a28dee0d31788401a7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a613dd90bec5a91a28dee0d31788401a7">mkernel_curvilinear_initialize_line_shift</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a613dd90bec5a91a28dee0d31788401a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the curvilinear line shift algorithm.  <br /></td></tr>
<tr class="separator:a613dd90bec5a91a28dee0d31788401a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cfc55175164aeeca32ef07b17fc1a5" id="r_a19cfc55175164aeeca32ef07b17fc1a5"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a19cfc55175164aeeca32ef07b17fc1a5">mkernel_curvilinear_initialize_orthogonal_grid_from_splines</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;curvilinearParameters, const <a class="el" href="structmeshkernel_1_1_splines_to_curvilinear_parameters.html">meshkernel::SplinesToCurvilinearParameters</a> &amp;splinesToCurvilinearParameters)</td></tr>
<tr class="memdesc:a19cfc55175164aeeca32ef07b17fc1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a curvilinear grid from splines with the advancing front method. Initialization step (interactive)  <br /></td></tr>
<tr class="separator:a19cfc55175164aeeca32ef07b17fc1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd685105dd6d04a35ddad5e013cdef4" id="r_a1cd685105dd6d04a35ddad5e013cdef4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1cd685105dd6d04a35ddad5e013cdef4">mkernel_curvilinear_insert_face</a> (int meshKernelId, double xCoordinate, double yCoordinate)</td></tr>
<tr class="memdesc:a1cd685105dd6d04a35ddad5e013cdef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new face on a curvilinear grid. The new face will be inserted on top of the closest edge by linear extrapolation.  <br /></td></tr>
<tr class="separator:a1cd685105dd6d04a35ddad5e013cdef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c46ebeb6dd10a6080eec66360eab373" id="r_a8c46ebeb6dd10a6080eec66360eab373"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8c46ebeb6dd10a6080eec66360eab373">mkernel_curvilinear_iterate_orthogonal_grid_from_splines</a> (int meshKernelId, int layer)</td></tr>
<tr class="memdesc:a8c46ebeb6dd10a6080eec66360eab373"><td class="mdescLeft">&#160;</td><td class="mdescRight">One advancement of the front in curvilinear grid from splines (interactive)  <br /></td></tr>
<tr class="separator:a8c46ebeb6dd10a6080eec66360eab373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5727bee8dd3366d7915e3f80c684e518" id="r_a5727bee8dd3366d7915e3f80c684e518"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a5727bee8dd3366d7915e3f80c684e518">mkernel_curvilinear_line_attraction_repulsion</a> (int meshKernelId, double repulsionParameter, double xFirstNodeOnTheLine, double yFirstNodeOnTheLine, double xSecondNodeOnTheLine, double ySecondNodeOnTheLine, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner)</td></tr>
<tr class="memdesc:a5727bee8dd3366d7915e3f80c684e518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attracts/repulses grid lines in a block towards another set grid line.  <br /></td></tr>
<tr class="separator:a5727bee8dd3366d7915e3f80c684e518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a4a01c4325f46d98254fbf6ccbc32" id="r_aa55a4a01c4325f46d98254fbf6ccbc32"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa55a4a01c4325f46d98254fbf6ccbc32">mkernel_curvilinear_line_mirror</a> (int meshKernelId, double mirroringFactor, double xFirstGridLineNode, double yFirstGridLineNode, double xSecondGridLineNode, double ySecondGridLineNode)</td></tr>
<tr class="memdesc:aa55a4a01c4325f46d98254fbf6ccbc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirrors a boundary gridline outwards. The boundary grid line is defined by its starting and ending points.  <br /></td></tr>
<tr class="separator:aa55a4a01c4325f46d98254fbf6ccbc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cf4944145f3981e711822151ffdeac" id="r_ad4cf4944145f3981e711822151ffdeac"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad4cf4944145f3981e711822151ffdeac">mkernel_curvilinear_line_shift</a> (int meshKernelId)</td></tr>
<tr class="memdesc:ad4cf4944145f3981e711822151ffdeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the new grid, shifting the line towards the moved nodes and distributing the shifting in block specified before.  <br /></td></tr>
<tr class="separator:ad4cf4944145f3981e711822151ffdeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512f0ec6c1a77978a75c91515723427" id="r_aa512f0ec6c1a77978a75c91515723427"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa512f0ec6c1a77978a75c91515723427">mkernel_curvilinear_compute_rectangular_grid</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters)</td></tr>
<tr class="memdesc:aa512f0ec6c1a77978a75c91515723427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a rectangular curvilinear grid.  <br /></td></tr>
<tr class="separator:aa512f0ec6c1a77978a75c91515723427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aa51060e729e70bc0a309d70c83188" id="r_a65aa51060e729e70bc0a309d70c83188"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a65aa51060e729e70bc0a309d70c83188">mkernel_curvilinear_compute_rectangular_grid_from_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:a65aa51060e729e70bc0a309d70c83188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a rectangular curvilinear grid from polygon.  <br /></td></tr>
<tr class="separator:a65aa51060e729e70bc0a309d70c83188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caa5ca4316f35e6fe4c5757f8a75589" id="r_a2caa5ca4316f35e6fe4c5757f8a75589"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a2caa5ca4316f35e6fe4c5757f8a75589">mkernel_curvilinear_compute_rectangular_grid_on_extension</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters)</td></tr>
<tr class="memdesc:a2caa5ca4316f35e6fe4c5757f8a75589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a rectangular curvilinear grid on a defined extension.  <br /></td></tr>
<tr class="separator:a2caa5ca4316f35e6fe4c5757f8a75589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1489f182a98483291e002a463576f108" id="r_a1489f182a98483291e002a463576f108"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1489f182a98483291e002a463576f108">mkernel_curvilinear_compute_circular_grid</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a1489f182a98483291e002a463576f108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rectangular or circular curvilinear grid.  <br /></td></tr>
<tr class="separator:a1489f182a98483291e002a463576f108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538a45d6469d77c2c1dc925a9fcb446" id="r_ab538a45d6469d77c2c1dc925a9fcb446"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab538a45d6469d77c2c1dc925a9fcb446">mkernel_curvilinear_move_node</a> (int meshKernelId, double xFromPoint, double yFromPoint, double xToPoint, double yToPoint)</td></tr>
<tr class="memdesc:ab538a45d6469d77c2c1dc925a9fcb446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a point of a curvilinear grid from one location to another.  <br /></td></tr>
<tr class="separator:ab538a45d6469d77c2c1dc925a9fcb446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dadaf06c429d8c30f962d672b72c1bb" id="r_a6dadaf06c429d8c30f962d672b72c1bb"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6dadaf06c429d8c30f962d672b72c1bb">mkernel_curvilinear_move_node_line_shift</a> (int meshKernelId, double xFromCoordinate, double yFromCoordinate, double xToCoordinate, double yToCoordinate)</td></tr>
<tr class="memdesc:a6dadaf06c429d8c30f962d672b72c1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a node of the line to shift, the operation can be performed multiple times.  <br /></td></tr>
<tr class="separator:a6dadaf06c429d8c30f962d672b72c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958ee3292784ee27c9d4c09adb0e2fb4" id="r_a958ee3292784ee27c9d4c09adb0e2fb4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a958ee3292784ee27c9d4c09adb0e2fb4">mkernel_curvilinear_refine</a> (int meshKernelId, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner, int refinement)</td></tr>
<tr class="memdesc:a958ee3292784ee27c9d4c09adb0e2fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directional curvilinear grid refinement. Additional gridlines are added perpendicularly to the segment defined by lowerLeftCorner and xUpperRightCorner.  <br /></td></tr>
<tr class="separator:a958ee3292784ee27c9d4c09adb0e2fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5018cc5b18f40820c127929506cdfab" id="r_ac5018cc5b18f40820c127929506cdfab"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac5018cc5b18f40820c127929506cdfab">mkernel_curvilinear_refresh_orthogonal_grid_from_splines</a> (int meshKernelId)</td></tr>
<tr class="memdesc:ac5018cc5b18f40820c127929506cdfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts curvilinear grid to mesh and refreshes the state (interactive)  <br /></td></tr>
<tr class="separator:ac5018cc5b18f40820c127929506cdfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d08c9fd622e708b148018b333a084" id="r_aff8d08c9fd622e708b148018b333a084"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aff8d08c9fd622e708b148018b333a084">mkernel_curvilinear_full_refine</a> (int meshKernelId, int mRefinement, int nRefinement)</td></tr>
<tr class="memdesc:aff8d08c9fd622e708b148018b333a084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curvilinear grid refinement. Additional gridlines are added in both directions, over the entire grid.  <br /></td></tr>
<tr class="separator:aff8d08c9fd622e708b148018b333a084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19debeee68b71cf42a0ee4405b72c835" id="r_a19debeee68b71cf42a0ee4405b72c835"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a19debeee68b71cf42a0ee4405b72c835">mkernel_curvilinear_orthogonalize</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;orthogonalizationParameters, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner)</td></tr>
<tr class="memdesc:a19debeee68b71cf42a0ee4405b72c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a block on the curvilinear grid where to perform orthogonalization.  <br /></td></tr>
<tr class="separator:a19debeee68b71cf42a0ee4405b72c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2242c66cb341c465f9f9a38e9379d9" id="r_acf2242c66cb341c465f9f9a38e9379d9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acf2242c66cb341c465f9f9a38e9379d9">mkernel_curvilinear_set</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:acf2242c66cb341c465f9f9a38e9379d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the curvilinear grid.  <br /></td></tr>
<tr class="separator:acf2242c66cb341c465f9f9a38e9379d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc5a4f9bf16b91caf138adaf2265040" id="r_a9bc5a4f9bf16b91caf138adaf2265040"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9bc5a4f9bf16b91caf138adaf2265040">mkernel_curvilinear_set_block_line_shift</a> (int meshKernelId, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner)</td></tr>
<tr class="memdesc:a9bc5a4f9bf16b91caf138adaf2265040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a block on the curvilinear where the shifting is distributed.  <br /></td></tr>
<tr class="separator:a9bc5a4f9bf16b91caf138adaf2265040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c77901337c6337a9854028135cc0ad" id="r_aa7c77901337c6337a9854028135cc0ad"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa7c77901337c6337a9854028135cc0ad">mkernel_curvilinear_frozen_line_is_valid</a> (int meshKernelId, int frozenLineId, bool &amp;isValid)</td></tr>
<tr class="memdesc:aa7c77901337c6337a9854028135cc0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a curvilinear frozen line is valid.  <br /></td></tr>
<tr class="separator:aa7c77901337c6337a9854028135cc0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d69fa7859cf8db64e927ee80c05d80" id="r_ad4d69fa7859cf8db64e927ee80c05d80"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad4d69fa7859cf8db64e927ee80c05d80">mkernel_curvilinear_frozen_line_delete</a> (int meshKernelId, int frozenLineId)</td></tr>
<tr class="memdesc:ad4d69fa7859cf8db64e927ee80c05d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an existing frozen line in the meshkernel state.  <br /></td></tr>
<tr class="separator:ad4d69fa7859cf8db64e927ee80c05d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddb979ccad2937a9a0f7793992f1bec" id="r_a2ddb979ccad2937a9a0f7793992f1bec"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a2ddb979ccad2937a9a0f7793992f1bec">mkernel_curvilinear_frozen_line_add</a> (int meshKernelId, double xFirstGridLineNode, double yFirstGridLineNode, double xSecondGridLineNode, double ySecondGridLineNode, int &amp;frozenLineId)</td></tr>
<tr class="memdesc:a2ddb979ccad2937a9a0f7793992f1bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new frozen line in the meshkernel state.  <br /></td></tr>
<tr class="separator:a2ddb979ccad2937a9a0f7793992f1bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2617d6cdc2cbf622be13e30d4fdc7f1" id="r_ae2617d6cdc2cbf622be13e30d4fdc7f1"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae2617d6cdc2cbf622be13e30d4fdc7f1">mkernel_curvilinear_frozen_line_get</a> (int meshKernelId, int frozenLineId, double &amp;xFirstFrozenLineCoordinate, double &amp;yFirstFrozenLineCoordinate, double &amp;xSecondFrozenLineCoordinate, double &amp;ySecondFrozenLineCoordinate)</td></tr>
<tr class="memdesc:ae2617d6cdc2cbf622be13e30d4fdc7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new frozen line in the meshkernel state.  <br /></td></tr>
<tr class="separator:ae2617d6cdc2cbf622be13e30d4fdc7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91be30c89a92e5849844512d7fe13bf" id="r_ad91be30c89a92e5849844512d7fe13bf"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad91be30c89a92e5849844512d7fe13bf">mkernel_curvilinear_frozen_lines_get_count</a> (int meshKernelId, int &amp;numFrozenLines)</td></tr>
<tr class="memdesc:ad91be30c89a92e5849844512d7fe13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of stored frozen lines in the meshkernel state.  <br /></td></tr>
<tr class="separator:ad91be30c89a92e5849844512d7fe13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef3cd4e875b3dd013795c13805d11dd" id="r_abef3cd4e875b3dd013795c13805d11dd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#abef3cd4e875b3dd013795c13805d11dd">mkernel_curvilinear_frozen_lines_get_ids</a> (int meshKernelId, int *frozenLinesIds)</td></tr>
<tr class="memdesc:abef3cd4e875b3dd013795c13805d11dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ids of the frozen lines.  <br /></td></tr>
<tr class="separator:abef3cd4e875b3dd013795c13805d11dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7dc0445883bf597840da83c47babc1" id="r_a4a7dc0445883bf597840da83c47babc1"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4a7dc0445883bf597840da83c47babc1">mkernel_curvilinear_set_line_line_shift</a> (int meshKernelId, double xFirstGridLineNode, double yFirstGridLineNode, double xSecondGridLineNode, double ySecondGridLineNode)</td></tr>
<tr class="memdesc:a4a7dc0445883bf597840da83c47babc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the start and end nodes of the line to shift.  <br /></td></tr>
<tr class="separator:a4a7dc0445883bf597840da83c47babc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc299ba69473ad8e3e16edd7b79ec196" id="r_afc299ba69473ad8e3e16edd7b79ec196"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#afc299ba69473ad8e3e16edd7b79ec196">mkernel_curvilinear_smoothing</a> (int meshKernelId, int smoothingIterations, double xLowerLeftCorner, double yLowerLeftCorner, double xUpperRightCorner, double yUpperRightCorner)</td></tr>
<tr class="memdesc:afc299ba69473ad8e3e16edd7b79ec196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths a curvilinear grid.  <br /></td></tr>
<tr class="separator:afc299ba69473ad8e3e16edd7b79ec196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19958bebc2ca018eca5e3da034deb0c" id="r_ad19958bebc2ca018eca5e3da034deb0c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad19958bebc2ca018eca5e3da034deb0c">mkernel_curvilinear_smoothing_directional</a> (int meshKernelId, int smoothingIterations, double xFirstGridlineNode, double yFirstGridlineNode, double xSecondGridLineNode, double ySecondGridLineNode, double xLowerLeftCornerSmoothingArea, double yLowerLeftCornerSmoothingArea, double xUpperRightCornerSmootingArea, double yUpperRightCornerSmootingArea)</td></tr>
<tr class="memdesc:ad19958bebc2ca018eca5e3da034deb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths a curvilinear grid along the direction specified by a segment.  <br /></td></tr>
<tr class="separator:ad19958bebc2ca018eca5e3da034deb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91770126953a7fe176cce86c51aba5c7" id="r_a91770126953a7fe176cce86c51aba5c7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a91770126953a7fe176cce86c51aba5c7">mkernel_curvilinear_snap_to_landboundary</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;land, double sectionControlPoint1x, double sectionControlPoint1y, double sectionControlPoint2x, double sectionControlPoint2y, double regionControlPointX=<a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>(), double regionControlPointY=<a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>())</td></tr>
<tr class="memdesc:a91770126953a7fe176cce86c51aba5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the curvilinear grid.  <br /></td></tr>
<tr class="separator:a91770126953a7fe176cce86c51aba5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41794e15c663467d71e75c78fa30dd26" id="r_a41794e15c663467d71e75c78fa30dd26"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a41794e15c663467d71e75c78fa30dd26">mkernel_curvilinear_snap_to_spline</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;spline, double sectionControlPoint1x, double sectionControlPoint1y, double sectionControlPoint2x, double sectionControlPoint2y, double regionControlPointX=<a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>(), double regionControlPointY=<a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>())</td></tr>
<tr class="memdesc:a41794e15c663467d71e75c78fa30dd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the curvilinear grid.  <br /></td></tr>
<tr class="separator:a41794e15c663467d71e75c78fa30dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54655bc724e99cb7447d35743525f12a" id="r_a54655bc724e99cb7447d35743525f12a"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a54655bc724e99cb7447d35743525f12a">mkernel_deallocate_property</a> (int propertyId)</td></tr>
<tr class="memdesc:a54655bc724e99cb7447d35743525f12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate property calculator.  <br /></td></tr>
<tr class="separator:a54655bc724e99cb7447d35743525f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d1b16ba8121e1f11b1692b755647c3" id="r_a57d1b16ba8121e1f11b1692b755647c3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a57d1b16ba8121e1f11b1692b755647c3">mkernel_deallocate_state</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a57d1b16ba8121e1f11b1692b755647c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate mesh state.  <br /></td></tr>
<tr class="separator:a57d1b16ba8121e1f11b1692b755647c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e91a7f466943f63bea081be84e2eab" id="r_a01e91a7f466943f63bea081be84e2eab"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a01e91a7f466943f63bea081be84e2eab">mkernel_expunge_state</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a01e91a7f466943f63bea081be84e2eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate mesh state and remove it completely, no undo for this meshKernelId will be possible after expunging.  <br /></td></tr>
<tr class="separator:a01e91a7f466943f63bea081be84e2eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c310189351a979c7f2b170802e5fa3" id="r_a61c310189351a979c7f2b170802e5fa3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a61c310189351a979c7f2b170802e5fa3">mkernel_get_averaging_method_closest_point</a> (int &amp;method)</td></tr>
<tr class="memdesc:a61c310189351a979c7f2b170802e5fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the closest point averaging method type.  <br /></td></tr>
<tr class="separator:a61c310189351a979c7f2b170802e5fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c993627e89f487a8ebf84882689c530" id="r_a5c993627e89f487a8ebf84882689c530"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a5c993627e89f487a8ebf84882689c530">mkernel_get_averaging_method_inverse_distance_weighting</a> (int &amp;method)</td></tr>
<tr class="memdesc:a5c993627e89f487a8ebf84882689c530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the inverse distance weights averaging method type.  <br /></td></tr>
<tr class="separator:a5c993627e89f487a8ebf84882689c530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd755a42334c133d093230297814729" id="r_aebd755a42334c133d093230297814729"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aebd755a42334c133d093230297814729">mkernel_get_averaging_method_max</a> (int &amp;method)</td></tr>
<tr class="memdesc:aebd755a42334c133d093230297814729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the max value averaging method type.  <br /></td></tr>
<tr class="separator:aebd755a42334c133d093230297814729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb82e72f98299ebb56b5c9dd3402dc7" id="r_a9fb82e72f98299ebb56b5c9dd3402dc7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9fb82e72f98299ebb56b5c9dd3402dc7">mkernel_get_averaging_method_min</a> (int &amp;method)</td></tr>
<tr class="memdesc:a9fb82e72f98299ebb56b5c9dd3402dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the minimum averaging method type.  <br /></td></tr>
<tr class="separator:a9fb82e72f98299ebb56b5c9dd3402dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c609b8166a7bb1f1eefc8e70895e201" id="r_a0c609b8166a7bb1f1eefc8e70895e201"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0c609b8166a7bb1f1eefc8e70895e201">mkernel_get_averaging_method_min_absolute_value</a> (int &amp;method)</td></tr>
<tr class="memdesc:a0c609b8166a7bb1f1eefc8e70895e201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the minimum absolute value averaging method type.  <br /></td></tr>
<tr class="separator:a0c609b8166a7bb1f1eefc8e70895e201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49825ed2de2cecdd6d38e0eb5d87620" id="r_ac49825ed2de2cecdd6d38e0eb5d87620"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac49825ed2de2cecdd6d38e0eb5d87620">mkernel_get_averaging_method_simple_averaging</a> (int &amp;method)</td></tr>
<tr class="memdesc:ac49825ed2de2cecdd6d38e0eb5d87620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the simple averaging method type.  <br /></td></tr>
<tr class="separator:ac49825ed2de2cecdd6d38e0eb5d87620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81c2fed7f95e682ce599388d92c90f3" id="r_ae81c2fed7f95e682ce599388d92c90f3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae81c2fed7f95e682ce599388d92c90f3">mkernel_get_edges_location_type</a> (int &amp;type)</td></tr>
<tr class="memdesc:ae81c2fed7f95e682ce599388d92c90f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the edge location type.  <br /></td></tr>
<tr class="separator:ae81c2fed7f95e682ce599388d92c90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3865787c434f2912debb2a89ecd01b" id="r_afd3865787c434f2912debb2a89ecd01b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#afd3865787c434f2912debb2a89ecd01b">mkernel_get_error</a> (char *errorMessage)</td></tr>
<tr class="memdesc:afd3865787c434f2912debb2a89ecd01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to error message.  <br /></td></tr>
<tr class="separator:afd3865787c434f2912debb2a89ecd01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf3b994bcbc9a005829b0630e50cec3" id="r_adaf3b994bcbc9a005829b0630e50cec3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#adaf3b994bcbc9a005829b0630e50cec3">mkernel_get_exit_code_success</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:adaf3b994bcbc9a005829b0630e50cec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the success exit code.  <br /></td></tr>
<tr class="separator:adaf3b994bcbc9a005829b0630e50cec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade49c422f668c8bdc3cf3f1b0d87bb3d" id="r_ade49c422f668c8bdc3cf3f1b0d87bb3d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ade49c422f668c8bdc3cf3f1b0d87bb3d">mkernel_get_exit_code_meshkernel_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:ade49c422f668c8bdc3cf3f1b0d87bb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type MeshKernelError.  <br /></td></tr>
<tr class="separator:ade49c422f668c8bdc3cf3f1b0d87bb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b55f1ae4b2476952a411371a317e66" id="r_ad3b55f1ae4b2476952a411371a317e66"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad3b55f1ae4b2476952a411371a317e66">mkernel_get_exit_code_not_implemented_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:ad3b55f1ae4b2476952a411371a317e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type NotImplementedCode.  <br /></td></tr>
<tr class="separator:ad3b55f1ae4b2476952a411371a317e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfd7f5c68ec2bd2d1211ef3701609a4" id="r_a6cfd7f5c68ec2bd2d1211ef3701609a4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6cfd7f5c68ec2bd2d1211ef3701609a4">mkernel_get_exit_code_algorithm_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:a6cfd7f5c68ec2bd2d1211ef3701609a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type AlgorithmexitCode.  <br /></td></tr>
<tr class="separator:a6cfd7f5c68ec2bd2d1211ef3701609a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79705a28cb51da36e8f3261ffb10b7a2" id="r_a79705a28cb51da36e8f3261ffb10b7a2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a79705a28cb51da36e8f3261ffb10b7a2">mkernel_get_exit_code_constraint_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:a79705a28cb51da36e8f3261ffb10b7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type ConstraintexitCode.  <br /></td></tr>
<tr class="separator:a79705a28cb51da36e8f3261ffb10b7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b752932fccfe496950396dc9a12e14c" id="r_a3b752932fccfe496950396dc9a12e14c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3b752932fccfe496950396dc9a12e14c">mkernel_get_exit_code_mesh_geometry_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:a3b752932fccfe496950396dc9a12e14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type MeshGeometryexitCode.  <br /></td></tr>
<tr class="separator:a3b752932fccfe496950396dc9a12e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d25d4fe41dcd38ac065e09eef03bbf" id="r_ad9d25d4fe41dcd38ac065e09eef03bbf"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad9d25d4fe41dcd38ac065e09eef03bbf">mkernel_get_exit_code_linear_algebra_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:ad9d25d4fe41dcd38ac065e09eef03bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type LinearAlgebraexitCode.  <br /></td></tr>
<tr class="separator:ad9d25d4fe41dcd38ac065e09eef03bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c81a4213151e86019c6fd1fd7b6dee" id="r_a87c81a4213151e86019c6fd1fd7b6dee"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a87c81a4213151e86019c6fd1fd7b6dee">mkernel_get_exit_code_range_error</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:a87c81a4213151e86019c6fd1fd7b6dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type RangeexitCode.  <br /></td></tr>
<tr class="separator:a87c81a4213151e86019c6fd1fd7b6dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2feb0a374dffb49ee3933710771753" id="r_a4c2feb0a374dffb49ee3933710771753"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4c2feb0a374dffb49ee3933710771753">mkernel_get_exit_code_stdlib_exception</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:a4c2feb0a374dffb49ee3933710771753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of type std::exception.  <br /></td></tr>
<tr class="separator:a4c2feb0a374dffb49ee3933710771753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37d92deca9c48ad10b8f3c1b055486" id="r_afb37d92deca9c48ad10b8f3c1b055486"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#afb37d92deca9c48ad10b8f3c1b055486">mkernel_get_exit_code_unknown_exception</a> (int &amp;exitCode)</td></tr>
<tr class="memdesc:afb37d92deca9c48ad10b8f3c1b055486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the exit code of an exception of unknown type.  <br /></td></tr>
<tr class="separator:afb37d92deca9c48ad10b8f3c1b055486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54964b1b218346c7bc7830ebec339b7" id="r_ab54964b1b218346c7bc7830ebec339b7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab54964b1b218346c7bc7830ebec339b7">mkernel_get_faces_location_type</a> (int &amp;type)</td></tr>
<tr class="memdesc:ab54964b1b218346c7bc7830ebec339b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the faces location type.  <br /></td></tr>
<tr class="separator:ab54964b1b218346c7bc7830ebec339b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60110d717bc03445222a06bc765ef4f4" id="r_a60110d717bc03445222a06bc765ef4f4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a60110d717bc03445222a06bc765ef4f4">mkernel_get_geometry_error</a> (int &amp;invalidIndex, int &amp;type)</td></tr>
<tr class="memdesc:a60110d717bc03445222a06bc765ef4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the erroneous entity.  <br /></td></tr>
<tr class="separator:a60110d717bc03445222a06bc765ef4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acc9b103eee667d7c83b375be9d664d" id="r_a0acc9b103eee667d7c83b375be9d664d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0acc9b103eee667d7c83b375be9d664d">mkernel_get_interpolation_type_short</a> (int &amp;type)</td></tr>
<tr class="memdesc:a0acc9b103eee667d7c83b375be9d664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer indicating the interpolation type short.  <br /></td></tr>
<tr class="separator:a0acc9b103eee667d7c83b375be9d664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bcbba1436c83eb69275f056bb9504c" id="r_a34bcbba1436c83eb69275f056bb9504c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a34bcbba1436c83eb69275f056bb9504c">mkernel_get_interpolation_type_float</a> (int &amp;type)</td></tr>
<tr class="memdesc:a34bcbba1436c83eb69275f056bb9504c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer indicating the interpolation type float.  <br /></td></tr>
<tr class="separator:a34bcbba1436c83eb69275f056bb9504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542a9206d51414d3992b17e29a6d220" id="r_a7542a9206d51414d3992b17e29a6d220"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a7542a9206d51414d3992b17e29a6d220">mkernel_get_interpolation_type_int</a> (int &amp;type)</td></tr>
<tr class="memdesc:a7542a9206d51414d3992b17e29a6d220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer indicating the interpolation type int.  <br /></td></tr>
<tr class="separator:a7542a9206d51414d3992b17e29a6d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230ee8561e4626c030364b4c246b8b8" id="r_a9230ee8561e4626c030364b4c246b8b8"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9230ee8561e4626c030364b4c246b8b8">mkernel_get_interpolation_type_double</a> (int &amp;type)</td></tr>
<tr class="memdesc:a9230ee8561e4626c030364b4c246b8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer indicating the interpolation type double.  <br /></td></tr>
<tr class="separator:a9230ee8561e4626c030364b4c246b8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fc6f05ef419a0e88293a93e6c9f266" id="r_a78fc6f05ef419a0e88293a93e6c9f266"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a78fc6f05ef419a0e88293a93e6c9f266">mkernel_get_nodes_location_type</a> (int &amp;type)</td></tr>
<tr class="memdesc:a78fc6f05ef419a0e88293a93e6c9f266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the node location type.  <br /></td></tr>
<tr class="separator:a78fc6f05ef419a0e88293a93e6c9f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a3ee15c254830a4cbbc717f679c595" id="r_ae6a3ee15c254830a4cbbc717f679c595"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae6a3ee15c254830a4cbbc717f679c595">mkernel_get_projection</a> (int meshKernelId, int &amp;projection)</td></tr>
<tr class="memdesc:ae6a3ee15c254830a4cbbc717f679c595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coordinate projection of the meshkernel state.  <br /></td></tr>
<tr class="separator:ae6a3ee15c254830a4cbbc717f679c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b5723e697138e4f4c0cd89fd7c7016" id="r_a24b5723e697138e4f4c0cd89fd7c7016"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a24b5723e697138e4f4c0cd89fd7c7016">mkernel_get_projection_cartesian</a> (int &amp;projection)</td></tr>
<tr class="memdesc:a24b5723e697138e4f4c0cd89fd7c7016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the cartesian projection.  <br /></td></tr>
<tr class="separator:a24b5723e697138e4f4c0cd89fd7c7016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f8539ad3c24315bb99e9f8a9605276" id="r_a80f8539ad3c24315bb99e9f8a9605276"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a80f8539ad3c24315bb99e9f8a9605276">mkernel_get_projection_spherical</a> (int &amp;projection)</td></tr>
<tr class="memdesc:a80f8539ad3c24315bb99e9f8a9605276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the spherical projection.  <br /></td></tr>
<tr class="separator:a80f8539ad3c24315bb99e9f8a9605276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a895fc8ca2c9520a0604deffe4692c" id="r_a48a895fc8ca2c9520a0604deffe4692c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a48a895fc8ca2c9520a0604deffe4692c">mkernel_get_projection_spherical_accurate</a> (int &amp;projection)</td></tr>
<tr class="memdesc:a48a895fc8ca2c9520a0604deffe4692c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the spherical accurate projection.  <br /></td></tr>
<tr class="separator:a48a895fc8ca2c9520a0604deffe4692c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d47258f24cf6884bb39bf648356e08" id="r_a11d47258f24cf6884bb39bf648356e08"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a11d47258f24cf6884bb39bf648356e08">mkernel_get_splines</a> (const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListOut, int numberOfPointsBetweenNodes)</td></tr>
<tr class="memdesc:a11d47258f24cf6884bb39bf648356e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the computed spline points between two corner nodes.  <br /></td></tr>
<tr class="separator:a11d47258f24cf6884bb39bf648356e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4271f39ab44e85f1fdefb8c25b9841" id="r_a4a4271f39ab44e85f1fdefb8c25b9841"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4a4271f39ab44e85f1fdefb8c25b9841">mkernel_get_version</a> (char *version)</td></tr>
<tr class="memdesc:a4a4271f39ab44e85f1fdefb8c25b9841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to version string.  <br /></td></tr>
<tr class="separator:a4a4271f39ab44e85f1fdefb8c25b9841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b222ed081c13ed360c0e04f70b589d6" id="r_a1b222ed081c13ed360c0e04f70b589d6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1b222ed081c13ed360c0e04f70b589d6">mkernel_mesh1d_get_data</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:a1b222ed081c13ed360c0e04f70b589d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data.  <br /></td></tr>
<tr class="separator:a1b222ed081c13ed360c0e04f70b589d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79454e20b730506c295f9e837b071c4d" id="r_a79454e20b730506c295f9e837b071c4d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a79454e20b730506c295f9e837b071c4d">mkernel_mesh1d_get_dimensions</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:a79454e20b730506c295f9e837b071c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data dimensions.  <br /></td></tr>
<tr class="separator:a79454e20b730506c295f9e837b071c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa162a77f3bcde424aa5c900b17b6cd06" id="r_aa162a77f3bcde424aa5c900b17b6cd06"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa162a77f3bcde424aa5c900b17b6cd06">mkernel_mesh1d_set</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:aa162a77f3bcde424aa5c900b17b6cd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state.  <br /></td></tr>
<tr class="separator:aa162a77f3bcde424aa5c900b17b6cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc29909e7d7b91c74f3a7218d863bf85" id="r_acc29909e7d7b91c74f3a7218d863bf85"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acc29909e7d7b91c74f3a7218d863bf85">mkernel_mesh1d_add</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:acc29909e7d7b91c74f3a7218d863bf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a mesh to the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state.  <br /></td></tr>
<tr class="separator:acc29909e7d7b91c74f3a7218d863bf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc35c8a835d5b362e8782ddc3197349" id="r_a1dc35c8a835d5b362e8782ddc3197349"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1dc35c8a835d5b362e8782ddc3197349">mkernel_mesh2d_averaging_interpolation</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;samples, int locationType, int averagingMethodType, double relativeSearchSize, size_t minNumSamples, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;results)</td></tr>
<tr class="memdesc:a1dc35c8a835d5b362e8782ddc3197349"><td class="mdescLeft">&#160;</td><td class="mdescRight">AveragingInterpolation interpolation (ec_module)  <br /></td></tr>
<tr class="separator:a1dc35c8a835d5b362e8782ddc3197349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa390097481a2f81487f41c5e46eaaaf6" id="r_aa390097481a2f81487f41c5e46eaaaf6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa390097481a2f81487f41c5e46eaaaf6">mkernel_mesh2d_compute_inner_ortogonalization_iteration</a> (int meshKernelId)</td></tr>
<tr class="memdesc:aa390097481a2f81487f41c5e46eaaaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inner orthogonalization iteration, by slowly moving the mesh nodes to new optimal positions (interactive mode).  <br /></td></tr>
<tr class="separator:aa390097481a2f81487f41c5e46eaaaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a3589ccdc1570cb64308aef54deb7d" id="r_a91a3589ccdc1570cb64308aef54deb7d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a91a3589ccdc1570cb64308aef54deb7d">mkernel_mesh2d_rotate</a> (int meshKernelId, double centreX, double centreY, double theta)</td></tr>
<tr class="memdesc:a91a3589ccdc1570cb64308aef54deb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a mesh2d about a point.  <br /></td></tr>
<tr class="separator:a91a3589ccdc1570cb64308aef54deb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a396a0ad56ec345564e4ae9db73e11" id="r_af0a396a0ad56ec345564e4ae9db73e11"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af0a396a0ad56ec345564e4ae9db73e11">mkernel_splines_snap_to_landboundary</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;land, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;splines, int startSplineIndex, int endSplineIndex)</td></tr>
<tr class="memdesc:af0a396a0ad56ec345564e4ae9db73e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snaps the spline (or splines) to the land boundary.  <br /></td></tr>
<tr class="separator:af0a396a0ad56ec345564e4ae9db73e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b25c255f1bf9207093b9d98ca1011d" id="r_a85b25c255f1bf9207093b9d98ca1011d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a85b25c255f1bf9207093b9d98ca1011d">mkernel_mesh2d_translate</a> (int meshKernelId, double translationX, double translationY)</td></tr>
<tr class="memdesc:a85b25c255f1bf9207093b9d98ca1011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a mesh2d.  <br /></td></tr>
<tr class="separator:a85b25c255f1bf9207093b9d98ca1011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212a43c6cb87cfed8bf14d681676987" id="r_ac212a43c6cb87cfed8bf14d681676987"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac212a43c6cb87cfed8bf14d681676987">mkernel_mesh2d_casulli_derefinement_elements</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;elements)</td></tr>
<tr class="memdesc:ac212a43c6cb87cfed8bf14d681676987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of elements that will be removed after the Casulli de-refinement algorithm.  <br /></td></tr>
<tr class="separator:ac212a43c6cb87cfed8bf14d681676987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac963dda956a7b00bac1fbc748cc0f309" id="r_ac963dda956a7b00bac1fbc748cc0f309"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac963dda956a7b00bac1fbc748cc0f309">mkernel_mesh2d_casulli_derefinement_elements_on_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonGeometry, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;elements)</td></tr>
<tr class="memdesc:ac963dda956a7b00bac1fbc748cc0f309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of elements that will be removed after the Casulli de-refinement algorithm.  <br /></td></tr>
<tr class="separator:ac963dda956a7b00bac1fbc748cc0f309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8393113961019f6808a7d2ac2355be58" id="r_a8393113961019f6808a7d2ac2355be58"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8393113961019f6808a7d2ac2355be58">mkernel_mesh2d_casulli_derefinement</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a8393113961019f6808a7d2ac2355be58"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-refine mesh using the Casulli de-refinement algorithm.  <br /></td></tr>
<tr class="separator:a8393113961019f6808a7d2ac2355be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393c9e1a49e6d111bf5de0dea8a0f37d" id="r_a393c9e1a49e6d111bf5de0dea8a0f37d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a393c9e1a49e6d111bf5de0dea8a0f37d">mkernel_mesh2d_casulli_derefinement_on_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons)</td></tr>
<tr class="memdesc:a393c9e1a49e6d111bf5de0dea8a0f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-refine mesh using the Casulli de-refinement algorithm.  <br /></td></tr>
<tr class="separator:a393c9e1a49e6d111bf5de0dea8a0f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862cbc79bab0e03153797c1e1292de88" id="r_a862cbc79bab0e03153797c1e1292de88"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a862cbc79bab0e03153797c1e1292de88">mkernel_mesh2d_casulli_refinement</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a862cbc79bab0e03153797c1e1292de88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine mesh using the Casulli refinement algorithm.  <br /></td></tr>
<tr class="separator:a862cbc79bab0e03153797c1e1292de88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d6d63626c31eb93ebb68f020f563fd" id="r_a70d6d63626c31eb93ebb68f020f563fd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a70d6d63626c31eb93ebb68f020f563fd">mkernel_mesh2d_casulli_refinement_on_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons)</td></tr>
<tr class="memdesc:a70d6d63626c31eb93ebb68f020f563fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine mesh using the Casulli refinement algorithm.  <br /></td></tr>
<tr class="separator:a70d6d63626c31eb93ebb68f020f563fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156192886c65dcffa89cad36a5c78045" id="r_a156192886c65dcffa89cad36a5c78045"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a156192886c65dcffa89cad36a5c78045">mkernel_mesh2d_compute_orthogonalization</a> (int meshKernelId, int projectToLandBoundaryOption, const <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;orthogonalizationParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectingPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;landBoundaries)</td></tr>
<tr class="separator:a156192886c65dcffa89cad36a5c78045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d548882516ac652fd0f01a08c88bd" id="r_acf9d548882516ac652fd0f01a08c88bd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acf9d548882516ac652fd0f01a08c88bd">mkernel_mesh2d_connect_meshes</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d, double searchFraction)</td></tr>
<tr class="memdesc:acf9d548882516ac652fd0f01a08c88bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two or more disconnected regions along boundary.  <br /></td></tr>
<tr class="separator:acf9d548882516ac652fd0f01a08c88bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a14647b813f56d13fdfc182a9f95011" id="r_a8a14647b813f56d13fdfc182a9f95011"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8a14647b813f56d13fdfc182a9f95011">mkernel_mesh2d_convert_projection</a> (int meshKernelId, int projectionType, const char *const zoneString)</td></tr>
<tr class="memdesc:a8a14647b813f56d13fdfc182a9f95011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the projection of a mesh2d.  <br /></td></tr>
<tr class="separator:a8a14647b813f56d13fdfc182a9f95011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a9720954ca157a1ba2ccfd35bbf183" id="r_a76a9720954ca157a1ba2ccfd35bbf183"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a76a9720954ca157a1ba2ccfd35bbf183">mkernel_mesh2d_convert_to_curvilinear</a> (int meshKernelId, double xPointCoordinate, double yPointCoordinate)</td></tr>
<tr class="memdesc:a76a9720954ca157a1ba2ccfd35bbf183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a mesh to a curvilinear mesh.  <br /></td></tr>
<tr class="separator:a76a9720954ca157a1ba2ccfd35bbf183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ba5182f31ea1567bc258bb95cad221" id="r_a00ba5182f31ea1567bc258bb95cad221"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a00ba5182f31ea1567bc258bb95cad221">mkernel_mesh2d_count_hanging_edges</a> (int meshKernelId, int &amp;numEdges)</td></tr>
<tr class="memdesc:a00ba5182f31ea1567bc258bb95cad221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of hanging edges in a mesh2d. An hanging edge is an edge where one of the two nodes is not connected.  <br /></td></tr>
<tr class="separator:a00ba5182f31ea1567bc258bb95cad221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7bcc0a8c5e3af905c124e5778a5960" id="r_a5b7bcc0a8c5e3af905c124e5778a5960"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a5b7bcc0a8c5e3af905c124e5778a5960">mkernel_mesh2d_count_mesh_boundaries_as_polygons</a> (int meshKernelId, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:a5b7bcc0a8c5e3af905c124e5778a5960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of polygon nodes contained in the mesh boundary polygons computed in function <code>mkernel_mesh2d_get_mesh_boundaries_as_polygons</code>  <br /></td></tr>
<tr class="separator:a5b7bcc0a8c5e3af905c124e5778a5960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddb0753a28c76813a451f9c5221443e" id="r_a1ddb0753a28c76813a451f9c5221443e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1ddb0753a28c76813a451f9c5221443e">mkernel_mesh2d_count_nodes_in_polygons</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int inside, int &amp;numberOfMeshNodes)</td></tr>
<tr class="memdesc:a1ddb0753a28c76813a451f9c5221443e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of selected mesh node indices.  <br /></td></tr>
<tr class="separator:a1ddb0753a28c76813a451f9c5221443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a0bff406cab9545674897ceeaf4af" id="r_aa79a0bff406cab9545674897ceeaf4af"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa79a0bff406cab9545674897ceeaf4af">mkernel_mesh2d_count_obtuse_triangles</a> (int meshKernelId, int &amp;numObtuseTriangles)</td></tr>
<tr class="memdesc:aa79a0bff406cab9545674897ceeaf4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of obtuse mesh2d triangles. Obtuse triangles are those having one edge longer than the sum of the other two.  <br /></td></tr>
<tr class="separator:aa79a0bff406cab9545674897ceeaf4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4542f019f36e5f06a23f8269e11342af" id="r_a4542f019f36e5f06a23f8269e11342af"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4542f019f36e5f06a23f8269e11342af">mkernel_mesh2d_count_small_flow_edge_centers</a> (int meshKernelId, double smallFlowEdgesLengthThreshold, int &amp;numSmallFlowEdges)</td></tr>
<tr class="memdesc:a4542f019f36e5f06a23f8269e11342af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of small mesh2d flow edges. The flow edges are the edges connecting faces circumcenters.  <br /></td></tr>
<tr class="separator:a4542f019f36e5f06a23f8269e11342af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab787ab2087d49d4797e2dbdb3cf5e0ca" id="r_ab787ab2087d49d4797e2dbdb3cf5e0ca"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab787ab2087d49d4797e2dbdb3cf5e0ca">mkernel_mesh2d_delete</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygon, int deletionOption, int invertDeletion)</td></tr>
<tr class="memdesc:ab787ab2087d49d4797e2dbdb3cf5e0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon using several options.  <br /></td></tr>
<tr class="separator:ab787ab2087d49d4797e2dbdb3cf5e0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce1ba846742ee85f26b34c71336ef9b" id="r_a0ce1ba846742ee85f26b34c71336ef9b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0ce1ba846742ee85f26b34c71336ef9b">mkernel_mesh2d_delete_edge</a> (int meshKernelId, double xCoordinate, double yCoordinate, double xLowerLeftBoundingBox, double yLowerLeftBoundingBox, double xUpperRightBoundingBox, double yUpperRightBoundingBox)</td></tr>
<tr class="memdesc:a0ce1ba846742ee85f26b34c71336ef9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the closest mesh2d edge to a point. The coordinates of the edge middle points are used for calculating the distances to the point.  <br /></td></tr>
<tr class="separator:a0ce1ba846742ee85f26b34c71336ef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0892a7890e27cd70521af0b86d90407f" id="r_a0892a7890e27cd70521af0b86d90407f"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0892a7890e27cd70521af0b86d90407f">mkernel_mesh2d_delete_edge_by_index</a> (int meshKernelId, int edgeIndex)</td></tr>
<tr class="memdesc:a0892a7890e27cd70521af0b86d90407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh2d edge given the index of the edge. The coordinates of the edge middle points are used for calculating the distances to the point.  <br /></td></tr>
<tr class="separator:a0892a7890e27cd70521af0b86d90407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847e53287a42b4e00385755ba1162e70" id="r_a847e53287a42b4e00385755ba1162e70"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a847e53287a42b4e00385755ba1162e70">mkernel_mesh2d_delete_hanging_edges</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a847e53287a42b4e00385755ba1162e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all hanging edges. An hanging edge is an edge where one of the two nodes is not connected.  <br /></td></tr>
<tr class="separator:a847e53287a42b4e00385755ba1162e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec2f1082a199322b753b054d226329e" id="r_a2ec2f1082a199322b753b054d226329e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a2ec2f1082a199322b753b054d226329e">mkernel_mesh2d_delete_node</a> (int meshKernelId, int nodeIndex)</td></tr>
<tr class="memdesc:a2ec2f1082a199322b753b054d226329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh2d node.  <br /></td></tr>
<tr class="separator:a2ec2f1082a199322b753b054d226329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24115f31dde1cfe7e388729dbd23b814" id="r_a24115f31dde1cfe7e388729dbd23b814"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a24115f31dde1cfe7e388729dbd23b814">mkernel_mesh2d_delete_orthogonalization</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a24115f31dde1cfe7e388729dbd23b814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans the orthogonalization algorithm state, allocated in <code>mkernel_mesh2d_initialize_orthogonalization</code> (interactive mode)  <br /></td></tr>
<tr class="separator:a24115f31dde1cfe7e388729dbd23b814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a8202bcfaa2902b5d42aed1cec50bb" id="r_a40a8202bcfaa2902b5d42aed1cec50bb"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a40a8202bcfaa2902b5d42aed1cec50bb">mkernel_mesh2d_delete_small_flow_edges_and_small_triangles</a> (int meshKernelId, double smallFlowEdgesThreshold, double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:a40a8202bcfaa2902b5d42aed1cec50bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all small mesh2d flow edges and small triangles. The flow edges are the edges connecting faces circumcenters.  <br /></td></tr>
<tr class="separator:a40a8202bcfaa2902b5d42aed1cec50bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d2485750b09cd54d44ce8a5d385dcd" id="r_ad3d2485750b09cd54d44ce8a5d385dcd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad3d2485750b09cd54d44ce8a5d385dcd">mkernel_mesh2d_finalize_inner_ortogonalization_iteration</a> (int meshKernelId)</td></tr>
<tr class="memdesc:ad3d2485750b09cd54d44ce8a5d385dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the orthogonalization outer iteration, computing the new coefficients for grid adaption and the new face circumcenters (interactive mode).  <br /></td></tr>
<tr class="separator:ad3d2485750b09cd54d44ce8a5d385dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dadc997b1571c5ba6cca3c178ceba14" id="r_a6dadc997b1571c5ba6cca3c178ceba14"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6dadc997b1571c5ba6cca3c178ceba14">mkernel_mesh2d_flip_edges</a> (int meshKernelId, int isTriangulationRequired, int projectToLandBoundaryRequired, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectingPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;landBoundaries)</td></tr>
<tr class="memdesc:a6dadc997b1571c5ba6cca3c178ceba14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips mesh2d edges, to optimize the mesh smoothness. This operation is usually performed after <code>mkernel_mesh2d_refine_based_on_samples</code> or <code>mkernel_mesh2d_refine_based_on_polygon</code>.  <br /></td></tr>
<tr class="separator:a6dadc997b1571c5ba6cca3c178ceba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6df0f168c0bd9535114fd65a41ded1" id="r_a4b6df0f168c0bd9535114fd65a41ded1"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4b6df0f168c0bd9535114fd65a41ded1">mkernel_mesh2d_get_closest_node</a> (int meshKernelId, double xCoordinateIn, double yCoordinateIn, double searchRadius, double xLowerLeftBoundingBox, double yLowerLeftBoundingBox, double xUpperRightBoundingBox, double yUpperRightBoundingBox, double &amp;xCoordinateOut, double &amp;yCoordinateOut)</td></tr>
<tr class="memdesc:a4b6df0f168c0bd9535114fd65a41ded1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest mesh2d node coordinates to a point, searching within a radius.  <br /></td></tr>
<tr class="separator:a4b6df0f168c0bd9535114fd65a41ded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c36845832e4dc42ce9437b844f5830" id="r_a16c36845832e4dc42ce9437b844f5830"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a16c36845832e4dc42ce9437b844f5830">mkernel_mesh2d_get_data</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:a16c36845832e4dc42ce9437b844f5830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions data.  <br /></td></tr>
<tr class="separator:a16c36845832e4dc42ce9437b844f5830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b420d3c788df828c023e79f5c7c31" id="r_ac99b420d3c788df828c023e79f5c7c31"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac99b420d3c788df828c023e79f5c7c31">mkernel_mesh2d_get_orthogonality_property_type</a> (int &amp;type)</td></tr>
<tr class="memdesc:ac99b420d3c788df828c023e79f5c7c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an int indicating the orthogonality property type for mesh2d.  <br /></td></tr>
<tr class="separator:ac99b420d3c788df828c023e79f5c7c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69ba29d07c1fcbd9a1292693090eaef" id="r_ac69ba29d07c1fcbd9a1292693090eaef"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac69ba29d07c1fcbd9a1292693090eaef">mkernel_mesh2d_get_node_edge_data</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:ac69ba29d07c1fcbd9a1292693090eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets only the node and edge <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data.  <br /></td></tr>
<tr class="separator:ac69ba29d07c1fcbd9a1292693090eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f563fcc78f0992f5a7b01a70ad7bb4" id="r_a67f563fcc78f0992f5a7b01a70ad7bb4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a67f563fcc78f0992f5a7b01a70ad7bb4">mkernel_mesh2d_get_dimensions</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:a67f563fcc78f0992f5a7b01a70ad7bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions.  <br /></td></tr>
<tr class="separator:a67f563fcc78f0992f5a7b01a70ad7bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0a192a35692dbb03284457fb8730b1" id="r_a3f0a192a35692dbb03284457fb8730b1"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3f0a192a35692dbb03284457fb8730b1">mkernel_mesh2d_get_edge</a> (int meshKernelId, double xCoordinate, double yCoordinate, double xLowerLeftBoundingBox, double yLowerLeftBoundingBox, double xUpperRightBoundingBox, double yUpperRightBoundingBox, int &amp;edgeIndex)</td></tr>
<tr class="memdesc:a3f0a192a35692dbb03284457fb8730b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest mesh2d edge to a point in a bounding box.  <br /></td></tr>
<tr class="separator:a3f0a192a35692dbb03284457fb8730b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423ff72e320079ef555cbd7413fe767" id="r_a2423ff72e320079ef555cbd7413fe767"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a2423ff72e320079ef555cbd7413fe767">mkernel_mesh2d_get_hanging_edges</a> (int meshKernelId, int *edges)</td></tr>
<tr class="memdesc:a2423ff72e320079ef555cbd7413fe767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indices of hanging edges. An hanging edge is an edge where one of the two nodes is not connected.  <br /></td></tr>
<tr class="separator:a2423ff72e320079ef555cbd7413fe767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7017faa5415bfe805793341015380efd" id="r_a7017faa5415bfe805793341015380efd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a7017faa5415bfe805793341015380efd">mkernel_mesh2d_get_face_polygons</a> (int meshKernelId, int numEdges, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;facePolygons)</td></tr>
<tr class="memdesc:a7017faa5415bfe805793341015380efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the faces polygons with a number of edges larger or equal to numEdges.  <br /></td></tr>
<tr class="separator:a7017faa5415bfe805793341015380efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0ef73c3fc68077dfa50d6b1ab855b7" id="r_aed0ef73c3fc68077dfa50d6b1ab855b7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aed0ef73c3fc68077dfa50d6b1ab855b7">mkernel_mesh2d_get_face_polygons_dimension</a> (int meshKernelId, int numEdges, int &amp;geometryListDimension)</td></tr>
<tr class="memdesc:aed0ef73c3fc68077dfa50d6b1ab855b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dimension of faces polygons with a number of edges larger or equal to numNodes.  <br /></td></tr>
<tr class="separator:aed0ef73c3fc68077dfa50d6b1ab855b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac177194bf4d9998cf649f884f4210140" id="r_ac177194bf4d9998cf649f884f4210140"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac177194bf4d9998cf649f884f4210140">mkernel_mesh2d_get_filtered_face_polygons_dimension</a> (int meshKernelId, int propertyValue, double minValue, double maxValue, int &amp;geometryListDimension)</td></tr>
<tr class="memdesc:ac177194bf4d9998cf649f884f4210140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the dimension of the geometry list containing the face polygons within the filtering range.  <br /></td></tr>
<tr class="separator:ac177194bf4d9998cf649f884f4210140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094481597e69f34b232c40cbde0a8c7e" id="r_a094481597e69f34b232c40cbde0a8c7e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a094481597e69f34b232c40cbde0a8c7e">mkernel_mesh2d_get_filtered_face_polygons</a> (int meshKernelId, int propertyValue, double minValue, double maxValue, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;facePolygons)</td></tr>
<tr class="memdesc:a094481597e69f34b232c40cbde0a8c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the geometry list containing the face polygons within the filtering range.  <br /></td></tr>
<tr class="separator:a094481597e69f34b232c40cbde0a8c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1d39c897149389496581641de8a216" id="r_aab1d39c897149389496581641de8a216"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aab1d39c897149389496581641de8a216">mkernel_mesh2d_get_location_index</a> (int meshKernelId, double xCoordinate, double yCoordinate, int locationType, const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox, int &amp;locationIndex)</td></tr>
<tr class="memdesc:aab1d39c897149389496581641de8a216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mesh location closet to a specific coordinate.  <br /></td></tr>
<tr class="separator:aab1d39c897149389496581641de8a216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8b018fc9893667066ec6bc59a0107" id="r_a9dd8b018fc9893667066ec6bc59a0107"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a9dd8b018fc9893667066ec6bc59a0107">mkernel_mesh2d_get_mesh_boundaries_as_polygons</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;boundaryPolygons)</td></tr>
<tr class="memdesc:a9dd8b018fc9893667066ec6bc59a0107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the boundaries of a mesh as a series of separated polygons.  <br /></td></tr>
<tr class="separator:a9dd8b018fc9893667066ec6bc59a0107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7157b97182f7c850d2e9af416c775e2a" id="r_a7157b97182f7c850d2e9af416c775e2a"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a7157b97182f7c850d2e9af416c775e2a">mkernel_mesh2d_get_node_index</a> (int meshKernelId, double xCoordinate, double yCoordinate, double searchRadius, double xLowerLeftBoundingBox, double yLowerLeftBoundingBox, double xUpperRightBoundingBox, double yUpperRightBoundingBox, int &amp;nodeIndex)</td></tr>
<tr class="memdesc:a7157b97182f7c850d2e9af416c775e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the mesh2d node closest to a point, within a search radius.  <br /></td></tr>
<tr class="separator:a7157b97182f7c850d2e9af416c775e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad047db207caf19e8856257ad86123b" id="r_adad047db207caf19e8856257ad86123b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#adad047db207caf19e8856257ad86123b">mkernel_mesh2d_get_nodes_in_polygons</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int inside, int *selectedNodes)</td></tr>
<tr class="memdesc:adad047db207caf19e8856257ad86123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indices of the mesh2d nodes selected with a polygon.  <br /></td></tr>
<tr class="separator:adad047db207caf19e8856257ad86123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913d907bdf44ddd4f981b2efc7b3bd7" id="r_a4913d907bdf44ddd4f981b2efc7b3bd7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4913d907bdf44ddd4f981b2efc7b3bd7">mkernel_mesh2d_get_obtuse_triangles_mass_centers</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;result)</td></tr>
<tr class="memdesc:a4913d907bdf44ddd4f981b2efc7b3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass centers of obtuse mesh2d triangles. Obtuse triangles are those having one edge longer than the sum of the other two.  <br /></td></tr>
<tr class="separator:a4913d907bdf44ddd4f981b2efc7b3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed83472a1ede3effc40d1a052ddf72cb" id="r_aed83472a1ede3effc40d1a052ddf72cb"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aed83472a1ede3effc40d1a052ddf72cb">mkernel_mesh2d_get_orthogonality</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:aed83472a1ede3effc40d1a052ddf72cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mesh orthogonality, expressed as the ratio between the edges and the segments connecting the face circumcenters.  <br /></td></tr>
<tr class="separator:aed83472a1ede3effc40d1a052ddf72cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816644a1b732b8ec3758d3c25f18e3a4" id="r_a816644a1b732b8ec3758d3c25f18e3a4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a816644a1b732b8ec3758d3c25f18e3a4">mkernel_mesh2d_get_property</a> (int meshKernelId, int propertyValue, int locationId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometrylist)</td></tr>
<tr class="memdesc:a816644a1b732b8ec3758d3c25f18e3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a specified property of a 2D mesh.  <br /></td></tr>
<tr class="separator:a816644a1b732b8ec3758d3c25f18e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2686e90f73ffacb9c9ee363399337e" id="r_a5b2686e90f73ffacb9c9ee363399337e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a5b2686e90f73ffacb9c9ee363399337e">mkernel_mesh2d_get_property_dimension</a> (int meshKernelId, int propertyValue, int &amp;dimension)</td></tr>
<tr class="memdesc:a5b2686e90f73ffacb9c9ee363399337e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of a specified property of a 2D mesh.  <br /></td></tr>
<tr class="separator:a5b2686e90f73ffacb9c9ee363399337e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c732d6cc407e5ef62f6ab00b423a908" id="r_a4c732d6cc407e5ef62f6ab00b423a908"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4c732d6cc407e5ef62f6ab00b423a908">mkernel_mesh2d_get_small_flow_edge_centers</a> (int meshKernelId, double smallFlowEdgesThreshold, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;result)</td></tr>
<tr class="memdesc:a4c732d6cc407e5ef62f6ab00b423a908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the small mesh2d flow edges. The flow edges are the edges connecting faces circumcenters.  <br /></td></tr>
<tr class="separator:a4c732d6cc407e5ef62f6ab00b423a908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95a652d65ce2650b4f490fcc901fb02" id="r_ad95a652d65ce2650b4f490fcc901fb02"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad95a652d65ce2650b4f490fcc901fb02">mkernel_mesh2d_get_smoothness</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:ad95a652d65ce2650b4f490fcc901fb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smoothness, expressed as the ratio between the values of two neighboring faces areas.  <br /></td></tr>
<tr class="separator:ad95a652d65ce2650b4f490fcc901fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d921edc9c4cd6801d8d5522d7aa809" id="r_ac6d921edc9c4cd6801d8d5522d7aa809"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac6d921edc9c4cd6801d8d5522d7aa809">mkernel_mesh2d_initialize_orthogonalization</a> (int meshKernelId, int projectToLandBoundaryOption, <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;orthogonalizationParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectingPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;landBoundaries)</td></tr>
<tr class="memdesc:ac6d921edc9c4cd6801d8d5522d7aa809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the <a class="el" href="classmeshkernel_1_1_orthogonalization_and_smoothing.html">meshkernel::OrthogonalizationAndSmoothing</a> algorithm.  <br /></td></tr>
<tr class="separator:ac6d921edc9c4cd6801d8d5522d7aa809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38c500f59b002ad798c50b8dbf66b4b" id="r_aa38c500f59b002ad798c50b8dbf66b4b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa38c500f59b002ad798c50b8dbf66b4b">mkernel_mesh2d_insert_edge</a> (int meshKernelId, int startNode, int endNode, int &amp;newEdgeIndex)</td></tr>
<tr class="memdesc:aa38c500f59b002ad798c50b8dbf66b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new mesh2d edge connecting two nodes.  <br /></td></tr>
<tr class="separator:aa38c500f59b002ad798c50b8dbf66b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2fc2052f30acc0a11b7fbbab2ba9b9" id="r_a8b2fc2052f30acc0a11b7fbbab2ba9b9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8b2fc2052f30acc0a11b7fbbab2ba9b9">mkernel_mesh2d_insert_edge_from_coordinates</a> (int meshKernelId, double firstNodeX, double firstNodeY, double secondNodeX, double secondNodeY, int &amp;firstNodeIndex, int &amp;secondNodeIndex, int &amp;edgeIndex)</td></tr>
<tr class="memdesc:a8b2fc2052f30acc0a11b7fbbab2ba9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new mesh2d edge from 2 coordinates.  <br /></td></tr>
<tr class="separator:a8b2fc2052f30acc0a11b7fbbab2ba9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f687ae29333b6400a412b82629c4ef" id="r_a90f687ae29333b6400a412b82629c4ef"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a90f687ae29333b6400a412b82629c4ef">mkernel_mesh2d_insert_node</a> (int meshKernelId, double xCoordinate, double yCoordinate, int &amp;nodeIndex)</td></tr>
<tr class="memdesc:a90f687ae29333b6400a412b82629c4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new mesh2d node at a specific coordinate.  <br /></td></tr>
<tr class="separator:a90f687ae29333b6400a412b82629c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a38a425a4c575cd1de377a5ecad354" id="r_a43a38a425a4c575cd1de377a5ecad354"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a43a38a425a4c575cd1de377a5ecad354">mkernel_mesh2d_intersections_from_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;boundaryPolygon, int *edgeNodes, int *edgeIndex, double *edgeDistances, double *segmentDistances, int *segmentIndexes, int *faceIndexes, int *faceNumEdges, int *faceEdgeIndex)</td></tr>
<tr class="memdesc:a43a38a425a4c575cd1de377a5ecad354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges intersected by a polygon, with additional information on the intersections.  <br /></td></tr>
<tr class="separator:a43a38a425a4c575cd1de377a5ecad354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8098267db254b7c57afe0ccfffcd18d" id="r_ac8098267db254b7c57afe0ccfffcd18d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac8098267db254b7c57afe0ccfffcd18d">mkernel_mesh2d_is_valid_property</a> (int meshKernelId, const int propertyId, const int locationId, bool &amp;propertyIsAvailable)</td></tr>
<tr class="memdesc:ac8098267db254b7c57afe0ccfffcd18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the property data for the mesh can be computed.  <br /></td></tr>
<tr class="separator:ac8098267db254b7c57afe0ccfffcd18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc659490a272d015ea79215b27419243" id="r_afc659490a272d015ea79215b27419243"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#afc659490a272d015ea79215b27419243">mkernel_mesh2d_make_global</a> (int meshKernelId, int numLongitudeNodes, int numLatitudeNodes)</td></tr>
<tr class="memdesc:afc659490a272d015ea79215b27419243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the global mesh with a given number of points along the longitude and latitude directions.  <br /></td></tr>
<tr class="separator:afc659490a272d015ea79215b27419243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705012a0f338272507f22bb5832ad3be" id="r_a705012a0f338272507f22bb5832ad3be"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a705012a0f338272507f22bb5832ad3be">mkernel_mesh2d_make_triangular_mesh_from_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonPoints)</td></tr>
<tr class="memdesc:a705012a0f338272507f22bb5832ad3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a triangular mesh2d grid within a polygon. The size of the triangles is determined from the length of the polygon edges.  <br /></td></tr>
<tr class="separator:a705012a0f338272507f22bb5832ad3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3459011bc43e11d1e6852914279eb0c3" id="r_a3459011bc43e11d1e6852914279eb0c3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3459011bc43e11d1e6852914279eb0c3">mkernel_mesh2d_make_triangular_mesh_from_samples</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;samples)</td></tr>
<tr class="memdesc:a3459011bc43e11d1e6852914279eb0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a triangular mesh from a set of samples, triangulating the sample points.  <br /></td></tr>
<tr class="separator:a3459011bc43e11d1e6852914279eb0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a432823c03f75fefa35669bb712e0d" id="r_a68a432823c03f75fefa35669bb712e0d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a68a432823c03f75fefa35669bb712e0d">mkernel_mesh2d_make_rectangular_mesh</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters)</td></tr>
<tr class="memdesc:a68a432823c03f75fefa35669bb712e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a rectangular mesh.  <br /></td></tr>
<tr class="separator:a68a432823c03f75fefa35669bb712e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b026000339c8b861a465a968794c24" id="r_a66b026000339c8b861a465a968794c24"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a66b026000339c8b861a465a968794c24">mkernel_mesh2d_make_rectangular_mesh_from_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:a66b026000339c8b861a465a968794c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a rectangular mesh from a polygon.  <br /></td></tr>
<tr class="separator:a66b026000339c8b861a465a968794c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d559487b89e3bde2ed59bb1c8b00031" id="r_a6d559487b89e3bde2ed59bb1c8b00031"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6d559487b89e3bde2ed59bb1c8b00031">mkernel_mesh2d_make_rectangular_mesh_on_extension</a> (int meshKernelId, const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;makeGridParameters)</td></tr>
<tr class="memdesc:a6d559487b89e3bde2ed59bb1c8b00031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a rectangular mesh on a defined extension.  <br /></td></tr>
<tr class="separator:a6d559487b89e3bde2ed59bb1c8b00031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ff49944a2e931a0bf54b8cd7fe610e" id="r_a06ff49944a2e931a0bf54b8cd7fe610e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a06ff49944a2e931a0bf54b8cd7fe610e">mkernel_mesh2d_merge_nodes</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn)</td></tr>
<tr class="memdesc:a06ff49944a2e931a0bf54b8cd7fe610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the mesh2d nodes within a distance of 0.001 m, effectively removing all small edges.  <br /></td></tr>
<tr class="separator:a06ff49944a2e931a0bf54b8cd7fe610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae177d47f9f0ae7eee4e51e7dfb47217" id="r_aae177d47f9f0ae7eee4e51e7dfb47217"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aae177d47f9f0ae7eee4e51e7dfb47217">mkernel_mesh2d_merge_nodes_with_merging_distance</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, double mergingDistance)</td></tr>
<tr class="memdesc:aae177d47f9f0ae7eee4e51e7dfb47217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the mesh2d nodes within a distance of 0.001 m, effectively removing all small edges.  <br /></td></tr>
<tr class="separator:aae177d47f9f0ae7eee4e51e7dfb47217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c58950912873ea5540775cb1c3b89" id="r_a4c0c58950912873ea5540775cb1c3b89"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4c0c58950912873ea5540775cb1c3b89">mkernel_mesh2d_merge_two_nodes</a> (int meshKernelId, int firstNode, int secondNode)</td></tr>
<tr class="memdesc:a4c0c58950912873ea5540775cb1c3b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh2d nodes into one.  <br /></td></tr>
<tr class="separator:a4c0c58950912873ea5540775cb1c3b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744a1d9dcec872bb2fcb07dcf01dc326" id="r_a744a1d9dcec872bb2fcb07dcf01dc326"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a744a1d9dcec872bb2fcb07dcf01dc326">mkernel_mesh2d_move_node</a> (int meshKernelId, double xCoordinate, double yCoordinate, int nodeIndex)</td></tr>
<tr class="memdesc:a744a1d9dcec872bb2fcb07dcf01dc326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a mesh2d node to a new position.  <br /></td></tr>
<tr class="separator:a744a1d9dcec872bb2fcb07dcf01dc326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef99054ee1c2c570e530c3dbb58ddcf" id="r_a3ef99054ee1c2c570e530c3dbb58ddcf"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3ef99054ee1c2c570e530c3dbb58ddcf">mkernel_mesh2d_prepare_outer_iteration_orthogonalization</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a3ef99054ee1c2c570e530c3dbb58ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares an outer orthogonalization iteration, computing the new orthogonalization and smoothing weights from the modified mesh geometry (in interactive mode).  <br /></td></tr>
<tr class="separator:a3ef99054ee1c2c570e530c3dbb58ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40793b2bcadef556033eb378fe8dfc0" id="r_aa40793b2bcadef556033eb378fe8dfc0"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa40793b2bcadef556033eb378fe8dfc0">mkernel_mesh2d_refine_based_on_gridded_samples</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_gridded_samples.html">GriddedSamples</a> &amp;griddedSamples, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;meshRefinementParameters, bool useNodalRefinement)</td></tr>
<tr class="memdesc:aa40793b2bcadef556033eb378fe8dfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine based on gridded samples.  <br /></td></tr>
<tr class="separator:aa40793b2bcadef556033eb378fe8dfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e296f36170b57a36cea8efc3f2a365" id="r_aa4e296f36170b57a36cea8efc3f2a365"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa4e296f36170b57a36cea8efc3f2a365">mkernel_mesh2d_refine_based_on_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;meshRefinementParameters)</td></tr>
<tr class="memdesc:aa4e296f36170b57a36cea8efc3f2a365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a mesh2d within a polygon. Refinement is achieved by splitting the edges contained in the polygon by two.  <br /></td></tr>
<tr class="separator:aa4e296f36170b57a36cea8efc3f2a365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda13ff3814870fa33c6b06e01f7ccd" id="r_a7dda13ff3814870fa33c6b06e01f7ccd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a7dda13ff3814870fa33c6b06e01f7ccd">mkernel_mesh2d_refine_based_on_samples</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;samples, double relativeSearchRadius, int minimumNumSamples, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;meshRefinementParameters)</td></tr>
<tr class="memdesc:a7dda13ff3814870fa33c6b06e01f7ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a mesh2d based on samples. Refinement is achieved by successive splits of the face edges.  <br /></td></tr>
<tr class="separator:a7dda13ff3814870fa33c6b06e01f7ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8657de73c9b65364990432552ff825e2" id="r_a8657de73c9b65364990432552ff825e2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8657de73c9b65364990432552ff825e2">mkernel_mesh2d_refine_ridges_based_on_gridded_samples</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_gridded_samples.html">GriddedSamples</a> &amp;griddedSamples, double relativeSearchRadius, int minimumNumSamples, int numberOfSmoothingIterations, const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;meshRefinementParameters)</td></tr>
<tr class="memdesc:a8657de73c9b65364990432552ff825e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a mesh2d based on samples with ridge refinement. This method automatically detects the ridges in a sample set.  <br /></td></tr>
<tr class="separator:a8657de73c9b65364990432552ff825e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b8b6364302aacea2b8461008c91993" id="r_a51b8b6364302aacea2b8461008c91993"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a51b8b6364302aacea2b8461008c91993">mkernel_mesh2d_remove_disconnected_regions</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a51b8b6364302aacea2b8461008c91993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any disconnected regions from a mesh2d.  <br /></td></tr>
<tr class="separator:a51b8b6364302aacea2b8461008c91993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8871161744c899f45413808e2ebbbfb" id="r_aa8871161744c899f45413808e2ebbbfb"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa8871161744c899f45413808e2ebbbfb">mkernel_mesh2d_set</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:aa8871161744c899f45413808e2ebbbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state.  <br /></td></tr>
<tr class="separator:aa8871161744c899f45413808e2ebbbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07556a2e2ed6373cc65d5d2aedf1ebf3" id="r_a07556a2e2ed6373cc65d5d2aedf1ebf3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a07556a2e2ed6373cc65d5d2aedf1ebf3">mkernel_mesh2d_set_property</a> (int projectionType, int interpolationType, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;sampleData, int &amp;propertyId)</td></tr>
<tr class="memdesc:a07556a2e2ed6373cc65d5d2aedf1ebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the property data for the mesh, the sample data points do not have to match the mesh2d nodes.  <br /></td></tr>
<tr class="separator:a07556a2e2ed6373cc65d5d2aedf1ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3189a745b36940d51c81b607cf85ee4" id="r_ac3189a745b36940d51c81b607cf85ee4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac3189a745b36940d51c81b607cf85ee4">mkernel_mesh2d_snap_to_landboundary</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectingPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;landBoundaries)</td></tr>
<tr class="memdesc:ac3189a745b36940d51c81b607cf85ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snaps a mesh to a land boundary.  <br /></td></tr>
<tr class="separator:ac3189a745b36940d51c81b607cf85ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4998517f14650d76335174d52c40d7b" id="r_af4998517f14650d76335174d52c40d7b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af4998517f14650d76335174d52c40d7b">mkernel_mesh2d_split_row</a> (int meshKernelId, int firstNode, int secondNode)</td></tr>
<tr class="memdesc:af4998517f14650d76335174d52c40d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An-isotropically refines the elements along a row or column, given a starting edge.  <br /></td></tr>
<tr class="separator:af4998517f14650d76335174d52c40d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33ed1cc636956cc68a7c1886447107" id="r_aec33ed1cc636956cc68a7c1886447107"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aec33ed1cc636956cc68a7c1886447107">mkernel_mesh2d_add</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:aec33ed1cc636956cc68a7c1886447107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a mesh to the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state.  <br /></td></tr>
<tr class="separator:aec33ed1cc636956cc68a7c1886447107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b94c6f1ad7b5e521d17453a944bacd" id="r_a91b94c6f1ad7b5e521d17453a944bacd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a91b94c6f1ad7b5e521d17453a944bacd">mkernel_mesh2d_triangulation_interpolation</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;samples, int locationType, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;results)</td></tr>
<tr class="memdesc:a91b94c6f1ad7b5e521d17453a944bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle interpolation (ec_module)  <br /></td></tr>
<tr class="separator:a91b94c6f1ad7b5e521d17453a944bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a958ce04cf210d3daf85eb03c88fc" id="r_a374a958ce04cf210d3daf85eb03c88fc"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a374a958ce04cf210d3daf85eb03c88fc">mkernel_network1d_compute_fixed_chainages</a> (int meshKernelId, double *fixedChainages, int sizeFixedChainages, double minFaceSize, double fixedChainagesOffset)</td></tr>
<tr class="memdesc:a374a958ce04cf210d3daf85eb03c88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the network chainages from fixed point locations.  <br /></td></tr>
<tr class="separator:a374a958ce04cf210d3daf85eb03c88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26aca7c00112d28304ffff67edc80ce" id="r_ad26aca7c00112d28304ffff67edc80ce"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad26aca7c00112d28304ffff67edc80ce">mkernel_network1d_compute_offsetted_chainages</a> (int meshKernelId, double offset)</td></tr>
<tr class="memdesc:ad26aca7c00112d28304ffff67edc80ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the network chainages at a regular offset.  <br /></td></tr>
<tr class="separator:ad26aca7c00112d28304ffff67edc80ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4682752f4cbc06cc28c6e428e673cce" id="r_ac4682752f4cbc06cc28c6e428e673cce"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac4682752f4cbc06cc28c6e428e673cce">mkernel_network1d_set</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polylines)</td></tr>
<tr class="memdesc:ac4682752f4cbc06cc28c6e428e673cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmeshkernel_1_1_network1_d.html" title="A class describing a network 1d.">meshkernel::Network1D</a> state.  <br /></td></tr>
<tr class="separator:ac4682752f4cbc06cc28c6e428e673cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e87cdf29b5b6ed204a0594b9e1bf08" id="r_a11e87cdf29b5b6ed204a0594b9e1bf08"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a11e87cdf29b5b6ed204a0594b9e1bf08">mkernel_network1d_to_mesh1d</a> (int meshKernelId, double minFaceSize)</td></tr>
<tr class="memdesc:a11e87cdf29b5b6ed204a0594b9e1bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert network chainages to mesh1d nodes and edges.  <br /></td></tr>
<tr class="separator:a11e87cdf29b5b6ed204a0594b9e1bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f926bf97f94392fec1a88b6d32d0d4" id="r_a29f926bf97f94392fec1a88b6d32d0d4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a29f926bf97f94392fec1a88b6d32d0d4">mkernel_polygon_count_offset</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int innerPolygon, double distance, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:a29f926bf97f94392fec1a88b6d32d0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of polygon nodes resulting from polygon offset.  <br /></td></tr>
<tr class="separator:a29f926bf97f94392fec1a88b6d32d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8116b16cb7763092d273cf184b626e" id="r_a3a8116b16cb7763092d273cf184b626e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3a8116b16cb7763092d273cf184b626e">mkernel_polygon_count_refine</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonToRefine, int firstIndex, int secondIndex, double distance, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:a3a8116b16cb7763092d273cf184b626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of polygon nodes resulting from polygon refinement with <code>mkernel_polygon_refine</code>.  <br /></td></tr>
<tr class="separator:a3a8116b16cb7763092d273cf184b626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc137eac3dfb82f608df3a1395f1f98" id="r_a1dc137eac3dfb82f608df3a1395f1f98"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1dc137eac3dfb82f608df3a1395f1f98">mkernel_polygon_count_linear_refine</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonToRefine, int firstIndex, int secondIndex, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:a1dc137eac3dfb82f608df3a1395f1f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of polygon nodes resulting from polygon refinement with <code>mkernel_polygon_linear_refine</code>.  <br /></td></tr>
<tr class="separator:a1dc137eac3dfb82f608df3a1395f1f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe136285361f89d9d13b87f7a7f5a84" id="r_affe136285361f89d9d13b87f7a7f5a84"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#affe136285361f89d9d13b87f7a7f5a84">mkernel_polygon_get_included_points</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectingPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonToSelect, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectionResults)</td></tr>
<tr class="memdesc:affe136285361f89d9d13b87f7a7f5a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the polygon nodes within another polygon.  <br /></td></tr>
<tr class="separator:affe136285361f89d9d13b87f7a7f5a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3833a1ecc2962cd39b9ea36a2982392e" id="r_a3833a1ecc2962cd39b9ea36a2982392e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3833a1ecc2962cd39b9ea36a2982392e">mkernel_polygon_get_offset</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int inWard, double distance, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListOut)</td></tr>
<tr class="memdesc:a3833a1ecc2962cd39b9ea36a2982392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new polygon from an existing one by offsetting the perimeter by a given distance.  <br /></td></tr>
<tr class="separator:a3833a1ecc2962cd39b9ea36a2982392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab0dd1a911d90ab8ec462d2eec86e14" id="r_aeab0dd1a911d90ab8ec462d2eec86e14"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aeab0dd1a911d90ab8ec462d2eec86e14">mkernel_polygon_refine</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonToRefine, int firstNodeIndex, int secondNodeIndex, double targetEdgeLength, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;refinedPolygon)</td></tr>
<tr class="memdesc:aeab0dd1a911d90ab8ec462d2eec86e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the polygon perimeter between two nodes. This interval is refined to achieve a target edge length.  <br /></td></tr>
<tr class="separator:aeab0dd1a911d90ab8ec462d2eec86e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b2005ba0b8863486bb12e374d20d26" id="r_ad5b2005ba0b8863486bb12e374d20d26"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad5b2005ba0b8863486bb12e374d20d26">mkernel_polygon_linear_refine</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonToRefine, int firstNodeIndex, int secondNodeIndex, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;refinedPolygon)</td></tr>
<tr class="memdesc:ad5b2005ba0b8863486bb12e374d20d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear refines the polygon perimeter between two nodes.  <br /></td></tr>
<tr class="separator:ad5b2005ba0b8863486bb12e374d20d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09fcdfed55040bf17cadff45647d1a6" id="r_ab09fcdfed55040bf17cadff45647d1a6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab09fcdfed55040bf17cadff45647d1a6">mkernel_polygon_snap_to_landboundary</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;land, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygon, int startIndex, int endIndex)</td></tr>
<tr class="memdesc:ab09fcdfed55040bf17cadff45647d1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snaps the polygon to the land boundary.  <br /></td></tr>
<tr class="separator:ab09fcdfed55040bf17cadff45647d1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all structs and functions exposed at the API level. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e737d3ce03b109b6aaff17396f63aac" name="a8e737d3ce03b109b6aaff17396f63aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d3ce03b109b6aaff17396f63aac">&#9670;&#160;</a></span>mkernel_allocate_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_allocate_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>meshKernelId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mesh state and returns the generated <code>meshKernelId</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projectionType</td><td>Cartesian (0), spherical (1) or spherical accurate(2) state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a635acda90d728526dbbf6b9180f9bde8" name="a635acda90d728526dbbf6b9180f9bde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635acda90d728526dbbf6b9180f9bde8">&#9670;&#160;</a></span>mkernel_clear_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_clear_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all internal mesh kernel state and undo actions, no undo will be possible after this. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a300a35a4e10c61d1b109ae10f46939b9" name="a300a35a4e10c61d1b109ae10f46939b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300a35a4e10c61d1b109ae10f46939b9">&#9670;&#160;</a></span>mkernel_clear_undo_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_clear_undo_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the undo state for all mesh kernel ids, no undo is possible after this. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aeb8f7b19c80078a6bd41e0676e3a0910" name="aeb8f7b19c80078a6bd41e0676e3a0910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8f7b19c80078a6bd41e0676e3a0910">&#9670;&#160;</a></span>mkernel_clear_undo_state_for_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_clear_undo_state_for_id </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the undo state for particular mesh kernel id, no undo for the id is possible after this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a23418612b67e544a81b53b49da588b8c" name="a23418612b67e544a81b53b49da588b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23418612b67e544a81b53b49da588b8c">&#9670;&#160;</a></span>mkernel_contacts_compute_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_compute_boundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a4ec01984b66446a3db7cd48de077e5df" title="Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_m...">meshkernel::Contacts::ComputeBoundaryContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = generate a connection, 0 = do not generate a connection) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The points selecting the faces to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The radius used for searching neighboring faces, if equal to constants::missing::doubleValue, the search radius will be calculated internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac667f8bfc3d51f8150d1c01476b7a724" name="ac667f8bfc3d51f8150d1c01476b7a724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667f8bfc3d51f8150d1c01476b7a724">&#9670;&#160;</a></span>mkernel_contacts_compute_multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_compute_multiple </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a7f91875d5a0da23ffbb679e428aa94a3" title="Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_...">meshkernel::Contacts::ComputeMultipleContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = generate a connection, 0 = do not generate a connection) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ab85a128cb85ceb3ad6af908c18e9c5ee" name="ab85a128cb85ceb3ad6af908c18e9c5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85a128cb85ceb3ad6af908c18e9c5ee">&#9670;&#160;</a></span>mkernel_contacts_compute_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_compute_single </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projectionFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where each single 1d node is connected to one mesh2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a70433c574488cf7db9600e63f9c37f5e" title="Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_ma...">meshkernel::Contacts::ComputeSingleContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not connect) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons selecting the area where the 1d-2d contacts will be generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectionFactor</td><td>The projection factor used for generating links when 1d nodes are not inside mesh2d </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9b5ad63d129f4cabde4ba06a663436e5" name="a9b5ad63d129f4cabde4ba06a663436e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5ad63d129f4cabde4ba06a663436e5">&#9670;&#160;</a></span>mkernel_contacts_compute_with_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_compute_with_points </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#acf4f82c10642d3e8b2d9e8bab6b07006" title="Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the inp...">meshkernel::Contacts::ComputeContactsWithPoints</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = generate a connection, 0 = do not generate a connection) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The points selecting the faces to connect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9defc8833031f7c5d24fcbd7b0b3f17e" name="a9defc8833031f7c5d24fcbd7b0b3f17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9defc8833031f7c5d24fcbd7b0b3f17e">&#9670;&#160;</a></span>mkernel_contacts_compute_with_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_compute_with_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a198d5ed49e69fcf8700ce9cf34b4f081" title="Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D...">meshkernel::Contacts::ComputeContactsWithPolygons</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = generate a connection, 0 = do not generate a connection) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons to connect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac3b3e7255f0763e4d904de90e58b510b" name="ac3b3e7255f0763e4d904de90e58b510b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b3e7255f0763e4d904de90e58b510b">&#9670;&#160;</a></span>mkernel_contacts_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_get_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the 1d-2d contacts indices (from index / to indices) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contacts</td><td><a class="el" href="structmeshkernelapi_1_1_contacts.html" title="A struct used to describe contacts between a 1d and a 2d mesh.">Contacts</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a76f74ded5da96ab12bd145e907f6ccd9" name="a76f74ded5da96ab12bd145e907f6ccd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f74ded5da96ab12bd145e907f6ccd9">&#9670;&#160;</a></span>mkernel_contacts_get_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_get_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of 1d-2d contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contacts</td><td><a class="el" href="structmeshkernelapi_1_1_contacts.html" title="A struct used to describe contacts between a 1d and a 2d mesh.">Contacts</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="abf0c92956bf8370a1fb79f3d07ca711e" name="abf0c92956bf8370a1fb79f3d07ca711e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c92956bf8370a1fb79f3d07ca711e">&#9670;&#160;</a></span>mkernel_contacts_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_contacts_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the 1d-2d contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contacts</td><td><a class="el" href="structmeshkernelapi_1_1_contacts.html" title="A struct used to describe contacts between a 1d and a 2d mesh.">Contacts</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1489f182a98483291e002a463576f108" name="a1489f182a98483291e002a463576f108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1489f182a98483291e002a463576f108">&#9670;&#160;</a></span>mkernel_curvilinear_compute_circular_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_circular_grid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a rectangular or circular curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The structure containing the make grid parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="addf56f8ac784e53c26207dcc7c450b36" name="addf56f8ac784e53c26207dcc7c450b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf56f8ac784e53c26207dcc7c450b36">&#9670;&#160;</a></span>mkernel_curvilinear_compute_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_curvature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>curvature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curvature of a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>The direction in which to compute the curvature </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvature</td><td>The grid curvature values in the selected direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a53496b0bd662667221bdd981ccaed584" name="a53496b0bd662667221bdd981ccaed584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53496b0bd662667221bdd981ccaed584">&#9670;&#160;</a></span>mkernel_curvilinear_compute_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates curvilinear grid from splines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The input splines corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The input parameters to generate the curvilinear grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a2f2656f8f1ebfbbc3d8086e17310b924" name="a2f2656f8f1ebfbbc3d8086e17310b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2656f8f1ebfbbc3d8086e17310b924">&#9670;&#160;</a></span>mkernel_curvilinear_compute_orthogonal_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_orthogonal_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_splines_to_curvilinear_parameters.html">meshkernel::SplinesToCurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>splinesToCurvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates curvilinear grid from splines with the advancing front method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The input splines corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The input parameters to generate the curvilinear grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splinesToCurvilinearParameters</td><td>The parameters of the advancing front algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa512f0ec6c1a77978a75c91515723427" name="aa512f0ec6c1a77978a75c91515723427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512f0ec6c1a77978a75c91515723427">&#9670;&#160;</a></span>mkernel_curvilinear_compute_rectangular_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_rectangular_grid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a rectangular curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a65aa51060e729e70bc0a309d70c83188" name="a65aa51060e729e70bc0a309d70c83188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65aa51060e729e70bc0a309d70c83188">&#9670;&#160;</a></span>mkernel_curvilinear_compute_rectangular_grid_from_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_rectangular_grid_from_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a rectangular curvilinear grid from polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The polygons to account for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a2caa5ca4316f35e6fe4c5757f8a75589" name="a2caa5ca4316f35e6fe4c5757f8a75589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caa5ca4316f35e6fe4c5757f8a75589">&#9670;&#160;</a></span>mkernel_curvilinear_compute_rectangular_grid_on_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_rectangular_grid_on_extension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a rectangular curvilinear grid on a defined extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a55ac58ccc4d78dd7073399ea61e777e9" name="a55ac58ccc4d78dd7073399ea61e777e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ac58ccc4d78dd7073399ea61e777e9">&#9670;&#160;</a></span>mkernel_curvilinear_compute_smoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_smoothness </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>smoothness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the smoothness of a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>The direction in which to compute the smoothness </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">smoothness</td><td>The grid smoothness values in the selected direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acf779508dd21bfb7f0d261af7ddffa27" name="acf779508dd21bfb7f0d261af7ddffa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf779508dd21bfb7f0d261af7ddffa27">&#9670;&#160;</a></span>mkernel_curvilinear_compute_transfinite_from_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_transfinite_from_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thirdNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>useFourthSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a curvilinear grid in a polygon. 3 separate polygon nodes need to be selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The first selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The second selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdNode</td><td>The third selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFourthSide</td><td>Use the fourth polygon side to compute the curvilinear grid (0 no, 1 yes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ab8c3780512c9d4271e04741cc485d828" name="ab8c3780512c9d4271e04741cc485d828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c3780512c9d4271e04741cc485d828">&#9670;&#160;</a></span>mkernel_curvilinear_compute_transfinite_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_transfinite_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates curvilinear grid from splines with transfinite interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splines</td><td>The splines to use for curvilinear grid generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The curvilinear parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a96a116ed7b36b018f8f2e3de5438bb97" name="a96a116ed7b36b018f8f2e3de5438bb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a116ed7b36b018f8f2e3de5438bb97">&#9670;&#160;</a></span>mkernel_curvilinear_compute_transfinite_from_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_compute_transfinite_from_triangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thirdNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a curvilinear grid in a triangle. 3 separate polygon nodes need to be selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The first selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The second selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdNode</td><td>The third node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae97ff97512d0d44db769f0d317473f5b" name="ae97ff97512d0d44db769f0d317473f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97ff97512d0d44db769f0d317473f5b">&#9670;&#160;</a></span>mkernel_curvilinear_count_boundaries_as_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_count_boundaries_as_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerLeftN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerLeftM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperRightN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperRightM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of nodes in curvilinear grid boundary polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftN</td><td>The n index of the lower left corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftM</td><td>The m index of the lower left corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightN</td><td>The n index of the upper right corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightM</td><td>The m index of the upper right corner </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of polygon nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refined boundary polygon values are cached, so that they can be copied </dd></dl>

</div>
</div>
<a id="a9fd10e0beda7681e4577da06e1b1dd48" name="a9fd10e0beda7681e4577da06e1b1dd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd10e0beda7681e4577da06e1b1dd48">&#9670;&#160;</a></span>mkernel_curvilinear_delete_exterior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_delete_exterior </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the exterior part of a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The bounding box defining the block to keep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a96ec15d80f7c46e3b9ee0558e968516d" name="a96ec15d80f7c46e3b9ee0558e968516d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ec15d80f7c46e3b9ee0558e968516d">&#9670;&#160;</a></span>mkernel_curvilinear_delete_interior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_delete_interior </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the interior part of a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The bounding box defining the block to keep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8828c734b99cf7e4a75065b93750e7c3" name="a8828c734b99cf7e4a75065b93750e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8828c734b99cf7e4a75065b93750e7c3">&#9670;&#160;</a></span>mkernel_curvilinear_delete_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_delete_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xPointCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yPointCoordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the node closest to a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPointCoordinate</td><td>The x coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPointCoordinate</td><td>The y coordinate of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae4058e2207ebb8a74b5f80024a02e888" name="ae4058e2207ebb8a74b5f80024a02e888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4058e2207ebb8a74b5f80024a02e888">&#9670;&#160;</a></span>mkernel_curvilinear_delete_orthogonal_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_delete_orthogonal_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes curvilinear grid from splines algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a6de2ba28c078686437dce5b9fe5a3d82" name="a6de2ba28c078686437dce5b9fe5a3d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de2ba28c078686437dce5b9fe5a3d82">&#9670;&#160;</a></span>mkernel_curvilinear_derefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_derefine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directional curvilinear grid de-refinement. Grid lines are removed perpendicularly to the segment defined by lowerLeftCorner and xUpperRightCorner. </p>
<p><code>firstPoint</code> and <code>secondPoint</code> must lie on the same grid line. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block to de-refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block to de-refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block to de-refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block to de-refine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9fc4804f0c3e0d14b9ea7e9d217081d6" name="a9fc4804f0c3e0d14b9ea7e9d217081d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc4804f0c3e0d14b9ea7e9d217081d6">&#9670;&#160;</a></span>mkernel_curvilinear_finalize_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_finalize_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the instance of the line shift algorithm in <a class="el" href="structmeshkernelapi_1_1_mesh_kernel_state.html" title="The class holding the state of the C API library.">MeshKernelState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a2ddb979ccad2937a9a0f7793992f1bec" name="a2ddb979ccad2937a9a0f7793992f1bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddb979ccad2937a9a0f7793992f1bec">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_line_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_line_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xSecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ySecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>frozenLineId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new frozen line in the meshkernel state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFirstGridLineNode</td><td>The x coordinate of the first point of the line to freeze </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFirstGridLineNode</td><td>The y coordinate of the first point of the line to freeze </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSecondGridLineNode</td><td>The x coordinate of the second point of the line to freeze </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySecondGridLineNode</td><td>The y coordinate of the second point of the line to freeze </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frozenLineId</td><td>The frozen line id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad4d69fa7859cf8db64e927ee80c05d80" name="ad4d69fa7859cf8db64e927ee80c05d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d69fa7859cf8db64e927ee80c05d80">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_line_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_line_delete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frozenLineId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an existing frozen line in the meshkernel state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frozenLineId</td><td>The id of the frozen line to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae2617d6cdc2cbf622be13e30d4fdc7f1" name="ae2617d6cdc2cbf622be13e30d4fdc7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2617d6cdc2cbf622be13e30d4fdc7f1">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_line_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_line_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frozenLineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xFirstFrozenLineCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yFirstFrozenLineCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xSecondFrozenLineCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ySecondFrozenLineCoordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new frozen line in the meshkernel state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frozenLineId</td><td>The frozen line id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xFirstFrozenLineCoordinate</td><td>The x coordinate of the first point of the frozen line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yFirstFrozenLineCoordinate</td><td>The y coordinate of the first point of the frozen line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xSecondFrozenLineCoordinate</td><td>The x coordinate of the second point of the frozen line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ySecondFrozenLineCoordinate</td><td>The y coordinate of the second point of the frozen line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa7c77901337c6337a9854028135cc0ad" name="aa7c77901337c6337a9854028135cc0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c77901337c6337a9854028135cc0ad">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_line_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_line_is_valid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frozenLineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a curvilinear frozen line is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frozenLineId</td><td>The id of the frozen line to delete </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isValid</td><td>0 if valid, 0 otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad91be30c89a92e5849844512d7fe13bf" name="ad91be30c89a92e5849844512d7fe13bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91be30c89a92e5849844512d7fe13bf">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_lines_get_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_lines_get_count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numFrozenLines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of stored frozen lines in the meshkernel state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numFrozenLines</td><td>The number of stored frozen lines in the meshkernel state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="abef3cd4e875b3dd013795c13805d11dd" name="abef3cd4e875b3dd013795c13805d11dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef3cd4e875b3dd013795c13805d11dd">&#9670;&#160;</a></span>mkernel_curvilinear_frozen_lines_get_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_frozen_lines_get_ids </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frozenLinesIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ids of the frozen lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frozenLinesIds</td><td>The frozen lines ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aff8d08c9fd622e708b148018b333a084" name="aff8d08c9fd622e708b148018b333a084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d08c9fd622e708b148018b333a084">&#9670;&#160;</a></span>mkernel_curvilinear_full_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_full_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mRefinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRefinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curvilinear grid refinement. Additional gridlines are added in both directions, over the entire grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mRefinement</td><td>The amount of refinement to compute in m-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nRefinement</td><td>The amount of refinement to compute in n-direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a373ebc3a04b5c89ab016a0fc2f8d03d5" name="a373ebc3a04b5c89ab016a0fc2f8d03d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373ebc3a04b5c89ab016a0fc2f8d03d5">&#9670;&#160;</a></span>mkernel_curvilinear_get_boundaries_as_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_get_boundaries_as_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerLeftN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerLeftM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperRightN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperRightM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>boundaryPolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary polygon of a curvilinear grid, nodes with invalid coordinates are excluded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftN</td><td>The n index of the lower left corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftM</td><td>The m index of the lower left corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightN</td><td>The n index of the upper right corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightM</td><td>The m index of the upper right corner </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundaryPolygons</td><td>The geometry list containing the boundary polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values are retrieved from the cache, cached values are deleted after copying </dd></dl>

</div>
</div>
<a id="a677b6613ca808dd8bfd900532cfbe930" name="a677b6613ca808dd8bfd900532cfbe930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677b6613ca808dd8bfd900532cfbe930">&#9670;&#160;</a></span>mkernel_curvilinear_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_get_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the curvilinear grid data as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes) </p>
<p>This function ought to be called after <code>mkernel_get_curvilinear_dimension</code> has been called and the pointers have been set to correctly sized memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvilinearGrid</td><td>The structure containing the curvilinear grid arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a82506e242e61fa0a70d63e669a936d67" name="a82506e242e61fa0a70d63e669a936d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82506e242e61fa0a70d63e669a936d67">&#9670;&#160;</a></span>mkernel_curvilinear_get_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_get_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the curvilinear grid dimensions as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes). </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_curvilinear_get_data</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvilinearGrid</td><td>The structure containing the dimensions of the curvilinear grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0f93061a0c885e18b266968ebf45e69e" name="a0f93061a0c885e18b266968ebf45e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f93061a0c885e18b266968ebf45e69e">&#9670;&#160;</a></span>mkernel_curvilinear_get_location_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_get_location_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>locationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the grid location closet to a specific coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The input xCoordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The input yCoordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The input bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">locationIndex</td><td>The location index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a613dd90bec5a91a28dee0d31788401a7" name="a613dd90bec5a91a28dee0d31788401a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613dd90bec5a91a28dee0d31788401a7">&#9670;&#160;</a></span>mkernel_curvilinear_initialize_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_initialize_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the curvilinear line shift algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a19cfc55175164aeeca32ef07b17fc1a5" name="a19cfc55175164aeeca32ef07b17fc1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cfc55175164aeeca32ef07b17fc1a5">&#9670;&#160;</a></span>mkernel_curvilinear_initialize_orthogonal_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_initialize_orthogonal_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_curvilinear_parameters.html">meshkernel::CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_splines_to_curvilinear_parameters.html">meshkernel::SplinesToCurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>splinesToCurvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a curvilinear grid from splines with the advancing front method. Initialization step (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The input splines corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The input parameters to generate the curvilinear grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splinesToCurvilinearParameters</td><td>The parameters of the advancing front algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1cd685105dd6d04a35ddad5e013cdef4" name="a1cd685105dd6d04a35ddad5e013cdef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd685105dd6d04a35ddad5e013cdef4">&#9670;&#160;</a></span>mkernel_curvilinear_insert_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_insert_face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new face on a curvilinear grid. The new face will be inserted on top of the closest edge by linear extrapolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The x coordinate of the point used for finding the closest face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The y coordinate of the point used for finding the closest face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8c46ebeb6dd10a6080eec66360eab373" name="a8c46ebeb6dd10a6080eec66360eab373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c46ebeb6dd10a6080eec66360eab373">&#9670;&#160;</a></span>mkernel_curvilinear_iterate_orthogonal_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_iterate_orthogonal_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One advancement of the front in curvilinear grid from splines (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>The layer index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a5727bee8dd3366d7915e3f80c684e518" name="a5727bee8dd3366d7915e3f80c684e518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5727bee8dd3366d7915e3f80c684e518">&#9670;&#160;</a></span>mkernel_curvilinear_line_attraction_repulsion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_line_attraction_repulsion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>repulsionParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFirstNodeOnTheLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFirstNodeOnTheLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xSecondNodeOnTheLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ySecondNodeOnTheLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attracts/repulses grid lines in a block towards another set grid line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repulsionParameter</td><td>The attraction/repulsion parameter. If positive the grid lines will be attracted towards the set line, if negative the lines will be repulsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFirstNodeOnTheLine</td><td>The x coordinate of the first node of the set line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFirstNodeOnTheLine</td><td>The y coordinate of the first node of the set line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSecondNodeOnTheLine</td><td>The x coordinate of the second node of the set line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySecondNodeOnTheLine</td><td>The y coordinate of the second node of the set line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block where the operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block where the operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block where the operation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block where the operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa55a4a01c4325f46d98254fbf6ccbc32" name="aa55a4a01c4325f46d98254fbf6ccbc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a4a01c4325f46d98254fbf6ccbc32">&#9670;&#160;</a></span>mkernel_curvilinear_line_mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_line_mirror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mirroringFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xSecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ySecondGridLineNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mirrors a boundary gridline outwards. The boundary grid line is defined by its starting and ending points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirroringFactor</td><td>The mirroring factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFirstGridLineNode</td><td>The x coordinate of the first grid line point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFirstGridLineNode</td><td>The y coordinate of the first grid line point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSecondGridLineNode</td><td>The x coordinate of the second grid line point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySecondGridLineNode</td><td>The y coordinate of the second grid line point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad4cf4944145f3981e711822151ffdeac" name="ad4cf4944145f3981e711822151ffdeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cf4944145f3981e711822151ffdeac">&#9670;&#160;</a></span>mkernel_curvilinear_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the new grid, shifting the line towards the moved nodes and distributing the shifting in block specified before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ab538a45d6469d77c2c1dc925a9fcb446" name="ab538a45d6469d77c2c1dc925a9fcb446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab538a45d6469d77c2c1dc925a9fcb446">&#9670;&#160;</a></span>mkernel_curvilinear_move_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_move_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFromPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFromPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xToPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yToPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a point of a curvilinear grid from one location to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFromPoint</td><td>The x coordinate of point to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFromPoint</td><td>The y coordinate of point to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xToPoint</td><td>The new x coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yToPoint</td><td>The new y coordinate of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a6dadaf06c429d8c30f962d672b72c1bb" name="a6dadaf06c429d8c30f962d672b72c1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dadaf06c429d8c30f962d672b72c1bb">&#9670;&#160;</a></span>mkernel_curvilinear_move_node_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_move_node_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFromCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFromCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xToCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yToCoordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a node of the line to shift, the operation can be performed multiple times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFromCoordinate</td><td>The x coordinate of the node to move (the closest curvilinear grid node will be found) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFromCoordinate</td><td>The y coordinate of the node to move (the closest curvilinear grid node will be found) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xToCoordinate</td><td>The x coordinate of the new node position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yToCoordinate</td><td>The y coordinate of the new node position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a19debeee68b71cf42a0ee4405b72c835" name="a19debeee68b71cf42a0ee4405b72c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19debeee68b71cf42a0ee4405b72c835">&#9670;&#160;</a></span>mkernel_curvilinear_orthogonalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_orthogonalize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a block on the curvilinear grid where to perform orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The orthogonalization parameters to use in the algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block to orthogonalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block to orthogonalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block to orthogonalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block to orthogonalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a958ee3292784ee27c9d4c09adb0e2fb4" name="a958ee3292784ee27c9d4c09adb0e2fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958ee3292784ee27c9d4c09adb0e2fb4">&#9670;&#160;</a></span>mkernel_curvilinear_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directional curvilinear grid refinement. Additional gridlines are added perpendicularly to the segment defined by lowerLeftCorner and xUpperRightCorner. </p>
<p><code>firstPoint</code> and <code>secondPoint</code> must lie on the same grid line. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refinement</td><td>The number of grid lines to add between <code>firstPoint</code> and <code>secondPoint</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac5018cc5b18f40820c127929506cdfab" name="ac5018cc5b18f40820c127929506cdfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5018cc5b18f40820c127929506cdfab">&#9670;&#160;</a></span>mkernel_curvilinear_refresh_orthogonal_grid_from_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_refresh_orthogonal_grid_from_splines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts curvilinear grid to mesh and refreshes the state (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acf2242c66cb341c465f9f9a38e9379d9" name="acf2242c66cb341c465f9f9a38e9379d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2242c66cb341c465f9f9a38e9379d9">&#9670;&#160;</a></span>mkernel_curvilinear_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The curvilinear grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9bc5a4f9bf16b91caf138adaf2265040" name="a9bc5a4f9bf16b91caf138adaf2265040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc5a4f9bf16b91caf138adaf2265040">&#9670;&#160;</a></span>mkernel_curvilinear_set_block_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_set_block_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a block on the curvilinear where the shifting is distributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4a7dc0445883bf597840da83c47babc1" name="a4a7dc0445883bf597840da83c47babc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7dc0445883bf597840da83c47babc1">&#9670;&#160;</a></span>mkernel_curvilinear_set_line_line_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_set_line_line_shift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFirstGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xSecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ySecondGridLineNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the start and end nodes of the line to shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFirstGridLineNode</td><td>The x coordinate of the first curvilinear grid node to shift </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFirstGridLineNode</td><td>The y coordinate of the first curvilinear grid node to shift </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSecondGridLineNode</td><td>The x coordinate of the second curvilinear grid node to shift </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySecondGridLineNode</td><td>The y coordinate of the second curvilinear grid node to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="afc299ba69473ad8e3e16edd7b79ec196" name="afc299ba69473ad8e3e16edd7b79ec196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc299ba69473ad8e3e16edd7b79ec196">&#9670;&#160;</a></span>mkernel_curvilinear_smoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_smoothing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothingIterations</td><td>The number of smoothing iterations to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCorner</td><td>The x coordinate of the lower left corner of the block to smooth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCorner</td><td>The y coordinate of the lower left corner of the block to smooth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCorner</td><td>The x coordinate of the upper right corner of the block to smooth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCorner</td><td>The y coordinate of the upper right corner of the block to smooth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad19958bebc2ca018eca5e3da034deb0c" name="ad19958bebc2ca018eca5e3da034deb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19958bebc2ca018eca5e3da034deb0c">&#9670;&#160;</a></span>mkernel_curvilinear_smoothing_directional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_smoothing_directional </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFirstGridlineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yFirstGridlineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xSecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ySecondGridLineNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftCornerSmoothingArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftCornerSmoothingArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightCornerSmootingArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightCornerSmootingArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths a curvilinear grid along the direction specified by a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothingIterations</td><td>The number of smoothing iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFirstGridlineNode</td><td>The x coordinate of the first curvilinear grid node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yFirstGridlineNode</td><td>The y coordinate of the first curvilinear grid node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSecondGridLineNode</td><td>The x coordinate of the second curvilinear grid node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySecondGridLineNode</td><td>The y coordinate of the second curvilinear grid node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftCornerSmoothingArea</td><td>The x coordinate of the lower left corner of the smoothing area </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftCornerSmoothingArea</td><td>The y coordinate of the lower left corner of the smoothing area </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightCornerSmootingArea</td><td>The x coordinate of the upper right corner of the smoothing area </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightCornerSmootingArea</td><td>The y coordinate of the upper right corner of the smoothing area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a91770126953a7fe176cce86c51aba5c7" name="a91770126953a7fe176cce86c51aba5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91770126953a7fe176cce86c51aba5c7">&#9670;&#160;</a></span>mkernel_curvilinear_snap_to_landboundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_snap_to_landboundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>land</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint1x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint1y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint2x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint2y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>regionControlPointX</em> = <code><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>regionControlPointY</em> = <code><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">land</td><td>The land boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint1x</td><td>Start point x-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint1y</td><td>Start point y-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint2x</td><td>End point x-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint2y</td><td>End point y-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionControlPointX</td><td>X-coordinate of region defining point, if null value then use default region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionControlPointY</td><td>Y-coordinate of region defining point, if null value then use default region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a41794e15c663467d71e75c78fa30dd26" name="a41794e15c663467d71e75c78fa30dd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41794e15c663467d71e75c78fa30dd26">&#9670;&#160;</a></span>mkernel_curvilinear_snap_to_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_curvilinear_snap_to_spline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>spline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint1x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint1y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint2x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sectionControlPoint2y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>regionControlPointX</em> = <code><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>regionControlPointY</em> = <code><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline</td><td>The spline </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint1x</td><td>Start point x-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint1y</td><td>Start point y-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint2x</td><td>End point x-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sectionControlPoint2y</td><td>End point y-coordinate for boundary section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionControlPointX</td><td>X-coordinate of region defining point, if null value then use default region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionControlPointY</td><td>Y-coordinate of region defining point, if null value then use default region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a54655bc724e99cb7447d35743525f12a" name="a54655bc724e99cb7447d35743525f12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54655bc724e99cb7447d35743525f12a">&#9670;&#160;</a></span>mkernel_deallocate_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_deallocate_property </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate property calculator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyId</td><td>The id of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a57d1b16ba8121e1f11b1692b755647c3" name="a57d1b16ba8121e1f11b1692b755647c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d1b16ba8121e1f11b1692b755647c3">&#9670;&#160;</a></span>mkernel_deallocate_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_deallocate_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate mesh state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a01e91a7f466943f63bea081be84e2eab" name="a01e91a7f466943f63bea081be84e2eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e91a7f466943f63bea081be84e2eab">&#9670;&#160;</a></span>mkernel_expunge_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_expunge_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate mesh state and remove it completely, no undo for this meshKernelId will be possible after expunging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a61c310189351a979c7f2b170802e5fa3" name="a61c310189351a979c7f2b170802e5fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c310189351a979c7f2b170802e5fa3">&#9670;&#160;</a></span>mkernel_get_averaging_method_closest_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_closest_point </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the closest point averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the closest point averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a5c993627e89f487a8ebf84882689c530" name="a5c993627e89f487a8ebf84882689c530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c993627e89f487a8ebf84882689c530">&#9670;&#160;</a></span>mkernel_get_averaging_method_inverse_distance_weighting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_inverse_distance_weighting </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the inverse distance weights averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the inverse weight distance averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aebd755a42334c133d093230297814729" name="aebd755a42334c133d093230297814729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd755a42334c133d093230297814729">&#9670;&#160;</a></span>mkernel_get_averaging_method_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_max </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the max value averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the max value averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9fb82e72f98299ebb56b5c9dd3402dc7" name="a9fb82e72f98299ebb56b5c9dd3402dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb82e72f98299ebb56b5c9dd3402dc7">&#9670;&#160;</a></span>mkernel_get_averaging_method_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_min </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the minimum averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the minimum averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0c609b8166a7bb1f1eefc8e70895e201" name="a0c609b8166a7bb1f1eefc8e70895e201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c609b8166a7bb1f1eefc8e70895e201">&#9670;&#160;</a></span>mkernel_get_averaging_method_min_absolute_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_min_absolute_value </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the minimum absolute value averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the minimum absolute value averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac49825ed2de2cecdd6d38e0eb5d87620" name="ac49825ed2de2cecdd6d38e0eb5d87620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49825ed2de2cecdd6d38e0eb5d87620">&#9670;&#160;</a></span>mkernel_get_averaging_method_simple_averaging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_averaging_method_simple_averaging </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the simple averaging method type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>The int indicating the averaging method type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae81c2fed7f95e682ce599388d92c90f3" name="ae81c2fed7f95e682ce599388d92c90f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81c2fed7f95e682ce599388d92c90f3">&#9670;&#160;</a></span>mkernel_get_edges_location_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_edges_location_type </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the edge location type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The int indicating the edge location type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="afd3865787c434f2912debb2a89ecd01b" name="afd3865787c434f2912debb2a89ecd01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3865787c434f2912debb2a89ecd01b">&#9670;&#160;</a></span>mkernel_get_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_error </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errorMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errorMessage</td><td>The pointer to the latest error message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a6cfd7f5c68ec2bd2d1211ef3701609a4" name="a6cfd7f5c68ec2bd2d1211ef3701609a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfd7f5c68ec2bd2d1211ef3701609a4">&#9670;&#160;</a></span>mkernel_get_exit_code_algorithm_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_algorithm_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type AlgorithmexitCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a79705a28cb51da36e8f3261ffb10b7a2" name="a79705a28cb51da36e8f3261ffb10b7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79705a28cb51da36e8f3261ffb10b7a2">&#9670;&#160;</a></span>mkernel_get_exit_code_constraint_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_constraint_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type ConstraintexitCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad9d25d4fe41dcd38ac065e09eef03bbf" name="ad9d25d4fe41dcd38ac065e09eef03bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d25d4fe41dcd38ac065e09eef03bbf">&#9670;&#160;</a></span>mkernel_get_exit_code_linear_algebra_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_linear_algebra_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type LinearAlgebraexitCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3b752932fccfe496950396dc9a12e14c" name="a3b752932fccfe496950396dc9a12e14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b752932fccfe496950396dc9a12e14c">&#9670;&#160;</a></span>mkernel_get_exit_code_mesh_geometry_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_mesh_geometry_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type MeshGeometryexitCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ade49c422f668c8bdc3cf3f1b0d87bb3d" name="ade49c422f668c8bdc3cf3f1b0d87bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade49c422f668c8bdc3cf3f1b0d87bb3d">&#9670;&#160;</a></span>mkernel_get_exit_code_meshkernel_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_meshkernel_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type MeshKernelError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad3b55f1ae4b2476952a411371a317e66" name="ad3b55f1ae4b2476952a411371a317e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b55f1ae4b2476952a411371a317e66">&#9670;&#160;</a></span>mkernel_get_exit_code_not_implemented_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_not_implemented_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type NotImplementedCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a87c81a4213151e86019c6fd1fd7b6dee" name="a87c81a4213151e86019c6fd1fd7b6dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c81a4213151e86019c6fd1fd7b6dee">&#9670;&#160;</a></span>mkernel_get_exit_code_range_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_range_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type RangeexitCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4c2feb0a374dffb49ee3933710771753" name="a4c2feb0a374dffb49ee3933710771753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2feb0a374dffb49ee3933710771753">&#9670;&#160;</a></span>mkernel_get_exit_code_stdlib_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_stdlib_exception </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of type std::exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="adaf3b994bcbc9a005829b0630e50cec3" name="adaf3b994bcbc9a005829b0630e50cec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf3b994bcbc9a005829b0630e50cec3">&#9670;&#160;</a></span>mkernel_get_exit_code_success()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_success </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the success exit code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="afb37d92deca9c48ad10b8f3c1b055486" name="afb37d92deca9c48ad10b8f3c1b055486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb37d92deca9c48ad10b8f3c1b055486">&#9670;&#160;</a></span>mkernel_get_exit_code_unknown_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_exit_code_unknown_exception </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the exit code of an exception of unknown type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exitCode</td><td>The exit code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ab54964b1b218346c7bc7830ebec339b7" name="ab54964b1b218346c7bc7830ebec339b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54964b1b218346c7bc7830ebec339b7">&#9670;&#160;</a></span>mkernel_get_faces_location_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_faces_location_type </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the faces location type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The int indicating the face location type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a60110d717bc03445222a06bc765ef4f4" name="a60110d717bc03445222a06bc765ef4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60110d717bc03445222a06bc765ef4f4">&#9670;&#160;</a></span>mkernel_get_geometry_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_geometry_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>invalidIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index of the erroneous entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">invalidIndex</td><td>The index of the erroneous entity </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The entity type (node, edge or face, see MeshLocations) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a329b68c1ddf16b487d2954b65481e3c4" name="a329b68c1ddf16b487d2954b65481e3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329b68c1ddf16b487d2954b65481e3c4">&#9670;&#160;</a></span>mkernel_get_inner_outer_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API double meshkernelapi::mkernel_get_inner_outer_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the double value used to separate the inner part of a polygon from its outer part. </p>
<dl class="section return"><dt>Returns</dt><dd>The double missing value used in mesh kernel </dd></dl>

</div>
</div>
<a id="a9230ee8561e4626c030364b4c246b8b8" name="a9230ee8561e4626c030364b4c246b8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9230ee8561e4626c030364b4c246b8b8">&#9670;&#160;</a></span>mkernel_get_interpolation_type_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_interpolation_type_double </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer indicating the interpolation type double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The integer indicating the interpolation type double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a34bcbba1436c83eb69275f056bb9504c" name="a34bcbba1436c83eb69275f056bb9504c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bcbba1436c83eb69275f056bb9504c">&#9670;&#160;</a></span>mkernel_get_interpolation_type_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_interpolation_type_float </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer indicating the interpolation type float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The integer indicating the interpolation type float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a7542a9206d51414d3992b17e29a6d220" name="a7542a9206d51414d3992b17e29a6d220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7542a9206d51414d3992b17e29a6d220">&#9670;&#160;</a></span>mkernel_get_interpolation_type_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_interpolation_type_int </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer indicating the interpolation type int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The integer indicating the interpolation type int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0acc9b103eee667d7c83b375be9d664d" name="a0acc9b103eee667d7c83b375be9d664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acc9b103eee667d7c83b375be9d664d">&#9670;&#160;</a></span>mkernel_get_interpolation_type_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_interpolation_type_short </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer indicating the interpolation type short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The integer indicating the interpolation type short </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a78fc6f05ef419a0e88293a93e6c9f266" name="a78fc6f05ef419a0e88293a93e6c9f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fc6f05ef419a0e88293a93e6c9f266">&#9670;&#160;</a></span>mkernel_get_nodes_location_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_nodes_location_type </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the node location type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The int indicating the node location type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae6a3ee15c254830a4cbbc717f679c595" name="ae6a3ee15c254830a4cbbc717f679c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a3ee15c254830a4cbbc717f679c595">&#9670;&#160;</a></span>mkernel_get_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_projection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the coordinate projection of the meshkernel state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projection</td><td>The int indicating the projection type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a24b5723e697138e4f4c0cd89fd7c7016" name="a24b5723e697138e4f4c0cd89fd7c7016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b5723e697138e4f4c0cd89fd7c7016">&#9670;&#160;</a></span>mkernel_get_projection_cartesian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_projection_cartesian </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the cartesian projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">projection</td><td>The int indicating the cartesian projection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a80f8539ad3c24315bb99e9f8a9605276" name="a80f8539ad3c24315bb99e9f8a9605276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f8539ad3c24315bb99e9f8a9605276">&#9670;&#160;</a></span>mkernel_get_projection_spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_projection_spherical </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the spherical projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">projection</td><td>The int indicating the spherical projection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a48a895fc8ca2c9520a0604deffe4692c" name="a48a895fc8ca2c9520a0604deffe4692c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a895fc8ca2c9520a0604deffe4692c">&#9670;&#160;</a></span>mkernel_get_projection_spherical_accurate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_projection_spherical_accurate </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the spherical accurate projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">projection</td><td>The int indicating the spherical accurate projection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0fa4028baafe51cdd5e87fe898b4a426" name="a0fa4028baafe51cdd5e87fe898b4a426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa4028baafe51cdd5e87fe898b4a426">&#9670;&#160;</a></span>mkernel_get_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API double meshkernelapi::mkernel_get_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the double value used in the back-end library as separator and missing value. </p>
<dl class="section return"><dt>Returns</dt><dd>The double missing value used in mesh kernel </dd></dl>

</div>
</div>
<a id="a11d47258f24cf6884bb39bf648356e08" name="a11d47258f24cf6884bb39bf648356e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d47258f24cf6884bb39bf648356e08">&#9670;&#160;</a></span>mkernel_get_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_splines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfPointsBetweenNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the computed spline points between two corner nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input corner nodes of the splines </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListOut</td><td>The output spline </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPointsBetweenNodes</td><td>The number of spline points to generate between two corner nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4a4271f39ab44e85f1fdefb8c25b9841" name="a4a4271f39ab44e85f1fdefb8c25b9841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4271f39ab44e85f1fdefb8c25b9841">&#9670;&#160;</a></span>mkernel_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_version </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to version string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">version</td><td>Version string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad49b7f49c043fe26218d479d986a4b61" name="ad49b7f49c043fe26218d479d986a4b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b7f49c043fe26218d479d986a4b61">&#9670;&#160;</a></span>mkernel_is_valid_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_is_valid_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the meshKernelId is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isValid</td><td>Indicates if the mesh id is valid, true is its valid, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acc29909e7d7b91c74f3a7218d863bf85" name="acc29909e7d7b91c74f3a7218d863bf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc29909e7d7b91c74f3a7218d863bf85">&#9670;&#160;</a></span>mkernel_mesh1d_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh1d_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a mesh to the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1b222ed081c13ed360c0e04f70b589d6" name="a1b222ed081c13ed360c0e04f70b589d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b222ed081c13ed360c0e04f70b589d6">&#9670;&#160;</a></span>mkernel_mesh1d_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh1d_get_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data. </p>
<p>This function ought to be called after <code>mkernel_mesh1d_get_dimensions</code> has been called and the pointers have been set to correctly sized memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh1d</td><td>The structure containing the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a79454e20b730506c295f9e837b071c4d" name="a79454e20b730506c295f9e837b071c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79454e20b730506c295f9e837b071c4d">&#9670;&#160;</a></span>mkernel_mesh1d_get_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh1d_get_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data dimensions. </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_mesh1d_get_dimensions</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh1d</td><td>The structure containing the dimensions of the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa162a77f3bcde424aa5c900b17b6cd06" name="aa162a77f3bcde424aa5c900b17b6cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa162a77f3bcde424aa5c900b17b6cd06">&#9670;&#160;</a></span>mkernel_mesh1d_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh1d_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aec33ed1cc636956cc68a7c1886447107" name="aec33ed1cc636956cc68a7c1886447107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec33ed1cc636956cc68a7c1886447107">&#9670;&#160;</a></span>mkernel_mesh2d_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a mesh to the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1dc35c8a835d5b362e8782ddc3197349" name="a1dc35c8a835d5b362e8782ddc3197349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc35c8a835d5b362e8782ddc3197349">&#9670;&#160;</a></span>mkernel_mesh2d_averaging_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_averaging_interpolation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>averagingMethodType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relativeSearchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minNumSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AveragingInterpolation interpolation (ec_module) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_averaging_interpolation.html" title="The class used to interpolate based on averaging.">meshkernel::AveragingInterpolation</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples coordinates and values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type (see <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">meshkernel::Location</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">averagingMethodType</td><td>The averaging method (see Method enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeSearchSize</td><td>The relative search size around the location (larger increases the number of samples considered) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minNumSamples</td><td>The minimum number of samples used for some interpolation algorithms to perform a valid interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">results</td><td>The interpolation results with x and y coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8393113961019f6808a7d2ac2355be58" name="a8393113961019f6808a7d2ac2355be58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8393113961019f6808a7d2ac2355be58">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_derefinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_derefinement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-refine mesh using the Casulli de-refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac212a43c6cb87cfed8bf14d681676987" name="ac212a43c6cb87cfed8bf14d681676987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac212a43c6cb87cfed8bf14d681676987">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_derefinement_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_derefinement_elements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of elements that will be removed after the Casulli de-refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>List of elements to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac963dda956a7b00bac1fbc748cc0f309" name="ac963dda956a7b00bac1fbc748cc0f309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac963dda956a7b00bac1fbc748cc0f309">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_derefinement_elements_on_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_derefinement_elements_on_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of elements that will be removed after the Casulli de-refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonGeometry</td><td>The input polygon geometry </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>List of elements to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a393c9e1a49e6d111bf5de0dea8a0f37d" name="a393c9e1a49e6d111bf5de0dea8a0f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393c9e1a49e6d111bf5de0dea8a0f37d">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_derefinement_on_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_derefinement_on_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-refine mesh using the Casulli de-refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a862cbc79bab0e03153797c1e1292de88" name="a862cbc79bab0e03153797c1e1292de88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862cbc79bab0e03153797c1e1292de88">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_refinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_refinement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine mesh using the Casulli refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a70d6d63626c31eb93ebb68f020f563fd" name="a70d6d63626c31eb93ebb68f020f563fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d6d63626c31eb93ebb68f020f563fd">&#9670;&#160;</a></span>mkernel_mesh2d_casulli_refinement_on_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_casulli_refinement_on_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine mesh using the Casulli refinement algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa390097481a2f81487f41c5e46eaaaf6" name="aa390097481a2f81487f41c5e46eaaaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa390097481a2f81487f41c5e46eaaaf6">&#9670;&#160;</a></span>mkernel_mesh2d_compute_inner_ortogonalization_iteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_compute_inner_ortogonalization_iteration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inner orthogonalization iteration, by slowly moving the mesh nodes to new optimal positions (interactive mode). </p>
<p><code>mkernel_mesh2d_prepare_outer_iteration_orthogonalization</code> function must be called before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a156192886c65dcffa89cad36a5c78045" name="a156192886c65dcffa89cad36a5c78045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156192886c65dcffa89cad36a5c78045">&#9670;&#160;</a></span>mkernel_mesh2d_compute_orthogonalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_compute_orthogonalization </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectingPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>landBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function modifies the mesh for achieving orthogonality between the edges and the segments connecting the face circumcenters. The amount of orthogonality is traded against the mesh smoothing (in this case the equality of face areas). The parameter to regulate the amount of orthogonalization is contained in <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html#afbd641160ab86c9f1b0450ce575fae30">meshkernel::OrthogonalizationParameters::orthogonalization_to_smoothing_factor</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryOption</td><td>The option to determine how to snap to land boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The structure containing the orthogonalization parameters <a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selectingPolygon</td><td>The polygon where to perform the orthogonalization (num_coordinates = 0 for an empty polygon) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landBoundaries</td><td>The land boundaries to account for in the orthogonalization process (num_coordinates = 0 for no land boundaries) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acf9d548882516ac652fd0f01a08c88bd" name="acf9d548882516ac652fd0f01a08c88bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d548882516ac652fd0f01a08c88bd">&#9670;&#160;</a></span>mkernel_mesh2d_connect_meshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_connect_meshes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchFraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two or more disconnected regions along boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh states </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The mesh we want to connect to the main mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchFraction</td><td>Fraction of the shortest edge (along an edge to be connected) to use when determining neighbour edge closeness </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8a14647b813f56d13fdfc182a9f95011" name="a8a14647b813f56d13fdfc182a9f95011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a14647b813f56d13fdfc182a9f95011">&#9670;&#160;</a></span>mkernel_mesh2d_convert_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_convert_projection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>zoneString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the projection of a mesh2d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectionType</td><td>The new projection for the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zoneString</td><td>The UTM zone and information string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a76a9720954ca157a1ba2ccfd35bbf183" name="a76a9720954ca157a1ba2ccfd35bbf183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a9720954ca157a1ba2ccfd35bbf183">&#9670;&#160;</a></span>mkernel_mesh2d_convert_to_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_convert_to_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xPointCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yPointCoordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a mesh to a curvilinear mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPointCoordinate</td><td>The x coordinate of the point where to start the conversion point coordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPointCoordinate</td><td>The y point coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a00ba5182f31ea1567bc258bb95cad221" name="a00ba5182f31ea1567bc258bb95cad221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ba5182f31ea1567bc258bb95cad221">&#9670;&#160;</a></span>mkernel_mesh2d_count_hanging_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_count_hanging_edges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of hanging edges in a mesh2d. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEdges</td><td>The number of hanging edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a5b7bcc0a8c5e3af905c124e5778a5960" name="a5b7bcc0a8c5e3af905c124e5778a5960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7bcc0a8c5e3af905c124e5778a5960">&#9670;&#160;</a></span>mkernel_mesh2d_count_mesh_boundaries_as_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_count_mesh_boundaries_as_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of polygon nodes contained in the mesh boundary polygons computed in function <code>mkernel_mesh2d_get_mesh_boundaries_as_polygons</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of polygon nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1ddb0753a28c76813a451f9c5221443e" name="a1ddb0753a28c76813a451f9c5221443e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddb0753a28c76813a451f9c5221443e">&#9670;&#160;</a></span>mkernel_mesh2d_count_nodes_in_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_count_nodes_in_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfMeshNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of selected mesh node indices. </p>
<p>This function should be used by clients before <code>mkernel_mesh2d_get_nodes_in_polygons</code> for allocating an integer array storing the selection results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Selection of the nodes inside the polygon (1) or outside (0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfMeshNodes</td><td>The number of selected nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa79a0bff406cab9545674897ceeaf4af" name="aa79a0bff406cab9545674897ceeaf4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79a0bff406cab9545674897ceeaf4af">&#9670;&#160;</a></span>mkernel_mesh2d_count_obtuse_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_count_obtuse_triangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numObtuseTriangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of obtuse mesh2d triangles. Obtuse triangles are those having one edge longer than the sum of the other two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numObtuseTriangles</td><td>The number of obtuse triangles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4542f019f36e5f06a23f8269e11342af" name="a4542f019f36e5f06a23f8269e11342af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4542f019f36e5f06a23f8269e11342af">&#9670;&#160;</a></span>mkernel_mesh2d_count_small_flow_edge_centers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_count_small_flow_edge_centers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesLengthThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numSmallFlowEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of small mesh2d flow edges. The flow edges are the edges connecting faces circumcenters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesLengthThreshold</td><td>The configurable length for detecting a small flow edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numSmallFlowEdges</td><td>The number of the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ab787ab2087d49d4797e2dbdb3cf5e0ca" name="ab787ab2087d49d4797e2dbdb3cf5e0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab787ab2087d49d4797e2dbdb3cf5e0ca">&#9670;&#160;</a></span>mkernel_mesh2d_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon using several options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">meshkernel::Mesh2D::DeleteMeshOptions</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Whether to invert the deletion of selected features (0 no, 1 yes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0ce1ba846742ee85f26b34c71336ef9b" name="a0ce1ba846742ee85f26b34c71336ef9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce1ba846742ee85f26b34c71336ef9b">&#9670;&#160;</a></span>mkernel_mesh2d_delete_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightBoundingBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the closest mesh2d edge to a point. The coordinates of the edge middle points are used for calculating the distances to the point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The x coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The y coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftBoundingBox</td><td>The x coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftBoundingBox</td><td>The y coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightBoundingBox</td><td>The x coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightBoundingBox</td><td>The y coordinate of the upper right corner of the bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0892a7890e27cd70521af0b86d90407f" name="a0892a7890e27cd70521af0b86d90407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0892a7890e27cd70521af0b86d90407f">&#9670;&#160;</a></span>mkernel_mesh2d_delete_edge_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_edge_by_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh2d edge given the index of the edge. The coordinates of the edge middle points are used for calculating the distances to the point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeIndex</td><td>The index of the edge to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a847e53287a42b4e00385755ba1162e70" name="a847e53287a42b4e00385755ba1162e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847e53287a42b4e00385755ba1162e70">&#9670;&#160;</a></span>mkernel_mesh2d_delete_hanging_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_hanging_edges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all hanging edges. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a2ec2f1082a199322b753b054d226329e" name="a2ec2f1082a199322b753b054d226329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec2f1082a199322b753b054d226329e">&#9670;&#160;</a></span>mkernel_mesh2d_delete_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh2d node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>The index of the node to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a24115f31dde1cfe7e388729dbd23b814" name="a24115f31dde1cfe7e388729dbd23b814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24115f31dde1cfe7e388729dbd23b814">&#9670;&#160;</a></span>mkernel_mesh2d_delete_orthogonalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_orthogonalization </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans the orthogonalization algorithm state, allocated in <code>mkernel_mesh2d_initialize_orthogonalization</code> (interactive mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a40a8202bcfaa2902b5d42aed1cec50bb" name="a40a8202bcfaa2902b5d42aed1cec50bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a8202bcfaa2902b5d42aed1cec50bb">&#9670;&#160;</a></span>mkernel_mesh2d_delete_small_flow_edges_and_small_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_delete_small_flow_edges_and_small_triangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all small mesh2d flow edges and small triangles. The flow edges are the edges connecting faces circumcenters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>The ratio of the face area to the average area of neighboring non triangular faces. This parameter is used for determining if a triangular face is small. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad3d2485750b09cd54d44ce8a5d385dcd" name="ad3d2485750b09cd54d44ce8a5d385dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d2485750b09cd54d44ce8a5d385dcd">&#9670;&#160;</a></span>mkernel_mesh2d_finalize_inner_ortogonalization_iteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_finalize_inner_ortogonalization_iteration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the orthogonalization outer iteration, computing the new coefficients for grid adaption and the new face circumcenters (interactive mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a6dadc997b1571c5ba6cca3c178ceba14" name="a6dadc997b1571c5ba6cca3c178ceba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dadc997b1571c5ba6cca3c178ceba14">&#9670;&#160;</a></span>mkernel_mesh2d_flip_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_flip_edges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isTriangulationRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectingPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>landBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips mesh2d edges, to optimize the mesh smoothness. This operation is usually performed after <code>mkernel_mesh2d_refine_based_on_samples</code> or <code>mkernel_mesh2d_refine_based_on_polygon</code>. </p>
<p>Nodes that are connected to more than six other nodes are typically enclosed by faces of highly non-uniform shape and wildly varying areas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isTriangulationRequired</td><td>The option to triangulate also non triangular cells (if activated squares becomes triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryRequired</td><td>The option to determine how to snap to land boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selectingPolygon</td><td>The polygon where to perform the edge flipping (num_coordinates = 0 for an empty polygon) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landBoundaries</td><td>The land boundaries to account for when flipping the edges (num_coordinates = 0 for no land boundaries) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4b6df0f168c0bd9535114fd65a41ded1" name="a4b6df0f168c0bd9535114fd65a41ded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6df0f168c0bd9535114fd65a41ded1">&#9670;&#160;</a></span>mkernel_mesh2d_get_closest_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_closest_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinateIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinateIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xCoordinateOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yCoordinateOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the closest mesh2d node coordinates to a point, searching within a radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>Id of the grid state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinateIn</td><td>The x coordinate of the node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinateIn</td><td>The y coordinate of the node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The radii where to search for mesh nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftBoundingBox</td><td>The x coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftBoundingBox</td><td>The y coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightBoundingBox</td><td>The x coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightBoundingBox</td><td>The y coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xCoordinateOut</td><td>The x coordinate of the found <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yCoordinateOut</td><td>The y coordinate of the found <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a16c36845832e4dc42ce9437b844f5830" name="a16c36845832e4dc42ce9437b844f5830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c36845832e4dc42ce9437b844f5830">&#9670;&#160;</a></span>mkernel_mesh2d_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions data. </p>
<p>This function ought to be called after <code>mkernel_mesh2d_get_dimensions</code> has been called and the pointers have been set to correctly sized memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a67f563fcc78f0992f5a7b01a70ad7bb4" name="a67f563fcc78f0992f5a7b01a70ad7bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f563fcc78f0992f5a7b01a70ad7bb4">&#9670;&#160;</a></span>mkernel_mesh2d_get_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions. </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_mesh2d_get_data</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3f0a192a35692dbb03284457fb8730b1" name="a3f0a192a35692dbb03284457fb8730b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0a192a35692dbb03284457fb8730b1">&#9670;&#160;</a></span>mkernel_mesh2d_get_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>edgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the closest mesh2d edge to a point in a bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The x coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The y coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftBoundingBox</td><td>The x coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftBoundingBox</td><td>The y coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightBoundingBox</td><td>The x coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightBoundingBox</td><td>The y coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeIndex</td><td>The found edge index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a7017faa5415bfe805793341015380efd" name="a7017faa5415bfe805793341015380efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7017faa5415bfe805793341015380efd">&#9670;&#160;</a></span>mkernel_mesh2d_get_face_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_face_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>facePolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the faces polygons with a number of edges larger or equal to numEdges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numEdges</td><td>The number of edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facePolygons</td><td>The resulting face polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aed0ef73c3fc68077dfa50d6b1ab855b7" name="aed0ef73c3fc68077dfa50d6b1ab855b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0ef73c3fc68077dfa50d6b1ab855b7">&#9670;&#160;</a></span>mkernel_mesh2d_get_face_polygons_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_face_polygons_dimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>geometryListDimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the dimension of faces polygons with a number of edges larger or equal to numNodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numEdges</td><td>The number of edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListDimension</td><td>The dimension of the geometry list containing the face polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a094481597e69f34b232c40cbde0a8c7e" name="a094481597e69f34b232c40cbde0a8c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094481597e69f34b232c40cbde0a8c7e">&#9670;&#160;</a></span>mkernel_mesh2d_get_filtered_face_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_filtered_face_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>facePolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the geometry list containing the face polygons within the filtering range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The identifier of the mesh kernel or mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyValue</td><td>The property used to filter the locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minValue</td><td>The minimum value of the property. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxValue</td><td>The maximum value of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">facePolygons</td><td>The geometry list containing the filtered locations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values are retrieved from the cache, cached values are deleted after copying </dd></dl>

</div>
</div>
<a id="ac177194bf4d9998cf649f884f4210140" name="ac177194bf4d9998cf649f884f4210140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac177194bf4d9998cf649f884f4210140">&#9670;&#160;</a></span>mkernel_mesh2d_get_filtered_face_polygons_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_filtered_face_polygons_dimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>geometryListDimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the dimension of the geometry list containing the face polygons within the filtering range. </p>
<p>This function filters face polygons within a mesh based on a specific property and location, applying a range filter (minimum and maximum values). It then returns the dimension of the filtered geometry list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The identifier of the mesh kernel or mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyValue</td><td>The property used to filter the locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minValue</td><td>The minimum value of the property. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxValue</td><td>The maximum value of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListDimension</td><td>The output parameter that will store the dimension (size) of the geometry list containing the polygons that match the filtering criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code indicating the success or failure of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>property values are cached, so that they can be copied </dd></dl>

</div>
</div>
<a id="a2423ff72e320079ef555cbd7413fe767" name="a2423ff72e320079ef555cbd7413fe767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2423ff72e320079ef555cbd7413fe767">&#9670;&#160;</a></span>mkernel_mesh2d_get_hanging_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_hanging_edges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the indices of hanging edges. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edges</td><td>Pointer to memory where the indices of the hanging edges will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aab1d39c897149389496581641de8a216" name="aab1d39c897149389496581641de8a216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1d39c897149389496581641de8a216">&#9670;&#160;</a></span>mkernel_mesh2d_get_location_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_location_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_bounding_box.html">BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>locationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mesh location closet to a specific coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The input xCoordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The input yCoordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>The input bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">locationIndex</td><td>The location index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a9dd8b018fc9893667066ec6bc59a0107" name="a9dd8b018fc9893667066ec6bc59a0107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd8b018fc9893667066ec6bc59a0107">&#9670;&#160;</a></span>mkernel_mesh2d_get_mesh_boundaries_as_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_mesh_boundaries_as_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>boundaryPolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the boundaries of a mesh as a series of separated polygons. </p>
<p>For example, if a mesh has an single inner hole, two polygons will be generated, one for the inner boundary and one for the outer boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundaryPolygons</td><td>The output network boundary polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac69ba29d07c1fcbd9a1292693090eaef" name="ac69ba29d07c1fcbd9a1292693090eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69ba29d07c1fcbd9a1292693090eaef">&#9670;&#160;</a></span>mkernel_mesh2d_get_node_edge_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_node_edge_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets only the node and edge <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data. </p>
<p>This function ought to be called after <code>mkernel_mesh2d_get_dimensions</code> has been called and the node_x, node_y and edge_nodes pointers have been set to correctly sized memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a7157b97182f7c850d2e9af416c775e2a" name="a7157b97182f7c850d2e9af416c775e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7157b97182f7c850d2e9af416c775e2a">&#9670;&#160;</a></span>mkernel_mesh2d_get_node_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_node_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yLowerLeftBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yUpperRightBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the mesh2d node closest to a point, within a search radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The x coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The y coordinate of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The search radius </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xLowerLeftBoundingBox</td><td>The x coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yLowerLeftBoundingBox</td><td>The y coordinate of the lower left corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUpperRightBoundingBox</td><td>The x coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yUpperRightBoundingBox</td><td>The y coordinate of the upper right corner of the bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIndex</td><td>The index of the found node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="adad047db207caf19e8856257ad86123b" name="adad047db207caf19e8856257ad86123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad047db207caf19e8856257ad86123b">&#9670;&#160;</a></span>mkernel_mesh2d_get_nodes_in_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_nodes_in_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>selectedNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the indices of the mesh2d nodes selected with a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Selection of the nodes inside the polygon (1) or outside (0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedNodes</td><td>The selected nodes indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4913d907bdf44ddd4f981b2efc7b3bd7" name="a4913d907bdf44ddd4f981b2efc7b3bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4913d907bdf44ddd4f981b2efc7b3bd7">&#9670;&#160;</a></span>mkernel_mesh2d_get_obtuse_triangles_mass_centers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_obtuse_triangles_mass_centers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mass centers of obtuse mesh2d triangles. Obtuse triangles are those having one edge longer than the sum of the other two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The coordinates of the obtuse triangles mass centers stored in coordinates_x and coordinates_y of a <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aed83472a1ede3effc40d1a052ddf72cb" name="aed83472a1ede3effc40d1a052ddf72cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed83472a1ede3effc40d1a052ddf72cb">&#9670;&#160;</a></span>mkernel_mesh2d_get_orthogonality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_orthogonality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mesh orthogonality, expressed as the ratio between the edges and the segments connecting the face circumcenters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryList</td><td>The orthogonality values of each edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac99b420d3c788df828c023e79f5c7c31" name="ac99b420d3c788df828c023e79f5c7c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99b420d3c788df828c023e79f5c7c31">&#9670;&#160;</a></span>mkernel_mesh2d_get_orthogonality_property_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_orthogonality_property_type </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an int indicating the orthogonality property type for mesh2d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The int indicating the orthogonality property type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a816644a1b732b8ec3758d3c25f18e3a4" name="a816644a1b732b8ec3758d3c25f18e3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816644a1b732b8ec3758d3c25f18e3a4">&#9670;&#160;</a></span>mkernel_mesh2d_get_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_property </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>locationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometrylist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a specified property of a 2D mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyValue</td><td>The value representing the specific property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationId</td><td>The location (nodes, edge centres or face centres) at which the samples should interpolated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">geometrylist</td><td>A reference to a <a class="el" href="structmeshkernelapi_1_1_geometry_list.html" title="A struct used to describe a list of geometries in a C-compatible manner.">GeometryList</a> object that will be populated with the values of the requested property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a5b2686e90f73ffacb9c9ee363399337e" name="a5b2686e90f73ffacb9c9ee363399337e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2686e90f73ffacb9c9ee363399337e">&#9670;&#160;</a></span>mkernel_mesh2d_get_property_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_property_dimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The dimension of a specified property of a 2D mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyValue</td><td>The value representing the specific property </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimension</td><td>The dimension of the specified property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4c732d6cc407e5ef62f6ab00b423a908" name="a4c732d6cc407e5ef62f6ab00b423a908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c732d6cc407e5ef62f6ab00b423a908">&#9670;&#160;</a></span>mkernel_mesh2d_get_small_flow_edge_centers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_small_flow_edge_centers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the small mesh2d flow edges. The flow edges are the edges connecting faces circumcenters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting a small flow edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The middle points of the small flow edges, stored in coordinates_x and coordinates_y of a <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad95a652d65ce2650b4f490fcc901fb02" name="ad95a652d65ce2650b4f490fcc901fb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95a652d65ce2650b4f490fcc901fb02">&#9670;&#160;</a></span>mkernel_mesh2d_get_smoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_get_smoothness </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smoothness, expressed as the ratio between the values of two neighboring faces areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryList</td><td>The smoothness values at each edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac6d921edc9c4cd6801d8d5522d7aa809" name="ac6d921edc9c4cd6801d8d5522d7aa809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d921edc9c4cd6801d8d5522d7aa809">&#9670;&#160;</a></span>mkernel_mesh2d_initialize_orthogonalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_initialize_orthogonalization </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernel_1_1_orthogonalization_parameters.html">meshkernel::OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectingPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>landBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of the <a class="el" href="classmeshkernel_1_1_orthogonalization_and_smoothing.html">meshkernel::OrthogonalizationAndSmoothing</a> algorithm. </p>
<p>This is the first function to call when using orthogonalization in interactive mode (visualizing the grid while it is orthogonalizing), in order to set the internal state of the algorithm reused during the iterations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryOption</td><td>The option to determine how to snap to land boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The structure containing the user defined orthogonalization parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selectingPolygon</td><td>The polygon where to perform the orthogonalization (num_coordinates = 0 for an empty polygon) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landBoundaries</td><td>The land boundaries to account for in the orthogonalization process (num_coordinates = 0 for no land boundaries) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa38c500f59b002ad798c50b8dbf66b4b" name="aa38c500f59b002ad798c50b8dbf66b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38c500f59b002ad798c50b8dbf66b4b">&#9670;&#160;</a></span>mkernel_mesh2d_insert_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_insert_edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>newEdgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new mesh2d edge connecting two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The index of the first node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The index of the second node to connect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newEdgeIndex</td><td>The index of the new generated edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8b2fc2052f30acc0a11b7fbbab2ba9b9" name="a8b2fc2052f30acc0a11b7fbbab2ba9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2fc2052f30acc0a11b7fbbab2ba9b9">&#9670;&#160;</a></span>mkernel_mesh2d_insert_edge_from_coordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_insert_edge_from_coordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>firstNodeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>firstNodeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>secondNodeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>secondNodeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>firstNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>secondNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>edgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new mesh2d edge from 2 coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeX</td><td>The index of the first node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeY</td><td>The index of the second node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeX</td><td>The index of the first node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeY</td><td>The index of the second node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeIndex</td><td>The index of the first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeIndex</td><td>The index of the second node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeIndex</td><td>The index of the new generated edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a90f687ae29333b6400a412b82629c4ef" name="a90f687ae29333b6400a412b82629c4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f687ae29333b6400a412b82629c4ef">&#9670;&#160;</a></span>mkernel_mesh2d_insert_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_insert_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new mesh2d node at a specific coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The x coordinate of the node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The y coordinate of the node to insert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIndex</td><td>The index of the new mesh node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a43a38a425a4c575cd1de377a5ecad354" name="a43a38a425a4c575cd1de377a5ecad354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a38a425a4c575cd1de377a5ecad354">&#9670;&#160;</a></span>mkernel_mesh2d_intersections_from_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_intersections_from_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>boundaryPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>edgeNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>edgeDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>segmentDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segmentIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>faceIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>faceNumEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>faceEdgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges intersected by a polygon, with additional information on the intersections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundaryPolygon</td><td>An input polygon, defined as a series of points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeNodes</td><td>The indices of the intersected edge nodes. The first node of the edge is on the left (the virtual node), the second node of the edge is on the right (the inner node) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeIndex</td><td>For each intersected edge, the edge index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeDistances</td><td>For each intersection, the location of the intersection expressed as adimensional distance from the edge starting node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentDistances</td><td>For each intersection, the location of the intersection expressed as adimensional distance from the polygon segment start </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentIndexes</td><td>For each intersection, the segment index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceIndexes</td><td>For each intersection, the face index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceNumEdges</td><td>For each intersection, the number of intersections </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceEdgeIndex</td><td>For each intersection, the index of the intersected edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac8098267db254b7c57afe0ccfffcd18d" name="ac8098267db254b7c57afe0ccfffcd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8098267db254b7c57afe0ccfffcd18d">&#9670;&#160;</a></span>mkernel_mesh2d_is_valid_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_is_valid_property </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>propertyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>locationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>propertyIsAvailable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the property data for the mesh can be computed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyId</td><td>The id of the property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationId</td><td>The location (nodes, edge centres or face centres) at which the samples should interpolated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">propertyIsAvailable</td><td>Indicate (true or false) if the property can be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="afc659490a272d015ea79215b27419243" name="afc659490a272d015ea79215b27419243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc659490a272d015ea79215b27419243">&#9670;&#160;</a></span>mkernel_mesh2d_make_global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_global </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLongitudeNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLatitudeNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the global mesh with a given number of points along the longitude and latitude directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLongitudeNodes</td><td>The number of points along the longitude. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLatitudeNodes</td><td>The number of points along the latitude (half hemisphere). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a68a432823c03f75fefa35669bb712e0d" name="a68a432823c03f75fefa35669bb712e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a432823c03f75fefa35669bb712e0d">&#9670;&#160;</a></span>mkernel_mesh2d_make_rectangular_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_rectangular_mesh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a rectangular mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a66b026000339c8b861a465a968794c24" name="a66b026000339c8b861a465a968794c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b026000339c8b861a465a968794c24">&#9670;&#160;</a></span>mkernel_mesh2d_make_rectangular_mesh_from_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_rectangular_mesh_from_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a rectangular mesh from a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The polygons to account for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a6d559487b89e3bde2ed59bb1c8b00031" name="a6d559487b89e3bde2ed59bb1c8b00031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d559487b89e3bde2ed59bb1c8b00031">&#9670;&#160;</a></span>mkernel_mesh2d_make_rectangular_mesh_on_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_rectangular_mesh_on_extension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_make_grid_parameters.html">meshkernel::MakeGridParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a rectangular mesh on a defined extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a705012a0f338272507f22bb5832ad3be" name="a705012a0f338272507f22bb5832ad3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705012a0f338272507f22bb5832ad3be">&#9670;&#160;</a></span>mkernel_mesh2d_make_triangular_mesh_from_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_triangular_mesh_from_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a triangular mesh2d grid within a polygon. The size of the triangles is determined from the length of the polygon edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonPoints</td><td>The polygon where to triangulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3459011bc43e11d1e6852914279eb0c3" name="a3459011bc43e11d1e6852914279eb0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3459011bc43e11d1e6852914279eb0c3">&#9670;&#160;</a></span>mkernel_mesh2d_make_triangular_mesh_from_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_make_triangular_mesh_from_samples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a triangular mesh from a set of samples, triangulating the sample points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples where to triangulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a06ff49944a2e931a0bf54b8cd7fe610e" name="a06ff49944a2e931a0bf54b8cd7fe610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ff49944a2e931a0bf54b8cd7fe610e">&#9670;&#160;</a></span>mkernel_mesh2d_merge_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_merge_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the mesh2d nodes within a distance of 0.001 m, effectively removing all small edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon defining the area where the operation will be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aae177d47f9f0ae7eee4e51e7dfb47217" name="aae177d47f9f0ae7eee4e51e7dfb47217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae177d47f9f0ae7eee4e51e7dfb47217">&#9670;&#160;</a></span>mkernel_mesh2d_merge_nodes_with_merging_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_merge_nodes_with_merging_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mergingDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the mesh2d nodes within a distance of 0.001 m, effectively removing all small edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon defining the area where the operation will be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mergingDistance</td><td>The distance below which two nodes will be merged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4c0c58950912873ea5540775cb1c3b89" name="a4c0c58950912873ea5540775cb1c3b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0c58950912873ea5540775cb1c3b89">&#9670;&#160;</a></span>mkernel_mesh2d_merge_two_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_merge_two_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two mesh2d nodes into one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The index of the first node to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The index of the second node to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a744a1d9dcec872bb2fcb07dcf01dc326" name="a744a1d9dcec872bb2fcb07dcf01dc326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744a1d9dcec872bb2fcb07dcf01dc326">&#9670;&#160;</a></span>mkernel_mesh2d_move_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_move_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a mesh2d node to a new position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>The new x coordinate of the node to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>The new y coordinate of the node to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>The index of the mesh2d node to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3ef99054ee1c2c570e530c3dbb58ddcf" name="a3ef99054ee1c2c570e530c3dbb58ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef99054ee1c2c570e530c3dbb58ddcf">&#9670;&#160;</a></span>mkernel_mesh2d_prepare_outer_iteration_orthogonalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_prepare_outer_iteration_orthogonalization </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares an outer orthogonalization iteration, computing the new orthogonalization and smoothing weights from the modified mesh geometry (in interactive mode). </p>
<p><code>mkernel_mesh2d_initialize_orthogonalization</code> function must be called before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa40793b2bcadef556033eb378fe8dfc0" name="aa40793b2bcadef556033eb378fe8dfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40793b2bcadef556033eb378fe8dfc0">&#9670;&#160;</a></span>mkernel_mesh2d_refine_based_on_gridded_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_refine_based_on_gridded_samples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_gridded_samples.html">GriddedSamples</a> &amp;&#160;</td>
          <td class="paramname"><em>griddedSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNodalRefinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine based on gridded samples. </p>
<p>The number of successive splits is indicated on the sample value. For example a value of 0 means no split and hence no refinement, a value of 1 a single split (a quadrilateral face generates 4 faces), a value of 2 two splits (a quadrilateral face generates 16 faces). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">griddedSamples</td><td>The gridded samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useNodalRefinement</td><td>Use nodal refinement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa4e296f36170b57a36cea8efc3f2a365" name="aa4e296f36170b57a36cea8efc3f2a365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e296f36170b57a36cea8efc3f2a365">&#9670;&#160;</a></span>mkernel_mesh2d_refine_based_on_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_refine_based_on_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a mesh2d within a polygon. Refinement is achieved by splitting the edges contained in the polygon by two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The closed polygon where to perform the refinement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a7dda13ff3814870fa33c6b06e01f7ccd" name="a7dda13ff3814870fa33c6b06e01f7ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dda13ff3814870fa33c6b06e01f7ccd">&#9670;&#160;</a></span>mkernel_mesh2d_refine_based_on_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_refine_based_on_samples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relativeSearchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumNumSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a mesh2d based on samples. Refinement is achieved by successive splits of the face edges. </p>
<p>The number of successive splits is indicated on the sample value. For example a value of 0 means no split and hence no refinement, a value of 1 a single split (a quadrilateral face generates 4 faces), a value of 2 two splits (a quadrilateral face generates 16 faces). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The sample set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeSearchRadius</td><td>The relative search radius relative to the face size, used for some interpolation algorithms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimumNumSamples</td><td>The minimum number of samples used for some averaging algorithms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8657de73c9b65364990432552ff825e2" name="a8657de73c9b65364990432552ff825e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8657de73c9b65364990432552ff825e2">&#9670;&#160;</a></span>mkernel_mesh2d_refine_ridges_based_on_gridded_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_refine_ridges_based_on_gridded_samples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_gridded_samples.html">GriddedSamples</a> &amp;&#160;</td>
          <td class="paramname"><em>griddedSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relativeSearchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumNumSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfSmoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_mesh_refinement_parameters.html">meshkernel::MeshRefinementParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>meshRefinementParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a mesh2d based on samples with ridge refinement. This method automatically detects the ridges in a sample set. </p>
<p>The number of successive splits is indicated on the sample value. For example a value of 0 means no split and hence no refinement, a value of 1 a single split (a quadrilateral face generates 4 faces), a value of 2 two splits (a quadrilateral face generates 16 faces). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">griddedSamples</td><td>The gridded samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeSearchRadius</td><td>The relative search radius relative to the face size, used for some interpolation algorithms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimumNumSamples</td><td>The minimum number of samples used for some averaging algorithms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfSmoothingIterations</td><td>The number of smoothing iterations to apply to the input sample set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshRefinementParameters</td><td>The mesh refinement parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a51b8b6364302aacea2b8461008c91993" name="a51b8b6364302aacea2b8461008c91993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b8b6364302aacea2b8461008c91993">&#9670;&#160;</a></span>mkernel_mesh2d_remove_disconnected_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_remove_disconnected_regions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any disconnected regions from a mesh2d. </p>
<p>The assumption is that the main region of interest has the largest number of elements. Regions with fewer elements that this will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91a3589ccdc1570cb64308aef54deb7d" name="a91a3589ccdc1570cb64308aef54deb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a3589ccdc1570cb64308aef54deb7d">&#9670;&#160;</a></span>mkernel_mesh2d_rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_rotate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>centreX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>centreY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a mesh2d about a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centreX</td><td>X-coordinate of the centre of rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centreY</td><td>Y-coordinate of the centre of rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>Angle of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa8871161744c899f45413808e2ebbbfb" name="aa8871161744c899f45413808e2ebbbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8871161744c899f45413808e2ebbbfb">&#9670;&#160;</a></span>mkernel_mesh2d_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a07556a2e2ed6373cc65d5d2aedf1ebf3" name="a07556a2e2ed6373cc65d5d2aedf1ebf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07556a2e2ed6373cc65d5d2aedf1ebf3">&#9670;&#160;</a></span>mkernel_mesh2d_set_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_set_property </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>sampleData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>propertyId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the property data for the mesh, the sample data points do not have to match the mesh2d nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projectionType</td><td>The projection type used by the sample data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolationType</td><td>The type of interpolation required, triangulation (0) or averaging (1) (for now) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleData</td><td>The sample data and associated sample data points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">propertyId</td><td>The id of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac3189a745b36940d51c81b607cf85ee4" name="ac3189a745b36940d51c81b607cf85ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3189a745b36940d51c81b607cf85ee4">&#9670;&#160;</a></span>mkernel_mesh2d_snap_to_landboundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_snap_to_landboundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectingPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>landBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snaps a mesh to a land boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selectingPolygon</td><td>The polygon where to perform the snapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landBoundaries</td><td>The input land boundaries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af4998517f14650d76335174d52c40d7b" name="af4998517f14650d76335174d52c40d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4998517f14650d76335174d52c40d7b">&#9670;&#160;</a></span>mkernel_mesh2d_split_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_split_row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An-isotropically refines the elements along a row or column, given a starting edge. </p>
<p>Only quadrilateral elements will be refined. Refinement will continue upto the boundary of the domain or when a non-quadrilateral element is encountered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The first node of the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The second node of the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a85b25c255f1bf9207093b9d98ca1011d" name="a85b25c255f1bf9207093b9d98ca1011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b25c255f1bf9207093b9d98ca1011d">&#9670;&#160;</a></span>mkernel_mesh2d_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>translationX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>translationY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a mesh2d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">translationX</td><td>X-component of the translation vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">translationY</td><td>Y-component of the translation vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a91b94c6f1ad7b5e521d17453a944bacd" name="a91b94c6f1ad7b5e521d17453a944bacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b94c6f1ad7b5e521d17453a944bacd">&#9670;&#160;</a></span>mkernel_mesh2d_triangulation_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_mesh2d_triangulation_interpolation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangle interpolation (ec_module) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_triangulation_interpolation.html" title="A class used for triangulation interpolation.">meshkernel::TriangulationInterpolation</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples coordinates and values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type (see <a class="el" href="namespacemeshkernel.html#a50aa377deae5c143c4fc0ba767f051d9">meshkernel::Location</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">results</td><td>The interpolation results with x and y coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a374a958ce04cf210d3daf85eb03c88fc" name="a374a958ce04cf210d3daf85eb03c88fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374a958ce04cf210d3daf85eb03c88fc">&#9670;&#160;</a></span>mkernel_network1d_compute_fixed_chainages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_network1d_compute_fixed_chainages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fixedChainages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeFixedChainages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFaceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fixedChainagesOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the network chainages from fixed point locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixedChainages</td><td>The fixed chainages for each polyline. Chunks are separated by the separator, each chunk corresponds to a polyline </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeFixedChainages</td><td>The size of fixed chainages vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minFaceSize</td><td>The minimum face size. The distance between two chainages must be no less than this length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixedChainagesOffset</td><td>The offset to use for fixed chainages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad26aca7c00112d28304ffff67edc80ce" name="ad26aca7c00112d28304ffff67edc80ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26aca7c00112d28304ffff67edc80ce">&#9670;&#160;</a></span>mkernel_network1d_compute_offsetted_chainages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_network1d_compute_offsetted_chainages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the network chainages at a regular offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset between points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac4682752f4cbc06cc28c6e428e673cce" name="ac4682752f4cbc06cc28c6e428e673cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4682752f4cbc06cc28c6e428e673cce">&#9670;&#160;</a></span>mkernel_network1d_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_network1d_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmeshkernel_1_1_network1_d.html" title="A class describing a network 1d.">meshkernel::Network1D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polylines</td><td>The polylines describing the network </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a11e87cdf29b5b6ed204a0594b9e1bf08" name="a11e87cdf29b5b6ed204a0594b9e1bf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e87cdf29b5b6ed204a0594b9e1bf08">&#9670;&#160;</a></span>mkernel_network1d_to_mesh1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_network1d_to_mesh1d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert network chainages to mesh1d nodes and edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minFaceSize</td><td>The minimum face size below which two nodes will be merged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1dc137eac3dfb82f608df3a1395f1f98" name="a1dc137eac3dfb82f608df3a1395f1f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc137eac3dfb82f608df3a1395f1f98">&#9670;&#160;</a></span>mkernel_polygon_count_linear_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_count_linear_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonToRefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of polygon nodes resulting from polygon refinement with <code>mkernel_polygon_linear_refine</code>. </p>
<p>This function should be used by clients before <code>mkernel_polygon_linear_refine</code> for allocating <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> containing the refinement result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonToRefine</td><td>The input polygon to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>The first index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIndex</td><td>The second index of the refinement interval </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of nodes after refinement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refined polygon values are cached, so that they can be copied in the mkernel_polygon_linear_refine </dd></dl>

</div>
</div>
<a id="a29f926bf97f94392fec1a88b6d32d0d4" name="a29f926bf97f94392fec1a88b6d32d0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f926bf97f94392fec1a88b6d32d0d4">&#9670;&#160;</a></span>mkernel_polygon_count_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_count_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>innerPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of polygon nodes resulting from polygon offset. </p>
<p>This function should be used by clients before <code>mkernel_polygon_get_offset</code> for allocating the <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> containing the offset result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon to offset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">innerPolygon</td><td>Whether to compute inner (1) or outer offset (0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The offset distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of nodes in the offset polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3a8116b16cb7763092d273cf184b626e" name="a3a8116b16cb7763092d273cf184b626e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8116b16cb7763092d273cf184b626e">&#9670;&#160;</a></span>mkernel_polygon_count_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_count_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonToRefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of polygon nodes resulting from polygon refinement with <code>mkernel_polygon_refine</code>. </p>
<p>This function should be used by clients before <code>mkernel_polygon_refine</code> for allocating <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> containing the refinement result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonToRefine</td><td>The input polygon to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>The first index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIndex</td><td>The second index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The target interval edge length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of nodes after refinement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refined polygon values are cached, so that they can be copied in the mkernel_polygon_refine </dd></dl>

</div>
</div>
<a id="affe136285361f89d9d13b87f7a7f5a84" name="affe136285361f89d9d13b87f7a7f5a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe136285361f89d9d13b87f7a7f5a84">&#9670;&#160;</a></span>mkernel_polygon_get_included_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_get_included_points </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectingPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonToSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectionResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the polygon nodes within another polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selectingPolygon</td><td>The selecting polygon (num_coordinates = 0 for an empty polygon) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonToSelect</td><td>The polygon to select </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectionResults</td><td>The selection result, contained in the in the values field of <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> (0.0 not selected, 1.0 selected). Note that the selection selectionResults variable must be allocated by the client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3833a1ecc2962cd39b9ea36a2982392e" name="a3833a1ecc2962cd39b9ea36a2982392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3833a1ecc2962cd39b9ea36a2982392e">&#9670;&#160;</a></span>mkernel_polygon_get_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_get_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inWard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new polygon from an existing one by offsetting the perimeter by a given distance. </p>
<p>Offsetting can be done inward or outward the existing polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon to offset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inWard</td><td>Compute the inner offset (1) or outer offset offset (0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The offset distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListOut</td><td>The resulting offset polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad5b2005ba0b8863486bb12e374d20d26" name="ad5b2005ba0b8863486bb12e374d20d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b2005ba0b8863486bb12e374d20d26">&#9670;&#160;</a></span>mkernel_polygon_linear_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_linear_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonToRefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>refinedPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear refines the polygon perimeter between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonToRefine</td><td>The input polygon to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeIndex</td><td>The first index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeIndex</td><td>The second index of the refinement interval </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">refinedPolygon</td><td>The refined polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values are retrieved from the cache, cached values are cleared after copying </dd></dl>

</div>
</div>
<a id="aeab0dd1a911d90ab8ec462d2eec86e14" name="aeab0dd1a911d90ab8ec462d2eec86e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab0dd1a911d90ab8ec462d2eec86e14">&#9670;&#160;</a></span>mkernel_polygon_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_refine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonToRefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>targetEdgeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>refinedPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the polygon perimeter between two nodes. This interval is refined to achieve a target edge length. </p>
<p>The function is often used before <code>mkernel_mesh2d_make_triangular_mesh_from_polygon</code>, for generating a triangular mesh where edges have a desired length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonToRefine</td><td>The input polygon to refine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNodeIndex</td><td>The first index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNodeIndex</td><td>The second index of the refinement interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetEdgeLength</td><td>The target interval edge length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">refinedPolygon</td><td>The refined polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values are retrieved from the cache, cached values are cleared after copying </dd></dl>

</div>
</div>
<a id="ab09fcdfed55040bf17cadff45647d1a6" name="ab09fcdfed55040bf17cadff45647d1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09fcdfed55040bf17cadff45647d1a6">&#9670;&#160;</a></span>mkernel_polygon_snap_to_landboundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_polygon_snap_to_landboundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>land</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snaps the polygon to the land boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">land</td><td>The land boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon values to be snapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>The start index of the polygon points to be snapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIndex</td><td>The end index of the polygon points to be snapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3f2c4a68c9f17c7401f226b8e3f81070" name="a3f2c4a68c9f17c7401f226b8e3f81070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2c4a68c9f17c7401f226b8e3f81070">&#9670;&#160;</a></span>mkernel_redo_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_redo_state </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>redone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>meshKernelId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to redo by one undo-action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">redone</td><td>Indicates if the redo action was actually redone </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshKernelId</td><td>The mesh kernel id related to the undo action </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aca112975478ad5720cab80bd3330c7a0" name="aca112975478ad5720cab80bd3330c7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca112975478ad5720cab80bd3330c7a0">&#9670;&#160;</a></span>mkernel_set_undo_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_set_undo_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>undoStackSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum size of the undo stack. </p>
<p>Setting the size to zero will disable the undo. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">undoStackSize</td><td>The maximum size of the undo stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af0a396a0ad56ec345564e4ae9db73e11" name="af0a396a0ad56ec345564e4ae9db73e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a396a0ad56ec345564e4ae9db73e11">&#9670;&#160;</a></span>mkernel_splines_snap_to_landboundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_splines_snap_to_landboundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>land</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startSplineIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endSplineIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snaps the spline (or splines) to the land boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">land</td><td>The land boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splines</td><td>The spline values to be snapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startSplineIndex</td><td>The start index of the splines to be snapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endSplineIndex</td><td>The end index of the splines to be snapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af1e78675445f77fcf3fdfa7d2d3ea972" name="af1e78675445f77fcf3fdfa7d2d3ea972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e78675445f77fcf3fdfa7d2d3ea972">&#9670;&#160;</a></span>mkernel_undo_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_undo_state </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>undone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>meshKernelId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to undo by one undo-action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">undone</td><td>Indicates if the undo action was actually undone </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshKernelId</td><td>The mesh kernel id related to the undo action </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aef00f9a1f84dd07f80ae270d908f2b0a" name="aef00f9a1f84dd07f80ae270d908f2b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef00f9a1f84dd07f80ae270d908f2b0a">&#9670;&#160;</a></span>mkernel_undo_state_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_undo_state_count </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>committedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>restoredCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of undo actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">committedCount</td><td>The number of undo actions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">restoredCount</td><td>The number of restored undo actions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1984f7e35632db869ead6e5eeeabf86c" name="a1984f7e35632db869ead6e5eeeabf86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1984f7e35632db869ead6e5eeeabf86c">&#9670;&#160;</a></span>mkernel_undo_state_count_for_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_undo_state_count_for_id </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>committedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>restoredCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of undo actions for a particular meshKernelId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">committedCount</td><td>The number of undo actions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">restoredCount</td><td>The number of restored undo actions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
