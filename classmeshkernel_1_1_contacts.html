<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Contacts Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_contacts.html">Contacts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmeshkernel_1_1_contacts-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">meshkernel::Contacts Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class describing an 1d-2d contacts.  
 <a href="classmeshkernel_1_1_contacts.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2_mesh_kernel_2_contacts_8hpp_source.html">Contacts.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeaa17c47cdb353019fb441cba2e9bb0b" id="r_aeaa17c47cdb353019fb441cba2e9bb0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#aeaa17c47cdb353019fb441cba2e9bb0b">Contacts</a> (<a class="el" href="classmeshkernel_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d, <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:aeaa17c47cdb353019fb441cba2e9bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor taking the 1d and 2d meshes to connect.  <br /></td></tr>
<tr class="separator:aeaa17c47cdb353019fb441cba2e9bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70433c574488cf7db9600e63f9c37f5e" id="r_a70433c574488cf7db9600e63f9c37f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#a70433c574488cf7db9600e63f9c37f5e">ComputeSingleContacts</a> (const std::vector&lt; bool &gt; &amp;oneDNodeMask, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double projectionFactor)</td></tr>
<tr class="memdesc:a70433c574488cf7db9600e63f9c37f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll).  <br /></td></tr>
<tr class="separator:a70433c574488cf7db9600e63f9c37f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f91875d5a0da23ffbb679e428aa94a3" id="r_a7f91875d5a0da23ffbb679e428aa94a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#a7f91875d5a0da23ffbb679e428aa94a3">ComputeMultipleContacts</a> (const std::vector&lt; bool &gt; &amp;oneDNodeMask)</td></tr>
<tr class="memdesc:a7f91875d5a0da23ffbb679e428aa94a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll).  <br /></td></tr>
<tr class="separator:a7f91875d5a0da23ffbb679e428aa94a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198d5ed49e69fcf8700ce9cf34b4f081" id="r_a198d5ed49e69fcf8700ce9cf34b4f081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#a198d5ed49e69fcf8700ce9cf34b4f081">ComputeContactsWithPolygons</a> (const std::vector&lt; bool &gt; &amp;oneDNodeMask, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons)</td></tr>
<tr class="memdesc:a198d5ed49e69fcf8700ce9cf34b4f081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll).  <br /></td></tr>
<tr class="separator:a198d5ed49e69fcf8700ce9cf34b4f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f82c10642d3e8b2d9e8bab6b07006" id="r_acf4f82c10642d3e8b2d9e8bab6b07006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#acf4f82c10642d3e8b2d9e8bab6b07006">ComputeContactsWithPoints</a> (const std::vector&lt; bool &gt; &amp;oneDNodeMask, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:acf4f82c10642d3e8b2d9e8bab6b07006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll).  <br /></td></tr>
<tr class="separator:acf4f82c10642d3e8b2d9e8bab6b07006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec01984b66446a3db7cd48de077e5df" id="r_a4ec01984b66446a3db7cd48de077e5df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#a4ec01984b66446a3db7cd48de077e5df">ComputeBoundaryContacts</a> (const std::vector&lt; bool &gt; &amp;oneDNodeMask, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double searchRadius)</td></tr>
<tr class="memdesc:a4ec01984b66446a3db7cd48de077e5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll).  <br /></td></tr>
<tr class="separator:a4ec01984b66446a3db7cd48de077e5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7a955dec84f9acab705af7dc6d82ff" id="r_aaa7a955dec84f9acab705af7dc6d82ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#aaa7a955dec84f9acab705af7dc6d82ff">Mesh1dIndices</a> () const</td></tr>
<tr class="memdesc:aaa7a955dec84f9acab705af7dc6d82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 1d mesh indices.  <br /></td></tr>
<tr class="separator:aaa7a955dec84f9acab705af7dc6d82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95325a340af78f6ce4f2700ecb37195" id="r_ae95325a340af78f6ce4f2700ecb37195"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#ae95325a340af78f6ce4f2700ecb37195">Mesh2dIndices</a> () const</td></tr>
<tr class="memdesc:ae95325a340af78f6ce4f2700ecb37195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 2d mesh indices.  <br /></td></tr>
<tr class="separator:ae95325a340af78f6ce4f2700ecb37195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80306ee59b6c43fc7cfd2fc587a0111" id="r_ae80306ee59b6c43fc7cfd2fc587a0111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#ae80306ee59b6c43fc7cfd2fc587a0111">SetIndices</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">meshkernel::UInt</a> &gt; &amp;mesh1dIndices, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">meshkernel::UInt</a> &gt; &amp;mesh2dIndices)</td></tr>
<tr class="memdesc:ae80306ee59b6c43fc7cfd2fc587a0111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 1d and 2d mesh indices.  <br /></td></tr>
<tr class="separator:ae80306ee59b6c43fc7cfd2fc587a0111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114f4c40a92aff503117d84bf795d70" id="r_a0114f4c40a92aff503117d84bf795d70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_contacts.html#a0114f4c40a92aff503117d84bf795d70">AreComputed</a> () const</td></tr>
<tr class="memdesc:a0114f4c40a92aff503117d84bf795d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether contacts have been computed  <br /></td></tr>
<tr class="separator:a0114f4c40a92aff503117d84bf795d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class describing an 1d-2d contacts. </p>
<p>The responsibility of the <a class="el" href="classmeshkernel_1_1_contacts.html" title="A class describing an 1d-2d contacts.">Contacts</a> class is connecting a 1d mesh to a 2d mesh. The class has a reference to the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">Mesh1D</a> and the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">Mesh2D</a> instances that will be connected. A contact is defined by the indices of the connected 1d node and 2d face. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeaa17c47cdb353019fb441cba2e9bb0b" name="aeaa17c47cdb353019fb441cba2e9bb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa17c47cdb353019fb441cba2e9bb0b">&#9670;&#160;</a></span>Contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Contacts::Contacts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor taking the 1d and 2d meshes to connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1d</td><td>The mesh1d to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The mesh2d to connect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0114f4c40a92aff503117d84bf795d70" name="a0114f4c40a92aff503117d84bf795d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0114f4c40a92aff503117d84bf795d70">&#9670;&#160;</a></span>AreComputed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool meshkernel::Contacts::AreComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether contacts have been computed </p>
<dl class="section return"><dt>Returns</dt><dd>True if the contact is crossing an existing contact </dd></dl>

</div>
</div>
<a id="a4ec01984b66446a3db7cd48de077e5df" name="a4ec01984b66446a3db7cd48de077e5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec01984b66446a3db7cd48de077e5df">&#9670;&#160;</a></span>ComputeBoundaryContacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::ComputeBoundaryContacts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll). </p>
<p>The algorithms works as follows:</p><ul>
<li>For each 1d node, find the closest 2d boundary faces within the search radius.</li>
<li>If a boundary face can be connected to multiple oned nodes, choose the closest one.</li>
<li>Generate the 1d-2d contacts.Index m_numM = 0; ///&lt; Number of columns in the curvilinear grid <div class="image">
<img src="ComputeBoundaryContacts.jpg" alt=""/>
<div class="caption">
1d mesh connecting to 2d mesh using the ComputeBoundaryContacts algorithm. Contacts are shown in red.</div></div>
 The mesh 2d boundary faces are connected to the closest 1d nodes."</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (true = connect node, false = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons selecting the area where the 1d-2d contacts will be generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The radius used for searching neighboring faces, if equal to constants::missing::doubleValue, the search radius will be calculated internally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4f82c10642d3e8b2d9e8bab6b07006" name="acf4f82c10642d3e8b2d9e8bab6b07006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4f82c10642d3e8b2d9e8bab6b07006">&#9670;&#160;</a></span>ComputeContactsWithPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::ComputeContactsWithPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll). </p>
<p>With this algorithm, each 2d face containing a point is connected to the 1d node closest to point itself. The search of the 2d faces and the closest 1d nodes uses RTrees. </p><div class="image">
<img src="ComputeContactsWithPoints.jpg" alt=""/>
<div class="caption">
2d faces containing the input points connecting to the 1d mesh. Contacts are shown in red and the input points in blue.</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (true = connect node, false = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The points selecting the faces to connect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a198d5ed49e69fcf8700ce9cf34b4f081" name="a198d5ed49e69fcf8700ce9cf34b4f081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198d5ed49e69fcf8700ce9cf34b4f081">&#9670;&#160;</a></span>ComputeContactsWithPolygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::ComputeContactsWithPolygons </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll). </p>
<p>The algorithms works as follows:</p><ul>
<li>Find the 2d face within each polygon closest to a 1d node.</li>
<li>Per polygon create one contact from the 2d circumcenters to the 1d node. <div class="image">
<object type="image/svg+xml" data="ComputeContactsWithPolygons.svg" style="pointer-events: none;"></object>
<div class="caption">
1d mesh connecting to 2d mesh using the ComputeContactsWithPolygons algorithm. Contacts are shown in red. Polygons in green.</div></div>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (true = connect node, false = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons to connect (<a class="el" href="classmeshkernel_1_1_polygons.html" title="A class containing a list of polygonaly enclosed regions.">Polygons</a> class can have multiple polygons) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f91875d5a0da23ffbb679e428aa94a3" name="a7f91875d5a0da23ffbb679e428aa94a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f91875d5a0da23ffbb679e428aa94a3">&#9670;&#160;</a></span>ComputeMultipleContacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::ComputeMultipleContacts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll). </p>
<p>Each internal 1d node is connected to multiple 2d faces. This type of contacts should be used when the lengths of the 1d mesh edges are considerably larger than the 2d mesh edges and generating a single contact for each 1d node is not sufficient. In this algorithm, only the internal 1d nodes are connected. The following figure shows a 1d mesh overlapping a 2d mesh. For the node n, the closest 2d faces within a search radius are found and it is determined if those faces cross are crossed by the current 1d edge starting at node n and ending at and n+1. If the answer is positive, a contact is generated between the face and the closest 1d node composing the current 1d edge (i.e. n or n+1). The procedure is repeated for each 1d node. </p><div class="image">
<img src="ComputeMultipleContacts.jpg" alt=""/>
<div class="caption">
1d mesh connecting to 2d mesh using the ComputeMultipleContacts algorithm. Contacts are shown in red.</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (true = connect node, false = do not generate contacts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70433c574488cf7db9600e63f9c37f5e" name="a70433c574488cf7db9600e63f9c37f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70433c574488cf7db9600e63f9c37f5e">&#9670;&#160;</a></span>ComputeSingleContacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::ComputeSingleContacts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projectionFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll). </p>
<p>Each non-boundary 1d node is connected to single 2d face. The figure below shows two 2d meshes, a 1d mesh between them, and the 1d-2d contacts (in red). For the 1d nodes not overlapping a 2d mesh, a ray starting from the current node n is computed (dashed blue ray). This ray is normal to the segment connecting the previous (n-1) and next one 1d node (n+1), the connecting segment is shown with a green dashed line. The ray is extended for 5 times the length of the connecting segment. The current 1d node is connected to the first boundary 2d face crossing the ray, first in the left direction and then in the right direction. By doing so a 1d mesh can be connected on the left and right sides of a mesh 2d boundary, for example when the 1d part represents a river and the 2d part the river banks. The 1d nodes overlapping the 2d mesh are directly connected to the face including them. </p><div class="image">
<img src="ComputeSingleContacts.jpg" alt=""/>
<div class="caption">
1d mesh connecting to 2d mesh using the ComputeSingleContacts algorithm. Contacts are shown in red.</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (true = connect node, false = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons selecting the area where the 1d-2d contacts will be generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectionFactor</td><td>The projection factor used for generating contacts when 1d nodes are not inside mesh2d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7a955dec84f9acab705af7dc6d82ff" name="aaa7a955dec84f9acab705af7dc6d82ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7a955dec84f9acab705af7dc6d82ff">&#9670;&#160;</a></span>Mesh1dIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; const  &amp; meshkernel::Contacts::Mesh1dIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 1d mesh indices. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmeshkernel_1_1_vector.html" title="A class defining a vector.">Vector</a> of 1d mesh indices </dd></dl>

</div>
</div>
<a id="ae95325a340af78f6ce4f2700ecb37195" name="ae95325a340af78f6ce4f2700ecb37195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95325a340af78f6ce4f2700ecb37195">&#9670;&#160;</a></span>Mesh2dIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; const  &amp; meshkernel::Contacts::Mesh2dIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 2d mesh indices. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmeshkernel_1_1_vector.html" title="A class defining a vector.">Vector</a> of 2d mesh indices </dd></dl>

</div>
</div>
<a id="ae80306ee59b6c43fc7cfd2fc587a0111" name="ae80306ee59b6c43fc7cfd2fc587a0111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80306ee59b6c43fc7cfd2fc587a0111">&#9670;&#160;</a></span>SetIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Contacts::SetIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">meshkernel::UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh1dIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">meshkernel::UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh2dIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the 1d and 2d mesh indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1dIndices</td><td>The 1d mesh indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2dIndices</td><td>The 2d mesh indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="include_2_mesh_kernel_2_contacts_8hpp_source.html">Contacts.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
