<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Design</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The choices made for the representation of the geometric entities have a strong influence on library design and performance. In MeshKernel an unstructured mesh is uniquely defined by two entities:</p>
<ul>
<li>The nodes vector: represented using <code>std::vector&lt;Point&gt;</code>, where <code>Point</code> is a structure containing the 2D coordinates of a point (cartesian or spherical).</li>
<li>The edges vector: represented using an <code>std::vector&lt;std::pair&lt;size_t,size_t&gt;&gt;</code>, containing the start and the end indices of the edges in the node vector described above.</li>
</ul>
<p>All other mesh properties are computed from these two entities, such as the face nodes, the face edges, the faces mass centers, and the faces circumcenters. See <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a> for some more details.</p>
<p>MeshKernel has an API namespace (<a class="el" href="namespacemeshkernelapi.html">meshkernelapi</a>) and a back-end namespace (<a class="el" href="namespacemeshkernel.html">meshkernel</a>), where the classes implementing the algorithms are included. <a class="el" href="namespacemeshkernelapi.html">meshkernelapi</a> contains the library API methods and several structures are used for communicating with the clients. These structures must be replicated in the client applications and filled with appropriate values.</p>
<p>When the client application creates a new mesh two API calls are required: in the first call (<a class="el" href="namespacemeshkernelapi.html#a8e737d3ce03b109b6aaff17396f63aac">meshkernelapi::mkernel_allocate_state</a>) a new entry is created in the <code>meshInstances</code> container, and in the second call (e.g. <a class="el" href="namespacemeshkernelapi.html#aa8871161744c899f45413808e2ebbbfb">meshkernelapi::mkernel_mesh2d_set</a>) the entry is set using the nodes and edges information obtained from the client. After this call, the mesh with all computed mappings is stored in memory and is ready to be used by the algorithms (the library keeps the mesh state).</p>
<p>The client now calls the <a class="el" href="namespacemeshkernelapi.html#af7dcad0b0efd5e3fce4d248420eb8be1">meshkernelapi::mkernel_mesh2d_refine_based_on_samples</a> function. In the local scope of the <a class="el" href="namespacemeshkernelapi.html#af7dcad0b0efd5e3fce4d248420eb8be1">meshkernelapi::mkernel_mesh2d_refine_based_on_samples</a> function an instance of the <a class="el" href="classmeshkernel_1_1_mesh_refinement.html">meshkernel::MeshRefinement</a> class is created, the Refine method is executed and the resulting mesh is saved in the <code>meshInstances</code> vector. The client retrieves the dimensions of the last state of the mesh using the <a class="el" href="namespacemeshkernelapi.html#a67f563fcc78f0992f5a7b01a70ad7bb4">meshkernelapi::mkernel_mesh2d_get_dimensions</a> function. After allocating the necessary memory, the meshkernelapi::mkernel_get_mesh2d_data function should be called, where all information required for rendering the new mesh (the nodes, the edges, and the faces) is copied from the library state to flat arrays. This extra copy is required for clients that cannot communicate an array of structures at the API level (C# and C++ clients could potentially do this, FORTRAN clients not ).</p>
<p>By using this design only the mesh instances are saved throughout the API calls and all other algorithm classes act as mesh modifiers, and are destroyed automatically after the API call is completed. Exceptions to this rule are the algorithms supporting interactivity. In these cases, the algorithms are divided into several API methods, and their instances survive until an explicit "delete" method is invoked (e.g. <a class="el" href="namespacemeshkernelapi.html#a24115f31dde1cfe7e388729dbd23b814">meshkernelapi::mkernel_mesh2d_delete_orthogonalization</a>). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
